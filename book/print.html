<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h1 id="z-shell-用户指南"><a class="header" href="#z-shell-用户指南">Z-Shell 用户指南</a></h1>
<h2 id="peter-stephenson"><a class="header" href="#peter-stephenson">Peter Stephenson</a></h2>
<h2 id="20030323"><a class="header" href="#20030323">2003/03/23</a></h2>
<h1 id="目录"><a class="header" href="#目录">目录</a></h1>
<h2 id="第一章简短介绍"><a class="header" href="#第一章简短介绍"><a href="zshguide01.html#l1">第一章：简短介绍</a></a></h2>
<h3 id="11-其他-shell-和其他指南"><a class="header" href="#11-其他-shell-和其他指南"><a href="zshguide01.html#l2">1.1: 其他 shell 和其他指南</a></a></h3>
<h3 id="12-zsh-的版本"><a class="header" href="#12-zsh-的版本"><a href="zshguide01.html#l3">1.2: zsh 的版本</a></a></h3>
<h3 id="13-约定"><a class="header" href="#13-约定"><a href="zshguide01.html#l4">1.3: 约定</a></a></h3>
<h3 id="14-致谢"><a class="header" href="#14-致谢"><a href="zshguide01.html#l5">1.4: 致谢</a></a></h3>
<h2 id="第二章启动文件中要放些什么"><a class="header" href="#第二章启动文件中要放些什么"><a href="zshguide02.html#l6">第二章：启动文件中要放些什么</a></a></h2>
<h3 id="21-shell-类型交互式和登录-shell"><a class="header" href="#21-shell-类型交互式和登录-shell"><a href="zshguide02.html#l7">2.1: Shell 类型：交互式和登录 shell</a></a></h3>
<p><a href="zshguide02.html#l8">2.1.1: 什么是登录 shell？简单测试</a></p>
<h3 id="22-所有的启动文件"><a class="header" href="#22-所有的启动文件"><a href="zshguide02.html#l9">2.2: 所有的启动文件</a></a></h3>
<h3 id="23-选项"><a class="header" href="#23-选项"><a href="zshguide02.html#l10">2.3: 选项</a></a></h3>
<h3 id="24-参数"><a class="header" href="#24-参数"><a href="zshguide02.html#l11">2.4: 参数</a></a></h3>
<p><a href="zshguide02.html#l12">2.4.1: 数组</a></p>
<h3 id="25-启动文件中要放些什么"><a class="header" href="#25-启动文件中要放些什么"><a href="zshguide02.html#l13">2.5: 启动文件中要放些什么</a></a></h3>
<p><a href="zshguide02.html#l14">2.5.1: 兼容性选项：<code>SH_WORD_SPLIT</code> 及其他</a></p>
<p><a href="zshguide02.html#l15">2.5.2: 为 csh 爱好者准备的选项</a></p>
<p><a href="zshguide02.html#l16">2.5.3: 历史记录机制：历史记录的类型</a></p>
<p><a href="zshguide02.html#l17">2.5.4: 设置历史记录</a></p>
<p><a href="zshguide02.html#l18">2.5.5: 历史记录选项</a></p>
<p><a href="zshguide02.html#l19">2.5.6: 提示符</a></p>
<p><a href="zshguide02.html#l20">2.5.7: 命名目录</a></p>
<p><a href="zshguide02.html#l21">2.5.8: 为高级用户准备的“加速”选项</a></p>
<p><a href="zshguide02.html#l22">2.5.9: 别名</a></p>
<p><a href="zshguide02.html#l23">2.5.10: 环境变量</a></p>
<p><a href="zshguide02.html#l24">2.5.11: 路径</a></p>
<p><a href="zshguide02.html#l25">2.5.12: 邮件</a></p>
<p><a href="zshguide02.html#l26">2.5.13: 其他类似路径的东西</a></p>
<p><a href="zshguide02.html#l27">2.5.14: 特定版本的东西</a></p>
<p><a href="zshguide02.html#l28">2.5.15: 其他所有东西</a></p>
<h2 id="第三章处理基本-shell-语法"><a class="header" href="#第三章处理基本-shell-语法"><a href="zshguide03.html#l29">第三章：处理基本 shell 语法</a></a></h2>
<h3 id="31-外部命令"><a class="header" href="#31-外部命令"><a href="zshguide03.html#l30">3.1: 外部命令</a></a></h3>
<h3 id="32-内建命令"><a class="header" href="#32-内建命令"><a href="zshguide03.html#l31">3.2: 内建命令</a></a></h3>
<p><a href="zshguide03.html#l32">3.2.1: 用于打印的内建命令</a></p>
<p><a href="zshguide03.html#l33">3.2.2: 其他仅为速度而设的内建命令</a></p>
<p><a href="zshguide03.html#l34">3.2.3: 改变 shell 状态的内建命令</a></p>
<p><a href="zshguide03.html#l35">3.2.4: cd 和它的朋友们</a></p>
<p><a href="zshguide03.html#l36">3.2.5: 命令控制和信息命令</a></p>
<p><a href="zshguide03.html#l37">3.2.6: 参数控制</a></p>
<p><a href="zshguide03.html#l38">3.2.7: 历史记录控制命令</a></p>
<p><a href="zshguide03.html#l39">3.2.8: 作业控制和进程控制</a></p>
<p><a href="zshguide03.html#l40">3.2.9: 终端、用户等</a></p>
<p><a href="zshguide03.html#l41">3.2.10: 语法零碎</a></p>
<p><a href="zshguide03.html#l42">3.2.11: 更多的前置命令修饰符：<code>exec</code>、<code>noglob</code></a></p>
<p><a href="zshguide03.html#l43">3.2.12: 测试事物</a></p>
<p><a href="zshguide03.html#l44">3.2.13: 处理函数和脚本的选项</a></p>
<p><a href="zshguide03.html#l45">3.2.14: 随机文件控制相关</a></p>
<p><a href="zshguide03.html#l46">3.2.15: 不要看这里，看别处</a></p>
<p><a href="zshguide03.html#l47">3.2.16: 以及其他</a></p>
<h3 id="33-函数"><a class="header" href="#33-函数"><a href="zshguide03.html#l48">3.3: 函数</a></a></h3>
<p><a href="zshguide03.html#l49">3.3.1: 加载函数</a></p>
<p><a href="zshguide03.html#l50">3.3.2: 函数参数</a></p>
<p><a href="zshguide03.html#l51">3.3.3: 编译函数</a></p>
<h3 id="34-别名"><a class="header" href="#34-别名"><a href="zshguide03.html#l52">3.4: 别名</a></a></h3>
<h3 id="35-命令摘要"><a class="header" href="#35-命令摘要"><a href="zshguide03.html#l53">3.5: 命令摘要</a></a></h3>
<h3 id="36-展开和引用"><a class="header" href="#36-展开和引用"><a href="zshguide03.html#l54">3.6: 展开和引用</a></a></h3>
<p><a href="zshguide03.html#l55">3.6.1: 历史展开</a></p>
<p><a href="zshguide03.html#l56">3.6.2: 别名展开</a></p>
<p><a href="zshguide03.html#l57">3.6.3: 进程、参数、命令、算术和花括号展开</a></p>
<p><a href="zshguide03.html#l58">3.6.4: 文件名展开</a></p>
<p><a href="zshguide03.html#l59">3.6.5: 文件名生成</a></p>
<h3 id="37-重定向大于号和小于号"><a class="header" href="#37-重定向大于号和小于号"><a href="zshguide03.html#l60">3.7: 重定向：大于号和小于号</a></a></h3>
<p><a href="zshguide03.html#l61">3.7.1: Clobber（覆盖）</a></p>
<p><a href="zshguide03.html#l62">3.7.2: 文件描述符</a></p>
<p><a href="zshguide03.html#l63">3.7.3: 追加、here-document、here-string、读写</a></p>
<p><a href="zshguide03.html#l64">3.7.4: 巧妙的技巧：exec 和其他文件描述符</a></p>
<p><a href="zshguide03.html#l65">3.7.5: Multios（多路输入输出）</a></p>
<h3 id="38-shell-语法循环子shell-等"><a class="header" href="#38-shell-语法循环子shell-等"><a href="zshguide03.html#l66">3.8: Shell 语法：循环、(子)shell 等</a></a></h3>
<p><a href="zshguide03.html#l67">3.8.1: 逻辑命令连接符</a></p>
<p><a href="zshguide03.html#l68">3.8.2: 结构</a></p>
<p><a href="zshguide03.html#l69">3.8.3: 子 shell 和当前 shell 结构</a></p>
<p><a href="zshguide03.html#l70">3.8.4: 子 shell 和当前 shell</a></p>
<h3 id="39-仿真和可移植性"><a class="header" href="#39-仿真和可移植性"><a href="zshguide03.html#l71">3.9: 仿真和可移植性</a></a></h3>
<p><a href="zshguide03.html#l72">3.9.1: 细节差异</a></p>
<p><a href="zshguide03.html#l73">3.9.2: 使你自己的脚本和函数可移植</a></p>
<h3 id="310-运行脚本"><a class="header" href="#310-运行脚本"><a href="zshguide03.html#l74">3.10: 运行脚本</a></a></h3>
<h2 id="第四章z-shell-行编辑器"><a class="header" href="#第四章z-shell-行编辑器"><a href="zshguide04.html#l75">第四章：Z-Shell 行编辑器</a></a></h2>
<h3 id="41-zle-介绍"><a class="header" href="#41-zle-介绍"><a href="zshguide04.html#l76">4.1: zle 介绍</a></a></h3>
<p><a href="zshguide04.html#l77">4.1.1: 简单事实</a></p>
<p><a href="zshguide04.html#l78">4.1.2: Vi 模式</a></p>
<h3 id="42-基本编辑"><a class="header" href="#42-基本编辑"><a href="zshguide04.html#l79">4.2: 基本编辑</a></a></h3>
<p><a href="zshguide04.html#l80">4.2.1: 移动</a></p>
<p><a href="zshguide04.html#l81">4.2.2: 删除</a></p>
<p><a href="zshguide04.html#l82">4.2.3: 更多删除操作</a></p>
<h3 id="43-更高级的编辑"><a class="header" href="#43-更高级的编辑"><a href="zshguide04.html#l83">4.3: 更高级的编辑</a></a></h3>
<p><a href="zshguide04.html#l84">4.3.1: 控制 zle 的选项</a></p>
<p><a href="zshguide04.html#l85">4.3.2: minibuffer 和扩展命令</a></p>
<p><a href="zshguide04.html#l86">4.3.3: 前缀（数字）参数</a></p>
<p><a href="zshguide04.html#l87">4.3.4: 单词、区域和标记</a></p>
<p><a href="zshguide04.html#l88">4.3.5: 区域和标记</a></p>
<h3 id="44-历史记录和搜索"><a class="header" href="#44-历史记录和搜索"><a href="zshguide04.html#l89">4.4: 历史记录和搜索</a></a></h3>
<p><a href="zshguide04.html#l90">4.4.1: 在历史记录中移动</a></p>
<p><a href="zshguide04.html#l91">4.4.2: 搜索历史记录</a></p>
<p><a href="zshguide04.html#l92">4.4.3: 从历史记录中提取单词</a></p>
<h3 id="45-绑定按键和处理键位映射"><a class="header" href="#45-绑定按键和处理键位映射"><a href="zshguide04.html#l93">4.5: 绑定按键和处理键位映射</a></a></h3>
<p><a href="zshguide04.html#l94">4.5.1: 简单按键绑定</a></p>
<p><a href="zshguide04.html#l95">4.5.2: 移除按键绑定</a></p>
<p><a href="zshguide04.html#l96">4.5.3: 功能键等</a></p>
<p><a href="zshguide04.html#l97">4.5.4: 绑定字符串而非命令</a></p>
<p><a href="zshguide04.html#l98">4.5.5: 键位映射</a></p>
<h3 id="46-高级编辑"><a class="header" href="#46-高级编辑"><a href="zshguide04.html#l99">4.6: 高级编辑</a></a></h3>
<p><a href="zshguide04.html#l100">4.6.1: 多行编辑</a></p>
<p><a href="zshguide04.html#l101">4.6.2: 内建命令 vared 和函数 zed</a></p>
<p><a href="zshguide04.html#l102">4.6.3: 缓冲区堆栈</a></p>
<h3 id="47-扩展-zle"><a class="header" href="#47-扩展-zle"><a href="zshguide04.html#l103">4.7: 扩展 zle</a></a></h3>
<p><a href="zshguide04.html#l104">4.7.1: 小部件（Widgets）</a></p>
<p><a href="zshguide04.html#l105">4.7.2: 执行其他小部件</a></p>
<p><a href="zshguide04.html#l106">4.7.3: 一些特殊的内建小部件及其用途</a></p>
<p><a href="zshguide04.html#l107">4.7.4: 特殊参数：普通文本</a></p>
<p><a href="zshguide04.html#l108">4.7.5: 其他特殊参数</a></p>
<p><a href="zshguide04.html#l109">4.7.6: 读取按键和使用 minibuffer</a></p>
<p><a href="zshguide04.html#l110">4.7.7: 示例</a></p>
<h2 id="第五章替换"><a class="header" href="#第五章替换"><a href="zshguide05.html#l111">第五章：替换</a></a></h2>
<h3 id="51-引用"><a class="header" href="#51-引用"><a href="zshguide05.html#l112">5.1: 引用</a></a></h3>
<p><a href="zshguide05.html#l113">5.1.1: 反斜杠</a></p>
<p><a href="zshguide05.html#l114">5.1.2: 单引号</a></p>
<p><a href="zshguide05.html#l115">5.1.3: POSIX 引号</a></p>
<p><a href="zshguide05.html#l116">5.1.4: 双引号</a></p>
<p><a href="zshguide05.html#l117">5.1.5: 反引号</a></p>
<h3 id="52-修饰符及其修饰对象"><a class="header" href="#52-修饰符及其修饰对象"><a href="zshguide05.html#l118">5.2: 修饰符及其修饰对象</a></a></h3>
<h3 id="53-进程替换"><a class="header" href="#53-进程替换"><a href="zshguide05.html#l119">5.3: 进程替换</a></a></h3>
<h3 id="54-参数替换"><a class="header" href="#54-参数替换"><a href="zshguide05.html#l120">5.4: 参数替换</a></a></h3>
<p><a href="zshguide05.html#l121">5.4.1: 使用数组</a></p>
<p><a href="zshguide05.html#l122">5.4.2: 使用关联数组</a></p>
<p><a href="zshguide05.html#l123">5.4.3: 替换的替换、首尾处理等</a></p>
<p><a href="zshguide05.html#l124">5.4.4: 选项标志：分割和连接</a></p>
<p><a href="zshguide05.html#l125">5.4.5: 选项标志：<code>GLOB_SUBST</code> 和 <code>RC_EXPAND_PARAM</code></a></p>
<p><a href="zshguide05.html#l126">5.4.6: 更多参数标志</a></p>
<p><a href="zshguide05.html#l127">5.4.7: 一些参数替换技巧</a></p>
<p><a href="zshguide05.html#l128">5.4.8: 嵌套参数替换</a></p>
<h3 id="55-再次讨论替换"><a class="header" href="#55-再次讨论替换"><a href="zshguide05.html#l129">5.5: 再次讨论替换</a></a></h3>
<h3 id="56-算术展开"><a class="header" href="#56-算术展开"><a href="zshguide05.html#l130">5.6: 算术展开</a></a></h3>
<p><a href="zshguide05.html#l131">5.6.1: 输入和输出基数</a></p>
<p><a href="zshguide05.html#l132">5.6.2: 参数类型</a></p>
<h3 id="57-花括号展开和数组"><a class="header" href="#57-花括号展开和数组"><a href="zshguide05.html#l133">5.7: 花括号展开和数组</a></a></h3>
<h3 id="58-文件名展开"><a class="header" href="#58-文件名展开"><a href="zshguide05.html#l134">5.8: 文件名展开</a></a></h3>
<h3 id="59-文件名生成和模式匹配"><a class="header" href="#59-文件名生成和模式匹配"><a href="zshguide05.html#l135">5.9: 文件名生成和模式匹配</a></a></h3>
<p><a href="zshguide05.html#l136">5.9.1: 比较模式和正则表达式</a></p>
<p><a href="zshguide05.html#l137">5.9.2: 标准特性</a></p>
<p><a href="zshguide05.html#l138">5.9.3: 通常可用的扩展</a></p>
<p><a href="zshguide05.html#l139">5.9.4: 需要 <code>EXTENDED_GLOB</code> 的扩展</a></p>
<p><a href="zshguide05.html#l140">5.9.5: 递归 globbing</a></p>
<p><a href="zshguide05.html#l141">5.9.6: Glob 限定符</a></p>
<p><a href="zshguide05.html#l142">5.9.7: Globbing 标志：改变匹配行为</a></p>
<p><a href="zshguide05.html#l143">5.9.8: 函数 <code>zmv</code></a></p>
<h2 id="第六章补全旧与新"><a class="header" href="#第六章补全旧与新"><a href="zshguide06.html#l144">第六章：补全，旧与新</a></a></h2>
<h3 id="61-补全和展开"><a class="header" href="#61-补全和展开"><a href="zshguide06.html#l145">6.1: 补全和展开</a></a></h3>
<h3 id="62-使用-shell-选项配置补全"><a class="header" href="#62-使用-shell-选项配置补全"><a href="zshguide06.html#l146">6.2: 使用 shell 选项配置补全</a></a></h3>
<p><a href="zshguide06.html#l147">6.2.1: 模糊补全</a></p>
<p><a href="zshguide06.html#l148">6.2.2: <code>ALWAYS_LAST_PROMPT</code></a></p>
<p><a href="zshguide06.html#l149">6.2.3: 菜单补全和菜单选择</a></p>
<p><a href="zshguide06.html#l150">6.2.4: 改变补全行为的其他方式</a></p>
<p><a href="zshguide06.html#l151">6.2.5: 改变补全的显示方式</a></p>
<h3 id="63-新补全入门"><a class="header" href="#63-新补全入门"><a href="zshguide06.html#l152">6.3: 新补全入门</a></a></h3>
<h3 id="64-shell-如何找到正确的补全"><a class="header" href="#64-shell-如何找到正确的补全"><a href="zshguide06.html#l153">6.4: shell 如何找到正确的补全</a></a></h3>
<p><a href="zshguide06.html#l154">6.4.1: 上下文（Contexts）</a></p>
<p><a href="zshguide06.html#l155">6.4.2: 标签（Tags）</a></p>
<h3 id="65-使用样式配置补全"><a class="header" href="#65-使用样式配置补全"><a href="zshguide06.html#l156">6.5: 使用样式配置补全</a></a></h3>
<p><a href="zshguide06.html#l157">6.5.1: 指定补全器及其选项</a></p>
<p><a href="zshguide06.html#l158">6.5.2: 改变列表格式：分组等</a></p>
<p><a href="zshguide06.html#l159">6.5.3: 影响特定补全的样式</a></p>
<h3 id="66-命令小部件"><a class="header" href="#66-命令小部件"><a href="zshguide06.html#l160">6.6: 命令小部件</a></a></h3>
<p><a href="zshguide06.html#l161">6.6.1: <code>_complete_help</code></a></p>
<p><a href="zshguide06.html#l162">6.6.2: <code>_correct_word</code>、<code>_correct_filename</code>、<code>_expand_word</code></a></p>
<p><a href="zshguide06.html#l163">6.6.3: <code>_history_complete_word</code></a></p>
<p><a href="zshguide06.html#l164">6.6.4: <code>_most_recent_file</code></a></p>
<p><a href="zshguide06.html#l165">6.6.5: <code>_next_tags</code></a></p>
<p><a href="zshguide06.html#l166">6.6.6: <code>_bash_completions</code></a></p>
<p><a href="zshguide06.html#l167">6.6.7: <code>_read_comp</code></a></p>
<p><a href="zshguide06.html#l168">6.6.8: <code>_generic</code></a></p>
<p><a href="zshguide06.html#l169">6.6.9: <code>predict-on</code>、<code>incremental-complete-word</code></a></p>
<h3 id="67-匹配控制和控制插入位置"><a class="header" href="#67-匹配控制和控制插入位置"><a href="zshguide06.html#l170">6.7: 匹配控制和控制插入位置</a></a></h3>
<p><a href="zshguide06.html#l171">6.7.1: 不区分大小写匹配</a></p>
<p><a href="zshguide06.html#l172">6.7.2: 匹配选项名称</a></p>
<p><a href="zshguide06.html#l173">6.7.3: 部分单词补全</a></p>
<p><a href="zshguide06.html#l174">6.7.4: 子字符串补全</a></p>
<p><a href="zshguide06.html#l175">6.7.5: 带大写字母的部分单词</a></p>
<p><a href="zshguide06.html#l176">6.7.6: 最后说明</a></p>
<h3 id="68-教程"><a class="header" href="#68-教程"><a href="zshguide06.html#l177">6.8: 教程</a></a></h3>
<p><a href="zshguide06.html#l178">6.8.1: 调度器</a></p>
<p><a href="zshguide06.html#l179">6.8.2: 子命令补全：<code>_arguments</code></a></p>
<p><a href="zshguide06.html#l180">6.8.3: 补全特定参数类型</a></p>
<p><a href="zshguide06.html#l181">6.8.4: 其余部分</a></p>
<h3 id="69-编写新的补全函数和小部件"><a class="header" href="#69-编写新的补全函数和小部件"><a href="zshguide06.html#l182">6.9: 编写新的补全函数和小部件</a></a></h3>
<p><a href="zshguide06.html#l183">6.9.1: 加载补全函数：<code>compdef</code></a></p>
<p><a href="zshguide06.html#l184">6.9.2: 添加一组补全：<code>compadd</code></a></p>
<p><a href="zshguide06.html#l185">6.9.3: 用于生成文件名等的函数</a></p>
<p><a href="zshguide06.html#l186">6.9.4: <code>zsh/parameter</code> 模块</a></p>
<p><a href="zshguide06.html#l187">6.9.5: 特殊补全参数和 <code>compset</code></a></p>
<p><a href="zshguide06.html#l188">6.9.6: 更高级的补全：使用标签和样式机制</a></p>
<p><a href="zshguide06.html#l189">6.9.7: 让他人为你完成工作：处理参数等</a></p>
<p><a href="zshguide06.html#l190">6.9.8: 更多补全实用函数</a></p>
<h3 id="610-最后"><a class="header" href="#610-最后"><a href="zshguide06.html#l191">6.10: 最后</a></a></h3>
<h2 id="第七章模块及其他零碎-未完成"><a class="header" href="#第七章模块及其他零碎-未完成"><a href="zshguide07.html#l192">第七章：模块及其他零碎 <em>未完成</em></a></a></h2>
<h3 id="71-模块控制zmodload"><a class="header" href="#71-模块控制zmodload"><a href="zshguide07.html#l193">7.1: 模块控制：<code>zmodload</code></a></a></h3>
<p><a href="zshguide07.html#l194">7.1.1: 定义参数的模块</a></p>
<p><a href="zshguide07.html#l195">7.1.2: 底层系统交互</a></p>
<p><a href="zshguide07.html#l196">7.1.3: ZFTP</a></p>
<h3 id="72-贡献部分"><a class="header" href="#72-贡献部分"><a href="zshguide07.html#l197">7.2: 贡献部分</a></a></h3>
<p><a href="zshguide07.html#l198">7.2.1: 提示符主题</a></p>
<h3 id="73-41-版本的新功能"><a class="header" href="#73-41-版本的新功能"><a href="zshguide07.html#l199">7.3: 4.1 版本的新功能</a></a></h3>
<h2 id="附录-1获取-zsh-和更多信息-未完成"><a class="header" href="#附录-1获取-zsh-和更多信息-未完成"><a href="zshguide08.html#l200">附录 1：获取 zsh 和更多信息 <em>未完成</em></a></a></h2>
<hr />
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide02.html">下一章</a></li>
</ul>
<hr />
<p>[]{#intro}[]{#l1}</p>
<h1 id="第一章简短介绍-1"><a class="header" href="#第一章简短介绍-1">第一章：简短介绍</a></h1>
<p>Z-Shell，简称 <code>zsh</code>，是 UNIX 系统的一个命令解释器，用 UNIX 的行话来说，就是一个 <code>shell</code>，因为它包裹着你使用的命令。但远不止于此，zsh 是一个特别强大的 shell --- 而且它是免费的，并处于定期维护中 --- 拥有许多交互式功能，让你能以最少的麻烦完成最多的工作。当然，为此你需要知道这个 shell 能做什么以及如何做，而这正是本指南的目的。</p>
<p>最基本的基础：我将假设你能够访问一个 UNIX 系统，否则本文档的其余部分对你来说没什么用。你也可以通过安装 Cygwin 在 Windows 下使用 zsh，Cygwin 为程序提供了一个类 UNIX 的环境 --- 鉴于标准 Windows 命令解释器的弱点，这样做是件好事。有一些旧版本的 zsh 被移植到了 Windows 上，可以本地运行，即无需 UNIX 环境，尽管它们在某些方面的行为略有不同，我不会进一步讨论它们。</p>
<p>我还将假设你具备一些 UNIX 的基础知识；你应该知道文件系统是如何工作的，例如 <code>/home/users/pws/.zshrc</code> 和 <code>../file</code> 的含义，以及一些基本命令，例如 <code>ls</code>，并且你应该有过不小心用 <code>rm</code> 删错文件的经历，诸如此类。在类似 <code>rm file</code> 的命令中，我通常会提到 <code>command</code>（命令，这里当然是 <code>rm</code>）和 <code>argument(s)</code>（参数，即命令后被其使用的任何东西），以及你一次性输入的完整内容称为 <code>command line</code>（命令行）。</p>
<p>你还需要 zsh 本身；如果你正在阅读本文，你很可能已经有了，但如果你没有，你或你的系统管理员应该阅读<a href="zshguide08.html#appa">附录 A</a>。现在，我们假设你正坐在一台已经运行着 zsh 的终端前。</p>
<p>现在说到 shell。登录后，你可能会看到一些提示符（屏幕上表示你可以输入命令的一系列符号），例如 <code>$</code> 或 <code>%</code>，可能前面还有一些其他文本 --- 稍后，我们将看到如何以有趣的方式更改这些文本。那个提示符来自 shell。输入 <code>print hello</code>，然后用退格键删除 <code>hello</code> 并输入 <code>goodbye</code>。现在按下 <code>Return</code> 键（或 <code>Enter</code> 键，从现在起我将简称为 <code>&lt;RET&gt;</code>，同样 <code>&lt;TAB&gt;</code> 代表 Tab 键，<code>&lt;SPC&gt;</code> 代表空格键）；除非你的系统上有严重的恶作剧问题，否则你会看到 <code>goodbye</code>，然后 shell 会返回另一个提示符。在你按下 <code>&lt;RET&gt;</code> 之前的所有时间里，你都在与 shell 及其编辑器（称为 <code>Z-Shell Line Editor</code> 或简称 <code>zle</code>）进行交互；只有在那之后，shell 才去告诉 <code>print</code> 命令打印出一条消息。所以你可以看到 shell 是很重要的。</p>
<p>然而，如果你只是输入像那样的简单命令，为什么需要任何复杂的东西呢？在这种情况下，你不需要；但现实生活没那么简单。在本指南的其余部分，我将描述在 zsh 的帮助下，你如何能够：</p>
<ul>
<li>通过使用启动文件，自定义你的工作环境，</li>
<li>编写你自己的命令来缩短任务，并将东西存储在 shell 变量（<code>parameters</code>）中，这样你就不必记住它们，</li>
<li>使用 zle 来最小化你必须输入的量 --- 在 zsh 中，你甚至可以用这种方式编辑小文件，</li>
<li>使用 zsh 非常复杂的 文件名生成（俗称 <code>globbing</code>）系统，为你想要用于特定命令（如 <code>mv</code> 或 <code>ls</code>）的文件进行挑选，</li>
<li>告诉编辑器你对特定命令使用什么样的参数，这样你只需要输入名称的一部分，它就会使用 zsh 无与伦-</li>
<li>使用最新版 zsh 提供的额外附加组件（<code>modules</code>），来做一些你通常在 shell 中根本做不到的事情。</li>
</ul>
<p>这只是一个小小的样本。由于要说的东西太多，本指南将专注于 zsh做得最好的事情，特别是它拥有而其他 shell 没有的东西。下一章通过尝试解释如何按照你想要的方式设置 shell，来介绍一些基础知识。像本指南的其余部分一样，它不打算详尽无遗，要了解全部内容，你应该查阅 shell 手册。</p>
<p>还有一些你可能应该马上知道的事情。首先，shell 总是在运行，即使你输入的命令也在运行；shell 只是等待它完成：你可能从其他 shell 中知道，通过在命令后加上一个 <code>&amp;</code>，可以将命令放入<strong>后台</strong>，这意味着 shell 不会等待它们完成。即使命令在前台，shell 也在那里，只是在这种情况下什么也不做。</p>
<p>其次，它不只是运行别人的命令，它也有自己的一些命令，称为<strong>内建命令</strong>或简称<strong>builtins</strong>，你甚至可以添加自己的命令，作为给 shell 的指令列表，称为<strong>函数</strong>；内建命令和函数总是在 shell 自身内部运行。了解这一点很重要，因为不在 shell 自身内部运行的东西不能影响它，因此不能改变参数、函数、别名以及我将要讨论的所有其他东西。</p>
<p>[]{#l2}</p>
<h2 id="11-其他-shell-和其他指南-1"><a class="header" href="#11-其他-shell-和其他指南-1">1.1: 其他 shell 和其他指南</a></h2>
<p>如果你想对 shell 的工作原理、它们的语法（即如何编写命令）以及如何编写脚本和函数有一个基本的了解，你应该阅读关于这个主题的众多书籍之一。特别是，阅读一本描述 Korn shell (ksh) 的书会让你收获最多，因为 zsh 与它非常相似 --- 如此相似，以至于我在讲解过程中指出差异是值得的，因为它们可能会让 ksh 用户感到困惑。最近版本的 zsh 可以非常接近地模拟 ksh（严格来说是 1988 年版的 ksh，尽管越来越多地加入了 1993 年版的特性），虽然并不完美，而且你看得越仔细，就越不完美。然而，重要的是要认识到，如果你只是启动任何一个旧的 zsh，并不能保证它会被设置为像 ksh 一样工作；除非你或你的系统管理员更改了一些设置，否则它肯定不会。你可能不会马上看到这一点，但它会以微妙的方式影响 shell。我稍后会更多地讨论模拟。</p>
<p>还有一些其他的 shell 值得一提。所有 UNIX shell 的鼻祖是 sh，现在被称为 Bourne shell，但最初只被称为 <code>the shell</code>。情况与 ksh 类似：zsh 可以非常接近地模拟 sh（比模拟 ksh 更接近，因为 sh 要简单得多），但通常你需要确保它被设置为这样做，然后才能确定它会模拟 sh。</p>
<p>你可能还会遇到 <code>Bourne-Again Shell</code>，即 bash。这是 GNU 项目编写的 sh 的一个免费增强版 --- 但它并不总是沿着 ksh 的路线增强，因此在许多方面它与 zsh 非常不同。在一些免费的类 UNIX 系统上，例如 Linux/GNU（人们通常所说的 Linux），命令 sh 实际上是 bash，所以在那里，当你试图确保在所谓的 <code>sh</code> 下运行的东西也能在 zsh 下运行时，你应该格外小心。一些 Linux 系统还有另一个更简单的 Bourne shell 克隆，ash；因为它更简单，所以更像原始的 Bourne shell。</p>
<p>一些更现代的操作系统谈论 <code>POSIX shell</code>。这是对 UNIX shell 进行标准化的尝试；它最像 Korn shell，尽管有点令人困惑的是，它通常只被称为 sh，因为标准规定它应该如此。通常，这只意味着你的 sh 附带了一些额外的免费功能，并且仍然能如你所愿地工作。Zsh 已经做了一些尝试来符合标准，但你必须告诉它这样做 --- 同样，仅仅启动 <code>zsh</code> 并不会有正确的设置。</p>
<p>还有另一个常见的 shell 家族，不幸的是，它们的语法不兼容。这个家族的源头是 C-Shell，csh，之所以这么叫是因为它的语法更像 C 编程语言。当当时唯一可用的其他 shell 是 sh 时，csh 因为有更好的交互功能（如作业控制）而变得普及。后来它被增强为 tcsh，它具有许多你也会在 zsh 中找到的交互功能，因此变得非常流行。尽管有这些共同的特性，zsh 的语法却非常不同，所以你不应该在 zsh 中尝试使用除了最简单的 csh/tcsh 命令之外的命令；但如果你是 tcsh 用户，你会发现你习惯的几乎所有功能在 zsh 中都能找到，而且还有更多。</p>
<p>[]{#l3}</p>
<h2 id="12-zsh-的版本-1"><a class="header" href="#12-zsh-的版本-1">1.2: zsh 的版本</a></h2>
<p>在撰写本文时，可供广泛使用的最新 zsh 版本是 4.0.6。你通常会发现两套旧的 zsh。3.0 系列，其最后一个版本是 3.0.9，是一个稳定版本，自 zsh 3 的第一个版本发布以来只有错误修复。3.1 系列是 beta 版本，有很多新功能；其中最后一个版本 3.1.9 与 4.0.1 相差不大；主要的变化是 shell 现在已被宣布为稳定版，因此与 zsh 3 一样，将有一组错误修复，标记为 4.0，以及一组包含新功能的版本，标记为 4.1。由于 4.0 取代了所有 zsh 3 版本，我将尽量简化并只讨论 4.0；但偶尔指出旧版本的不同之处会很有帮助。</p>
<p>Zsh 的一个显著特点是命令行参数的补全。该系统在 3.1.6 和 3.1.7 中发生了变化，使其更具可配置性，并且（只要你保持清醒）稍微不那么晦涩。因此，我不会详细描述旧的补全系统，它使用 <code>compctl</code> 命令；zsh FAQ 中有一个非常简短的介绍。旧系统仍然可用，但我们强烈建议新用户从新系统开始。有关新式补全的详细信息，请参见<a href="zshguide06.html#comp">第六章</a> <code>补全，旧与新</code>。</p>
<p>4.0 和 4.1 之间不会有太大差异，只是一些错误修复和一些演进性变化，外加一些额外的模块。在<a href="zshguide07.html#ragbag">第七章</a>中会有一些关于 4.1 新功能的说明，但你为 4.0 编写的任何东西在可预见的未来都不太可能过时。</p>
<p>[]{#l4}</p>
<h2 id="13-约定-1"><a class="header" href="#13-约定-1">1.3: 约定</a></h2>
<p>我所说的大部分内容都将是相当独立的（这意味着我使用的短语如 <code>如我之前所说</code> 和 <code>我稍后会讨论</code> 比真正的文体家希望的要多，而且我引用其他章节的次数也过多），但在你深入之前，我可能应该提请你注意一些要点。</p>
<p>我经常会像你在文件中编写可执行代码（<code>脚本</code> 或 <code>函数</code>，差异将在各处讨论）那样写代码块：</p>
<pre><code>  if [[ $ZSH_VERSION = 3.* ]]; then
    print This is a release of the third version of zsh.
  else
    print This is either very new or very old.
  fi
</code></pre>
<p>但有时我会同时显示你在 shell 中交互式输入的内容，以及 shell 返回给你的内容：</p>
<pre><code>  % print $ZSH_VERSION
  3.1.9
  % print $CPUTYPE
  i586
</code></pre>
<p>在这里，<code>%</code> 显示了 shell 提示符，告诉你它正在等待输入（紧随其后的空格是它的一部分）。实际上，你可能会在百分号前看到一些东西，比如机器名或你的用户名，或者更花哨的东西。为了避免混淆，我把它精简到了最低限度，并保留它作为提醒，这是你输入的那一行。</p>
<p>如果你正在阅读本指南的电子版，并想将前面带有 <code>%</code> 的行复制到终端中执行，有一个巧妙的方法，你甚至不必先编辑该行：</p>
<pre><code>  alias %=' '
</code></pre>
<p>然后，行首的 <code>%</code> 会变成空无一物；空格只是表示任何后续的别名都应该被展开。所以 <code> % print $CPUTYPE</code> 这一行会忽略 <code>%</code> 并执行该行的其余部分。（我希望这很明显，但你<em>自己的</em>提示符总是被忽略的；这只是在你从指南中复制提示符到 shell 中时才适用。）</p>
<p>Zsh 中有许多不同类型的对象，但最常见的一种是参数，我将始终在它们前面加上 <code>$</code> 符号，如 <code>$ZSH_VERSION</code>，以提醒你它们是参数。你需要记住，当你设置或操作参数本身而不是其值时，你要省略 <code>$</code>。随着我们的深入，何时需要何时不需要它应该会变得更清楚。</p>
<p>我将特别展示的另一类对象是 shell 选项 --- 关于 shell 如何工作的选择 --- 我会这样写：<code>SH_WORD_SPLIT</code>、<code>NO_NOMATCH</code>、<code>ZLE</code>。同样，这也不是全部，因为只要 shell 期望选项，你就可以用大写或小写字母书写它们，下划线的数量也可以随意；而且在代码块中，我通常会使用最简单的形式：<code>shwordsplit</code>、<code>nonomatch</code>、<code>zle</code>。如果你有哲学头脑，可以认为这是在表达谈论编程和实际编程之间的类别差异，但实际上只是我前后不一致而已。</p>
<p>你可能会觉得我用三个连字符来表示一个破折号很奇怪。这实际上是本指南印刷版中使用的一个约定，它是用 LaTeX 制作的。总有一天，我会把它变成一个宏，它会在其他版本中正确显示；但是，总有一天宇宙也会终结。</p>
<p>[]{#l5}</p>
<h2 id="14-致谢-1"><a class="header" href="#14-致谢-1">1.4: 致谢</a></h2>
<p>我感谢各位 zsh 用户的评论。特别是，我收到了来自 Bart Schaefer、Sven <code>Mr Completion</code> Wischnowsky 和 Oliver Kiddle 的详细评论和更正。通常会加上一句“任何剩余的错误都是我自己的”，但这简直是显而易见到了荒谬的地步。我的意思是，这是谁写的？算了。</p>
<p>大部分内容是在某个版本的 Linux Mandrake（Red Hat 的一个衍生版）上，使用通常的 GNU 和 XFree86 工具编写的。由于所有这些都是免费的，说声 <code>谢谢</code> 以示感谢似乎是公平的。它也比这台特定 PC 自带的操作系统好用得多。</p>
<hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide02.html">下一章</a></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide01.html">上一章</a></li>
<li><a href="zshguide03.html">下一章</a></li>
</ul>
<hr />
<p>[]{#init}[]{#l6}</p>
<h1 id="第二章启动文件中要放些什么-1"><a class="header" href="#第二章启动文件中要放些什么-1">第二章：启动文件中要放些什么</a></h1>
<p>你可能想对 shell 的行为做出各种各样的改变。所有的 shell 都有“启动”文件，其中包含在 shell 启动时立即执行的命令。像许多其他 shell 一样，zsh 允许每个用户拥有自己的启动文件。在本章中，我将讨论你可能想放在那里的一些东西。这将作为对 shell 功能的介绍；读完本章，你应该对许多稍后将更详细讨论的事情以及它们为什么有趣有一个初步的了解。有时你会发现比你想知道的更多的东西，比如 zsh 与你不会使用的其他 shell 有何不同。在这里解释这些差异可以省去我以后撒谎说 shell 是如何工作然后再纠正的麻烦：大多数人只想知道 shell 通常是如何工作的，并注意到还有其他方法可以做到这一点。</p>
<p>[]{#l7}</p>
<h2 id="21-shell-类型交互式和登录-shell-1"><a class="header" href="#21-shell-类型交互式和登录-shell-1">2.1: Shell 类型：交互式和登录 shell</a></h2>
<p>首先，你需要知道<strong>交互式</strong>和<strong>登录</strong> shell 是什么意思。基本上，shell 只是用来接收一个命令列表并运行它们；它并不真正关心这些命令是在文件中，还是在终端中输入的。在第二种情况下，当你在提示符下输入并等待每个命令运行时，shell 是<strong>交互式</strong>的；在另一种情况下，当 shell 从文件中读取命令时，它因此是<strong>非交互式</strong>的。以这种第二种方式使用的命令列表——通常通过输入类似 <code>zsh filename</code> 的东西，尽管有快捷方式——被称为<strong>脚本</strong>，就好像 shell 在读取它时像在演戏一样（而 shell 在演戏方面可以是真正的戏精）。当你从键盘启动一个脚本时，实际上有两个 zsh 在运行：你正在输入的交互式 zsh，它正在等待另一个非交互式 zsh 运行完脚本。第二个 zsh 中发生的几乎所有事情都不会影响第一个；它们是 zsh 的不同副本。</p>
<p>请记住，当我给出让你输入的示例时，我通常会像它们在脚本中出现的那样显示它们，前面没有提示符。如果你输入它们，你在屏幕上实际看到的内容前面会有更多的东西。</p>
<p>当你第一次登录到计算机时，你得到的 shell 是交互式的，但它也是一个登录 shell。如果你输入 <code>zsh</code>，它会启动一个新的交互式 shell：因为你没有给它一个包含命令的文件名，它假设你会以交互方式输入它们。现在你同时有两个交互式 shell，一个在等待另一个：这听起来不那么有用，但有时你会暂时对 shell 的设置进行一些根本性的改变，最简单的方法是启动另一个 shell，做你想做的事，然后退出回到原来的、未改变的 shell——所以这并不像听起来那么愚蠢。</p>
<p>然而，第二个 shell 不会是登录 shell。zsh 是如何知道区别的呢？嗯，在你输入密码后让你登录的程序（可预见地称为 <strong>login</strong>），实际上在 shell 的名称前加了一个 <code>-</code>，zsh 会识别它。使 shell 成为登录 shell 的另一种方法是自己用 <code>-l</code> 选项运行它；输入 <code>zsh -l</code> 将启动一个也认为自己是登录 shell 的 zsh，稍后我将解释如何在 shell 内部打开选项，你也可以对登录选项这样做。否则，你自己启动的任何 zsh 都不会是登录 shell。如果你正在使用 X-Windows，并且有一个像 xterm 这样的终端模拟器运行 shell，那可能不是一个登录 shell。然而，实际上可以通过给 xterm <code>-ls</code> 选项来让它启动一个登录 shell，所以如果你输入 <code>xterm -ls &amp;</code>，你会得到一个运行登录 shell 的窗口（<code>&amp;</code> 意味着第一个窗口中的 shell 不会等待它完成）。</p>
<p>登录 shell 和任何其他交互式 shell 的第一个主要区别是与启动文件有关的，下面会描述。另一个是当你完成时你做什么。对于登录 shell，你可以输入 <code>logout</code> 来退出 shell；对于其他 shell，你输入 <code>exit</code>。然而，<code>exit</code> 对所有 shell 都有效，无论是交互式、非交互式、登录 shell 还是其他，所以很多人只用它。事实上，唯一的区别是，如果你在其他任何地方使用 <code>logout</code>，它会告诉你 <code>not login shell</code> 并且无法退出。命令 <code>bye</code> 与 <code>exit</code> 相同，只是更短且不那么标准。所以我的建议是只用 <code>exit</code>。</p>
<p>正如有人最近向我指出的，登录 shell 不必是交互式的。你总是可以用两种方式启动一个 shell，使其成为登录 shell；使其成为交互式 shell 或非交互式 shell 的方式是独立的。事实上，一些窗口系统的启动脚本会运行一个非交互式的登录 shell，以便在执行启动窗口会话的命令之前，从适当的登录脚本中合并定义。</p>
<p>[]{#l8}</p>
<h3 id="211-什么是登录-shell简单测试"><a class="header" href="#211-什么是登录-shell简单测试">2.1.1: 什么是登录 shell？简单测试</a></h3>
<p>判断你正在看的 shell 是否是交互式通常很容易：如果有提示符，它就是交互式的。正如你可能已经了解到的，判断它是否是登录 shell 更复杂，因为你并不总是知道 shell 是如何启动的，或者选项是否被更改了。如果你想知道，你可以输入以下内容（如果你喜欢，可以一次一行，见下文），</p>
<pre><code>  if [[ -o login ]]; then
    print yes
  else
    print no
  fi
</code></pre>
<p>这将根据它是否是登录 shell 打印 <code>yes</code> 或 <code>no</code>；语法将在我们进行中解释。有更短的方法可以做到这一点，但这说明了测试事物最常见的 shell 语法，这是你在启动文件中可能经常想做的事情。你要测试的内容放在 <code>[[ ... ]]</code> 内部；在这种情况下，<code>-o</code> 告诉 shell 测试一个选项，这里是 <code>login</code>。下一行说明如果测试成功该做什么；<code>else</code> 之后的行说明如果测试失败该做什么。这个语法与 ksh 几乎相同；在本指南中，我不会给出你可以执行的测试的详尽细节，因为它们有很多，但只展示一些最有用的。一如既往，请参阅手册——在这种情况下，是 <code>zshmisc</code> 手册页中的 <code>Conditional Expressions</code>。</p>
<p>虽然你通常知道一个 shell 何时是交互式的，但实际上你也可以用完全相同的方式测试它：只需使用 <code>[[ -o interactive ]]</code>。这是你在 shell 中无法更改的一个选项；如果你关闭了从键盘读取，shell 应该从哪里读取呢？但你至少可以测试它。</p>
<p>给 shell 编程初学者的旁注：也许分号看起来有点奇怪；那是因为 <code>then</code> 实际上是一个单独的命令。分号只是代替了把它放在新的一行；两者是可互换的。事实上，我本可以写成，</p>
<pre><code>  if [[ -o login ]]; then; print yes; else; print no; fi
</code></pre>
<p>这做的完全是同一件事。我甚至可以省略 <code>then</code> 和 <code>else</code> 之后的分号，因为 shell 知道在它们各自之后必须有一个命令——尽管 <code>then</code> <em>之前</em> 的分号或换行符通常很重要，因为 shell <code>并不知道</code> 接下来必须有一个命令，并且可能会将 <code>then</code> 与 <code>if</code> 之后的命令的参数混淆：它可能看起来很奇怪，但 <code>[[</code> <em>...</em> <code>]]</code> 实际上是一个命令。所以你会在 shell 程序中看到各种划分行的方式。你可能还想知道 <code>print</code> 是前面提到的内建命令之一；换句话说，那整个程序块都是由 shell 自己执行的。如果你使用的是较新版本的 shell，你会注意到 zsh 会告诉你它在等待什么，即一个 <code>then</code> 或一个 <code>else</code> 子句——更多信息请参见下面对 <code>$PS2</code> 的解释。最后，我在 <code>print</code> 命令前放的空格只是为了让它看起来更漂亮；在命令和参数之前、之后或之间可以出现任意数量的空格，只要普通单词之间至少有一个（分号被识别为特殊的，所以你不需要在它之前加一个，尽管你加一个也无妨）。</p>
<p>给 sh 用户的第二条旁注：你可能记得 sh 中的测试使用一对单括号，<code>if [ ... ]; then ...</code>，或者等效地作为一个名为 <strong>test</strong> 的命令，<code>if test ...; then ...</code>。Korn shell 被故意做得不同，zsh 也遵循了这一点。原因是 <code>[[</code> 被特殊处理，这允许 shell 做一些额外的检查并允许更自然的语法。例如，你可能知道在 sh 中测试一个可能为空的参数是危险的：<code>[ $var = foo ]</code> 如果 <code>$var</code> 为空就会失败，因为在这种情况下，这个词被省略了，shell 永远不知道它应该在那里；而使用 <code>[[</code> <em>...</em> <code>]]</code>，这是完全安全的，因为 shell 知道在 <code>=</code> 之前有一个词，即使它是空的。此外，你可以使用 <code>&amp;&amp;</code> 和 <code>||</code> 来表示逻辑上的 <code>与</code> 和 <code>或</code>，这与通常的 UNIX/C 约定一致；在 sh 中，它们会被视为启动一个新命令，而不是测试的一部分，你必须使用不太清晰的 <code>-a</code> 和 <code>-o</code>。实际上，zsh 为了向后兼容也提供了旧形式的测试，但如果你不使用它，事情会顺利得多。</p>
<p>[]{#l9}</p>
<h2 id="22-所有的启动文件-1"><a class="header" href="#22-所有的启动文件-1">2.2: 所有的启动文件</a></h2>
<p>现在这里是启动文件列表以及它们何时运行。你会看到它们分为两类：在 <code>/etc</code> 目录中的，由系统管理员放置并为所有用户运行；以及在你主目录中的，zsh 像许多 shell 一样，允许你缩写为 <code>~</code>。后者文件可能在别处；输入 <code>print $ZDOTDIR</code>，如果你得到除空行或告知参数未设置的错误消息之外的任何内容，它会告诉你一个除 <code>~</code> 之外的目录，你的启动文件就在那里。如果 <code>$ZDOTDIR</code>（另一个参数）尚未设置，你不会无缘无故地去设置它。</p>
<p><strong><code>/etc/zshenv</code></strong>
:   总是为每个 zsh 运行。</p>
<p><strong><code>~/.zshenv</code></strong>
:   通常为每个 zsh 运行（见下文）。</p>
<p><strong><code>/etc/zprofile</code></strong>
:   为登录 shell 运行。</p>
<p><strong><code>~/.zprofile</code></strong>
:   为登录 shell 运行。</p>
<p><strong><code>/etc/zshrc</code></strong>
:   为交互式 shell 运行。</p>
<p><strong><code>~/.zshrc</code></strong>
:   为交互式 shell 运行。</p>
<p><strong><code>/etc/zlogin</code></strong>
:   为登录 shell 运行。</p>
<p><strong><code>~/.zlogin</code></strong>
:   为登录 shell 运行。</p>
<p>现在你知道什么是登录 shell 和交互式 shell，这应该很简单了。你可能想知道为什么既有 <code>~/.zprofile</code> 又有 <code>~/.zlogin</code>，因为它们都是为登录 shell 准备的：答案是显而易见的，一个在 <code>~/.zshrc</code> 之前运行，一个在之后运行。这是历史原因；Bourne 类型的 shell 运行 <code>/etc/profile</code>，csh 类型的 shell 运行 <code>~/.login</code>，而 zsh 试图用自己的启动文件来涵盖这两种情况。</p>
<p>复杂性由 <code>见下文</code> 暗示。文件 <code>/etc/zshenv</code>，如其所述，总是在任何 zsh 启动时运行。然而，如果设置了 <code>NO_RCS</code> 选项（或者等效地，<code>RCS</code> 选项未设置：我稍后会谈到选项，因为它们在启动文件中很重要），其他文件都不会运行。设置此选项最常见的方法是在命令行上使用一个标志：如果你以 <code>zsh -f</code> 启动 shell，该选项就会被设置，所以只有 <code>/etc/zshenv</code> 会运行，其他的都会被跳过。通常，脚本这样做是为了尝试获得一个没有多余装饰的基本 shell，我将在下面描述；但如果在 <code>/etc/zshenv</code> 中设置了某些东西，就没有办法避免它。这就引出了 Zsh 管理第一定律：在 <code>/etc/zshenv</code> 文件中放尽可能少的东西，因为每个启动的 zsh 都必须读取它。特别是，如果脚本假设只设置了基本选项，而 <code>/etc/zshenv</code> 已经改变了它们，它很可能无法工作。所以，至少，你可能应该在 <code>/etc/zshenv</code> 中的任何选项设置周围加上</p>
<pre><code>  if [[ ! -o norcs ]]; then
    ... &lt;如果 NO_RCS 未设置时要运行的命令，
         例如设置选项&gt; ...
  fi
</code></pre>
<p>你的用户将永远感激你。用于交互式 shell 的设置，例如提示符，除非你<em>真的</em>坚持所有用户在每个 shell 中都将它们作为默认设置，否则不应该放在 <code>/etc/zshenv</code> 中。想要绕过 <code>/etc/zshenv</code> 中选项被更改问题的脚本编写者应该在脚本顶部放上 <code>emulate zsh</code>。</p>
<p>有两个文件在结束时运行：<code>~/.zlogout</code> 和 <code>/etc/zlogout</code>，按此顺序。顾名思义，它们是 <code>zlogin</code> 文件的对应物，因此只为登录 shell 运行——尽管你可以通过设置 <code>login</code> 选项来欺骗 shell。请注意，无论你使用 <code>exit</code>、<code>bye</code> 还是 <code>logout</code> 离开 shell，都不会影响这些文件是否运行：当我说 <code>exit</code> 和 <code>logout</code> 之间唯一的区别是错误消息时，我没有说谎（这次）。如果你想在任何其他类型的 shell 结束时运行一个文件，你可以用另一种方式做到：</p>
<pre><code>  TRAPEXIT() {
    # 在这里运行命令，例如，如果你
    # 总是想运行 .zlogout：
    if [[ ! -o login ]]; then
      # 不要在登录 shell 中这样做
      # 因为它无论如何都会发生
      . ~/.zlogout
    fi
  }
</code></pre>
<p>如果你把它放在 <code>.zshrc</code> 中，它将强制 <code>.zlogout</code> 在所有交互式 shell 结束时运行。稍后会提到陷阱（trap），但这有点一次性；它实际上只是一个在 shell 结束时运行命令的技巧。然而，我不会谈论注销文件，因为没有什么标准的东西可以放在里面；有些人用 <code>clear</code> 命令清除屏幕以删除敏感信息。除此之外，你可能需要在退出时整理一些文件。</p>
<p>[]{#l10}</p>
<h2 id="23-选项-1"><a class="header" href="#23-选项-1">2.3: 选项</a></h2>
<p>是时候谈谈选项了，因为我已经提过好几次了。每个选项描述一种特定的 shell 行为；它们都是布尔值，即可以打开或关闭，没有其他状态。它们有短名称，在文档和本指南中，它们用大写字母书写，并用下划线分隔各个部分（除了在实际代码中，我将以短形式书写它们）。然而，这两者都不是必需的。实际上，<code>NO_RCS</code>、<code>norcs</code> 和 <code>__N_o_R_c_S__</code> 意味着相同的事情，并且都被 shell 接受。</p>
<p>第二件事是，前面带有 <code>no</code> 的选项只是意味着没有该选项的相反情况。我也可以将测试 <code>[[ ! -o norcs ]]</code> 写成 <code>[[ -o rcs ]]</code>；<code>!</code> 意味着 <code>非</code>，就像在 C 语言中一样。你只能有一个 <code>no</code>；<code>nonorcs</code> 是没有意义的。不幸的是，有一个选项 <code>NOMATCH</code>，它的基本名称中就包含 <code>no</code>，所以在这种情况下，相反的确实是 <code>NO_NOMATCH</code>；当然，<code>NOTIFY</code> 本身也是一个完整的名称。</p>
<p>设置和取消设置选项的常用方法是使用 <strong>setopt</strong> 和 <strong>unsetopt</strong> 命令，它们接受一串选项名称。一些选项也有标志，比如 <code>NO_RCS</code> 的 <code>-f</code>，这些命令也接受，但使用全名更清晰，额外的时间和空间可以忽略不计。命令 <code>set -o</code> 等同于 <code>setopt</code>；这来自 ksh。请注意，没有 <code>-o</code> 的 <code>set</code> 做的是别的事情——它设置位置参数，这是 zsh 向脚本和函数传递参数的方式。</p>
<p>几乎每个人都会在他们的启动文件中设置一些选项。由于你希望它们至少在每个交互式 shell 中都存在，所以选择是将它们放在 <code>~/.zshrc</code> 或 <code>~/.zshenv</code> 中。选择实际上取决于你如何使用非交互式 shell。它们可以在意想不到的地方启动。例如，如果你使用 Emacs 并在其中运行命令，例如 <strong>grep</strong>，那将启动一个非交互式 shell，并且可能需要一些选项。我的经验法则是将尽可能多的选项放入 <code>~/.zshrc</code>，如果我发现我需要它们，再将它们转移到 <code>~/.zshenv</code>。一些纯粹主义者完全反对在 <code>~/.zshenv</code> 中设置选项，因为它会影响脚本；但是，正如我已经暗示的，无论如何你都必须更加努力地确保脚本不受这类事情的影响。在下文中，我只是假设它们将放在 <code>~/.zshrc</code> 中。</p>
<p>[]{#l11}</p>
<h2 id="24-参数-1"><a class="header" href="#24-参数-1">2.4: 参数</a></h2>
<p>为了编写启动文件，你还需要了解的另一件事是参数，也称为变量。它们大多像其他编程语言中的变量。简单的参数可以这样存储（一个<strong>赋值</strong>）：</p>
<pre><code>  foo='这是一个参数。'
</code></pre>
<p>注意两件事：首先，<code>=</code> 周围没有空格。如果前面有空格，zsh 会认为 <code>foo</code> 是要执行的命令的名称；如果后面有空格，它会给参数 <code>foo</code> 赋一个空字符串。其次，注意使用引号来防止字符串内的空格产生同样的效果。单引号，如此处所示，是引号的核武器选项：直到另一个单引号之前的所有内容都被视为一个简单的字符串——换行符、等号、不可打印字符，所有这些，在这个例子中都会被赋给变量；例如，</p>
<pre><code>  foo='这是一个参数。
  这仍然是同一个参数。'
</code></pre>
<p>所以，在你了解双引号的额外效果之前，它们是最好的选择。有时你不需要它们，例如，</p>
<pre><code>  foo=oneword
</code></pre>
<p>因为 <code>oneword</code> 中没有任何东西会迷惑 shell；但你仍然可以在那里加上引号。</p>
<p>Csh 用户应该注意，你不用 <code>set</code> 来设置参数。这很重要，因为有一个 <code>set</code> 命令，但它的工作方式不同——如果你尝试 <code>set var="this wont't work"</code>，你不会得到错误，但你也不会设置参数。输入 <code>print $1</code> 看看你到底设置了什么。</p>
<p>要取回存储在参数中的内容，你在命令行某处使用名称，并在前面加上一个 <code>$</code>——这被称为<strong>展开</strong>，或者更准确地说，因为还有其他类型的展开，称为<strong>参数展开</strong>。例如，在上面的第一个赋值之后。</p>
<pre><code>  print -- '$foo is "'$foo'"'
</code></pre>
<p>得到</p>
<pre><code>  $foo is "这是一个参数。"
</code></pre>
<p>所以你可以看到我说的单引号的效果是什么意思。注意不对称性——赋值参数时没有 <code>$</code>，但在前面有一个 <code>$</code> 以将其展开到命令行中。你可能会发现有时用 <code>替换</code> 这个词代替 <code>展开</code>；我将尽量坚持使用手册中的术语。</p>
<p>在我们讨论这个的时候，还有两件事。首先，为什么我在 <code>print</code> 之后放了 <code>--</code>？那是因为 <strong>print</strong>，像许多 UNIX 命令一样，可以在它后面接受以 <code>-</code> 开头的选项。<code>--</code> 表示没有更多选项了；所以如果你想打印的东西以 <code>-</code> 开头，它仍然会打印出来。实际上，在这种情况下你可以看到它没有，所以你是安全的；但这是一个好习惯，我希望我养成了。在 zsh 中，总是有例外；例如，如果你在 <code>--</code> 之前使用 <code>-R</code> 选项来打印，它只识别 BSD 风格的选项，这意味着它不理解 <code>--</code>。的确，zsh 程序员在标准方面可能相当松懈，并且经常使用旧的、但现在非标准的单个 <code>-</code> 来表示没有更多选项。目前，即使在 <code>-R</code> 之后，这也有效。</p>
<p>下一点是，我没有在单引号和 <code>$foo</code> 之间放空格，它仍然被展开了——展开发生在参数未被引用的任何地方；它不必是独立的，只要与任何可能使其看起来像不同参数的东西分开即可。这是使 shell 脚本看起来如此野蛮的事情之一。</p>
<p>除了定义你自己的参数，还有一些是 shell 自己设置的，还有一些是当你设置它们时具有特殊效果的。不过，以上所有内容仍然适用。在本指南的其余部分，我将用前面加上 <code>$</code> 来表示参数，以提醒你它们是什么，但你应该记住，当你设置它们时，或者实际上，任何时候你引用参数的名称而不是其值时，<code>$</code> 是没有的。</p>
<p>[]{#l12}</p>
<h3 id="241-数组"><a class="header" href="#241-数组">2.4.1: 数组</a></h3>
<p>有一种特殊类型的参数叫做<strong>数组</strong>，zsh 从 ksh 和 csh 中都继承了它。这是一个有点不稳定的结合，因为这两个 shell 对它们的一些操作是不兼容的，而 zsh 两者都有，所以如果你在其中任何一个中使用过数组，你需要小心。<code>KSH_ARRAYS</code> 选项可以让你设置它们，使其行为更像 ksh，但很多 zsh 用户编写的函数和脚本都假设它没有被设置，所以这可能很危险。</p>
<p>与普通参数（称为<strong>标量</strong>）不同，数组中有多个词。在上面的例子中，我们让参数 <code>$foo</code> 得到一个带空格的字符串，但空格并不重要。如果我们这样做</p>
<pre><code>  foo=(这是一个参数。)
</code></pre>
<p>（注意没有引号），它会创建一个数组。同样，<code>=</code> 和 <code>(</code> 之间不能有空格，尽管在括号内，空格分隔单词就像在命令行上一样。如果你尝试打印它，区别并不明显——它看起来完全一样——但现在试试这个：</p>
<pre><code>  print -- ${foo[4]}
</code></pre>
<p>你会得到 <code>参数。</code>。数组分别存储单词，你可以通过在方括号中放入数组元素的编号来分别检索它们。还要注意花括号 <code>{...}</code>——zsh 并不总是要求它们，但当事情变得复杂时，它们使事情更清晰，而且把它们放进去永远不会错：当你想打印出完整的参数时，你可以说 <code>${foo}</code>，它会被视为与 <code>$foo</code> 完全相同。花括号只是将展开与周围可能迷惑 shell 的任何其他东西隔离开来。在像 <code>${foo}s</code> 这样的表达式中，它也很有用，可以防止 <code>s</code> 成为参数名的一部分；最后，当设置了 <code>KSH_ARRAYS</code> 时，花括号是强制性的，但不幸的是，在这种情况下，数组的索引从 0 开始。</p>
<p>你可以在定义数组时使用引号；和以前一样，这可以防止 shell 认为空格是在数组的不同元素之间。试试：</p>
<pre><code>  foo=('第一个元素' '第二个元素')
  print -- ${foo[2]}
</code></pre>
<p>当 shell 需要将一系列不同的东西放在一起时，数组很有用，所以我们会遇到一些你可能想放在启动文件中的数组。ksh 的用户会注意到 zsh 中的情况有点不同，但现在我只假设你正在使用正常的 zsh 方式做事。</p>
<p>[]{#l13}</p>
<h2 id="25-启动文件中要放些什么-1"><a class="header" href="#25-启动文件中要放些什么-1">2.5: 启动文件中要放些什么</a></h2>
<p>据上次统计，有超过 130 个选项和几十个对 shell 来说是特殊的参数，其中许多都涉及我直到很久以后才会谈论的事情。但作为让你开始的指南，以及对未来内容的预示，这里有一些你可能想在 <code>~/.zshrc</code> 中考虑设置的选项和参数。</p>
<p>[]{#l14}</p>
<h3 id="251-兼容性选项sh_word_split-及其他"><a class="header" href="#251-兼容性选项sh_word_split-及其他">2.5.1: 兼容性选项：<code>SH_WORD_SPLIT</code> 及其他</a></h3>
<p>我已经提到 zsh 的工作方式与它最接近的标准亲戚 ksh 不同，并且其中一些差异可能会让新用户感到困惑，例如数组的使用。像 <code>KSH_ARRAYS</code> 这样的选项的存在是为了让你能够让事情以 ksh 的方式工作。这些选项大多相当挑剔，但有一个让很多人都中招了。上面，我说过在</p>
<pre><code>  foo='这是一个参数。'
</code></pre>
<p>之后，<code>$foo</code> 会被视为一个词。然而，在包括 sh、ksh 和 bash 在内的传统 Bourne-like shell 中，shell 会在它找到的任何空格处分割 <code>$foo</code>。所以如果你运行一个命令</p>
<pre><code>  command $foo
</code></pre>
<p>那么在 zsh 中，命令得到一个单一的参数 <code>这是一个参数。</code>，但在其他 shell 中，它得到第一个参数 <code>这</code>，第二个参数 <code>是</code>，依此类推。如果你喜欢这样，或者已经习惯了以至于改变会感到困惑，你应该在你的 <code>~/.zshrc</code> 中设置 <code>SH_WORD_SPLIT</code> 选项。大多数有经验的 zsh 用户在他们想要分词时使用数组，因为正如我解释的，你可以控制什么被分割，什么不被分割；这就是为什么 <code>SH_WORD_SPLIT</code> 默认不被设置的原因。其他 shell 的用户只是习惯于把东西放在双引号里，</p>
<pre><code>  command "$foo"
</code></pre>
<p>与单引号不同，双引号允许 <code>$</code> 保持特殊，并且有一个副作用，即引号内的任何东西都将保持为一个单词（尽管也有一个例外：参数 <code>$@</code>）。</p>
<p>还有很多其他选项做类似的事情，以让标准 shell 的用户感到满意。其中许多只是关闭功能，因为其他 shell 没有它们，因此可能会发生意想不到的事情，或者只是调整一个稍微不同或通常不重要的功能。目前这样的选项包括 <code>NO_BANG_HIST</code>、<code>BSD_ECHO</code>（仅限 sh）、<code>IGNORE_BRACES</code>、<code>INTERACTIVE_COMMENTS</code>、<code>KSH_OPTION_PRINT</code>、<code>NO_MULTIOS</code>、<code>POSIX_BUILTINS</code>、<code>PROMPT_BANG</code>、<code>SINGLE_LINE_ZLE</code>（我按照它们作为 <code>setopt</code> 的参数出现的方式写的，以使选项符合其他 shell 的期望，所以有些前面有 <code>NO_</code>）。大多数人可能不会改变这些，除非他们注意到某些东西没有按他们期望的方式工作。</p>
<p>其他一些有更显著的效果。这里有一些如果你从另一个 Bourne-like shell 转换过来最可能让你挠头的选项。</p>
<p><strong><code>BARE_GLOB_QUAL</code>, <code>GLOB_SUBST</code>, <code>SH_FILE_EXPANSION</code>, <code>SH_GLOB</code>, <code>KSH_GLOB</code></strong>\</p>
<p>这些都与模式匹配的工作方式有关。你可能已经知道模式 <code>*.c</code> 将被扩展为当前目录中所有以 <code>.c</code> 结尾的文件。像这样的简单用法在所有 shell 中都是相同的，文件名扩展的方式通常因历史原因被称为 <code>globbing</code>（显然它代表 <code>global replacement</code>），因此这些选项中的一些以此命名。</p>
<p>然而，zsh 和 ksh 在更复杂的模式上有所不同。例如，要匹配文件 <code>foo.c</code> 或文件 <code>bar.c</code>，在 ksh 中你会说 <code>@(foo|bar).c</code>。通常的 zsh 做法是 <code>(foo|bar).c</code>。要打开 ksh 的做法，设置 <code>KSH_GLOB</code> 选项；要关闭 zsh 的做法，设置 <code>SH_GLOB</code> 和 <code>NO_BARE_GLOB_QUAL</code> 选项。最后一个关闭了<strong>限定符</strong>，这是一种非常强大的按类型（例如，目录或可执行文件）而不是按名称选择文件的方式，我将在<a href="zshguide05.html#subst">第五章</a>中讨论。</p>
<p>另外两个需要多一点解释。试试这个：</p>
<pre><code>  foo='*'
  print $foo
</code></pre>
<p>在 zsh 中，你通常会得到一个 <code>*</code> 被打印出来，而在 ksh 中，<code>*</code> 会被扩展为目录中的所有文件，就像你输入了 <code>print *</code> 一样。这有点像 <code>SH_WORD_SPLIT</code>，因为 ksh 假装 <code>$foo</code> 的值出现在命令行上，就像你输入它一样，而 zsh 使用你赋给 <code>foo</code> 的值，而不允许它再被改变。要让这个词在 zsh 中也被扩展，你可以设置 <code>GLOB_SUBST</code> 选项。与 <code>SH_WORD_SPLIT</code> 一样，如果你不希望值被改变，绕过 ksh 行为的方法是使用双引号：<code>"$foo"</code>。</p>
<p>你不太可能需要担心 <code>SH_FILE_EXPANSION</code>。它决定了 shell 何时将像 <code>~/.zshrc</code> 这样的东西扩展为完整路径，例如 <code>/home/user2/pws/.zshrc</code>。在 zsh 的情况下，这通常在很晚的时候完成，在大多数其他形式的扩展（如参数扩展）之后。这意味着如果你设置了 <code>GLOB_SUBST</code> 并执行</p>
<pre><code>  foo='~/.zshrc'
  print $foo
</code></pre>
<p>你通常会看到以 <code>/</code> 开头的完整路径。然而，如果你<em>也</em>设置了 <code>SH_FILE_EXPANSION</code>，<code>~</code> 会在更早的时候被测试，在 <code>$foo</code> 被替换之前，那时还没有一个，所以 <code>~/.zshrc</code> 会被打印出来。这（两个选项都设置）是 ksh 的工作方式。这也意味着当我说 ksh 对待 <code>$foo</code> 完全就像它的值被输入一样时，我撒了谎，因为如果你输入 <code>print ~/.zshrc</code>，<code>~</code> 确实会被扩展。所以你看撒谎是多么方便。</p>
<p><strong><code>NOMATCH</code>, <code>BAD_PATTERN</code></strong>\</p>
<p>这些也与产生文件名的模式有关，但在这种情况下，它们决定了当模式因某种原因不匹配文件时会发生什么。有两个可能的原因：要么没有文件碰巧匹配，要么你没有使用一个正确的模式。在这两种情况下，zsh 与 ksh 不同，会打印一条错误消息。例如，</p>
<pre><code>  % print nosuchfile*
  zsh: no matches found: nosuchfile*
  % print [-
  zsh: bad pattern: [-
</code></pre>
<p>（记住 <code>%</code> 行是你输入的内容，前面有一个来自 shell 的提示符。）你可以看到有两个不同的错误消息：你可以通过设置 <code>NO_NOMATCH</code> 来停止第一个，通过设置 <code>NO_BAD_PATTERN</code> 来停止第二个。在这两种情况下，这都会让 shell 在没有匹配文件时打印出你最初输入的内容，而不进行任何扩展。</p>
<p><strong><code>BG_NICE</code>, <code>NOTIFY</code></strong>\</p>
<p>所有 UNIX shell 都允许你通过在行尾放一个 <code>&amp;</code> 来启动一个<em>后台</em>作业；然后 shell 不会等待作业完成，所以你可以输入其他东西。在 zsh 中，这样的作业通常以较低的优先级运行（在 UNIX 术语中是 <code>较高的 nice 值</code>），这样它们就不会像前台作业（所有其他的，没有 <code>&amp;</code> 的）那样占用那么多的处理器时间。这样做是为了像编辑或使用 shell 这样的作业不会变慢，这可能会非常烦人。你可以通过设置 <code>NO_BG_NICE</code> 来关闭这个功能。</p>
<p>当一个后台作业完成时，zsh 通常会立即通过打印一条消息来通知你，这会中断你正在做的任何事情。你可以通过设置 <code>NO_NOTIFY</code> 来阻止这种情况。实际上，这也是大多数版本的 ksh 中的一个选项，但在 zsh 中它稍微不那么烦人，因为如果它发生在你正在向 shell 输入其他东西时，shell 会重新打印你所在的那一行，直到你输入的位置。例如：</p>
<pre><code>  % sleep 3 &amp;
  [1] 40366
  % print The quick brown
  [1]  + 40366 done       sleep 3
  % print The quick brown
</code></pre>
<p><code>sleep</code> 命令只是在你告诉它的秒数内什么也不做，但在这里它是在后台做的（zsh 打印了一条消息告诉你）。在你输入了三秒钟后，作业退出了，并且在设置了 <code>NOTIFY</code> 的情况下，它打印了另一条消息：<code>done</code> 是关键，因为它告诉你作业已经完成。但 zsh 足够聪明，知道显示被弄乱了，所以它重新打印了你正在编辑的行，你可以继续。然而，如果你已经在前台运行另一个程序，那个程序不会知道 zsh 打印了消息，所以显示仍然会被弄乱。</p>
<p><strong><code>HUP</code></strong>\</p>
<p>信号是说服一个作业做它不想做的事情的方式，比如死亡；当你输入 <code>^C</code> 时，它会向作业发送一个信号（在这种情况下称为 <code>SIGINT</code>）。在 zsh 中，如果你在 shell 退出时有一个后台作业在运行，shell 会假设你想杀死那个作业；在这种情况下，它会被发送一个特定的信号，称为 <code>SIGHUP</code>，代表 <code>hangup</code>（挂断，如电话，而不是伍迪·艾伦那种），是 UNIX 中 <code>该回家了</code> 的等价物。如果你经常启动即使在 shell 退出后也应该继续运行的作业，那么你可以设置 <code>NO_HUP</code> 选项，后台作业将被保留。</p>
<p><strong><code>KSH_ARRAYS</code></strong>\</p>
<p>我已经提到过这个，但这里是细节。假设你定义了一个数组 <code>arr</code>，例如用</p>
<pre><code>  arr=(foo bar)
</code></pre>
<p>尽管 ksh 中的语法，zsh 也允许，是</p>
<pre><code>  set -A arr foo bar
</code></pre>
<p>在 zsh 中，<code>$arr</code> 会给出整个数组；在 ksh 中，它只产生第一个元素。在 zsh 中，<code>${arr[1]}</code> 指的是数组的第一个元素，即 <code>foo</code>，而在 ksh 中，第一个元素被称为 <code>${arr[0]}</code>，所以 <code>${arr[1]}</code> 会给你 <code>bar</code>。最后，在 zsh 中，你可以用 <code>$arr[1]</code> 来引用一个元素，而 ksh 坚持使用花括号。通过设置 <code>KSH_ARRAYS</code>，zsh 将切换到 ksh 的方式。这是你在编写函数和脚本时需要特别小心的选项之一。</p>
<p><strong><code>FUNCTION_ARG_ZERO</code></strong>\</p>
<p>Shell 函数是指定一组由 shell 运行的命令的有用方法。这里有一个简单的例子：</p>
<pre><code>  % fn() { print My name is $0; }
  % fn
  My name is fn
</code></pre>
<p>注意这个特殊的语法：<code>()</code> 出现在函数名之后，表示你正在定义一个函数，然后一组命令出现在 <code>{ ... }</code> 之间。当你输入函数名时，这些命令就会被执行。如果你了解 C 编程语言，这个语法会很熟悉，但请注意 <code>()</code> 有点误导：你可能会认为你会把函数的参数放在那里，但你不能，它必须总是简单地显示为 <code>()</code>。如果你不了解 C，也没关系；C 的任何细节都不真正适用，这只是一个表面的相似之处。</p>
<p>在这种情况下，zsh 打印了特殊参数 <code>$0</code>（<code>参数零</code>），如你所见，它变成了函数名。现在，函数外的 <code>$0</code> 意味着 shell 的名称，或者对于非交互式 shell 来说是脚本的名称，所以如果你输入 <code>print $0</code>，它可能会说 <code>zsh</code>。在大多数版本的 ksh 中，这是 <code>$0</code> 的唯一用途；它在函数中不会改变，<code>fn</code> 会打印 <code>ksh</code>。要获得这种行为，你可以设置 <code>NO_FUNCTION_ARG_ZERO</code>。可能没有理由你想这样做，但 zsh 函数经常测试自己的名称，所以这是它们可能无法工作的一个原因。</p>
<p>在定义函数时还有另一个区别，与 <code>FUNCTION_ARG_ZERO</code> 无关：在 zsh 中，你可以在 <code>fn</code> 定义结束前省略最后的 <code>;</code>，因为它知道 <code>}</code> 必须结束最后一个命令以及函数；但 ksh 在这里不那么宽容。很多语法通可能会告诉你为什么这是件好事，但幸运的是我不能。</p>
<p><strong><code>KSH_AUTOLOAD</code></strong>\</p>
<p>在 ksh 和 zsh 中都内置了一种加载函数的简单方法。与其把它们都放在一个大的启动文件中，你可以在那个文件中放一行，</p>
<pre><code>  autoload fn
</code></pre>
<p>然后函数 <code>fn</code> 只有在你通过输入它的名字作为命令来运行时才会被加载。shell 需要知道函数存储在哪里。这是通过一个名为 <code>$fpath</code> 的特殊参数来完成的，它是一个目录列表的数组；它会搜索所有目录中一个名为 <code>fn</code> 的文件，并将其用作函数定义。如果你想试试这个，你可以输入 <code>autoload fn; fpath=(. $fpath)</code> 并在当前目录中写一个名为 <code>fn</code> 的文件。</p>
<p>不幸的是，ksh 和 zsh 在那个文件中应该包含什么内容上有点分歧。通常的 zsh 做法是只把函数的主体放在那里。所以如果文件 <code>fn</code> 是可自动加载的并且包含，</p>
<pre><code>  # 这是一个简单的函数
  print My name is $0
</code></pre>
<p>那么输入 <code>fn</code> 将与上面的函数 <code>fn</code> 有完全相同的效果，打印 <code>My name is fn</code>。Zsh 用户倾向于喜欢这样，因为函数的写法与脚本相同；如果你输入 <code>zsh fn</code>，用一个新的 zsh 副本将文件作为脚本调用，它也会以同样的方式工作。第一行是注释；它被忽略，在 zsh 中甚至在函数运行时也不会被自动加载，所以添加解释性内容不仅更清晰，而且也不会占用更多内存。当然，它会占用更多的磁盘空间，但如今即使是家用 PC 也配备了那种允许你在易读性上稍作放纵的磁盘大小。</p>
<p>然而，ksh 的做法不同，这里文件 <code>fn</code> 需要包含</p>
<pre><code>  fn() {
    # 这是一个简单的函数
    print My name is $0
  }
</code></pre>
<p>换句话说，正是你定义函数时会输入的内容。这种形式的优点是，你可以在文件中放入其他东西，这些东西会立即运行然后被忘记，比如定义 <code>fn</code> 可能需要使用但不需要每次运行 <code>fn</code> 时都重新定义的东西。强制 zsh 在这里以 ksh 方式工作的选项叫做 <code>KSH_AUTOLOAD</code>。（如果你想尝试第二个例子，你需要输入 <code>unfunction fn; autoload fn</code> 来从内存中移除函数并再次标记它以便自动加载。）</p>
<p>实际上，zsh 更聪明一点。如果 <code>KSH_AUTOLOAD</code> 选项没有设置，但文件只包含一个 ksh 形式的函数定义，而没有其他内容（就像上面最后一个例子一样），那么 zsh 会假设它需要立即运行刚刚加载的函数。另一种可能性是，你想定义一个除了定义一个同名函数之外什么都不做的函数，这被认为是不太可能的——如果你真的想这样做，你需要通过在同一个文件中放入一个无操作命令来欺骗 zsh，比如在最后一行放一个 <code>:</code>。</p>
<p>最后一个复杂情况——抱歉，但这个确实会发生——是，有时在 zsh 中你不仅想定义要调用的函数，还想定义一些帮助它的函数。那么你需要这样做：</p>
<pre><code>  fn() {
    # 这是以文件名命名的函数
  }
  helper() {
    # 天知道这是干嘛的
  }
  fn "$@"
  # 这实际上是第一次调用函数，
  # 带有任何传递的参数（关于 "$@"，请参见
  # 下一章 `函数` 部分的 `函数参数` 小节）。
</code></pre>
<p>在设置了 <code>KSH_AUTOLOAD</code> 的情况下，最后那行非注释行是不必要的。然而，zsh 附带的函数假设 <code>KSH_AUTOLOAD</code> 没有设置，所以除非你需要，否则不应该打开它。你可以像往常一样把 <code>fn</code> 变成整个主体，并在其中定义 <code>helper</code>；问题是每次执行 <code>fn</code> 时 <code>helper</code> 都会被重新定义，这是低效的。避免这个问题的一个更好的方法是将 helper 定义为一个完全独立的、本身也是自动加载的函数：在 zsh 和 ksh 中，一个函数是在另一个函数内部还是外部定义都没有区别，不像（比如说）Pascal 或 Scheme。</p>
<p><strong><code>LOCAL_OPTIONS</code>, <code>LOCAL_TRAPS</code></strong>\</p>
<p>这两个选项也与函数有关，在这里 ksh 的做法通常更可取，所以很多人在他们的很多函数中至少设置了 <code>LOCAL_OPTIONS</code>。zsh 的最初版本没有这些，这就是为什么你需要手动打开它们。</p>
<p>如果在函数中设置了 <code>LOCAL_OPTIONS</code>（或者在函数之前已经设置，并且在函数内部没有取消设置），那么在函数内部更改的任何选项在函数结束时都会恢复原样。所以</p>
<pre><code>  fn() {
    setopt localoptions kshglob
    ...
  }
</code></pre>
<p>允许你使用一个带有 ksh globbing 语法的函数，但会确保 <code>KSH_GLOB</code> 选项在函数退出时恢复到之前的状态。即使函数被 <code>^C</code> 中断，这也有效。请注意，<code>LOCAL_OPTIONS</code> 本身也会恢复到原来的状态。</p>
<p><code>LOCAL_TRAPS</code> 选项，首次出现在 3.1.6 版本中，原因类似，但指的是（猜猜看）<strong>陷阱</strong>，这是一种阻止发送到 shell 的信号的方法，例如通过输入 <code>^C</code> 来取消某事（<code>SIGINT</code>，<code>signal interrupt</code> 的缩写），或 <code>^Z</code> 来暂时挂起它（<code>SIGTSTP</code>，<code>signal terminal stop</code>），或我们已经见过的 <code>SIGHUP</code> 等等。要在 shell 收到 <code>^C</code> 时做一些你自己的事情，你可以这样做</p>
<pre><code>  trap 'print I caught a SIGINT' INT
</code></pre>
<p>当 <code>^C</code> 到达时，引号中的命令集将被运行（你甚至可以不运行任何东西就尝试它）。如果字符串是空的（只是 <code>''</code> 里面什么都没有），信号将被忽略；输入 <code>^C</code> 没有效果。要把它恢复正常，命令是 <code>trap - INT</code>。</p>
<p>陷阱在函数中最有用，在那里你可能暂时（比如说）不希望在按下 <code>^C</code> 时停止，或者你可能想在从函数返回之前清理一些东西。所以现在你可以猜到 <code>LOCAL_TRAPS</code> 是做什么的了；用</p>
<pre><code>  fn() {
    setopt localoptions localtraps
    trap '' INT
    ...
  }
</code></pre>
<p>shell 将忽略 <code>^C</code> 直到函数结束，但然后会恢复之前的陷阱，或者如果之前没有就完全移除它。陷阱在<a href="zshguide03.html#syntax">第三章</a>中有更详细的描述。</p>
<p>有一个非常方便的简写来使选项和陷阱局部化，以及将其他选项设置为它们的标准值：在函数开头放上 <code>emulate -L zsh</code>。这将选项值设置回 zsh 启动时的值，但同时设置了 <code>LOCAL_OPTIONS</code> 和 <code>LOCAL_TRAPS</code>，所以你现在确切地知道在函数的其余部分事情将如何工作，无论外部世界设置了什么选项。实际上，这只改变影响正常编程的选项；你可以用 <code>emulate -RL zsh</code> 将每个有意义设置的选项都设置为其标准值（例如，此时更改像 <code>login</code> 这样的选项是没有意义的）。此外，你可以通过执行 <code>emulate -L ksh</code>，带或不带 <code>-R</code>，让 shell 尽可能地像 ksh 一样行事。</p>
<p><code>emulate</code> 的 <code>-L</code> 选项实际上只出现在 3.0.6 和 3.1.6 版本中。在此之前你需要</p>
<pre><code>  emulate zsh
  setopt localoptions
</code></pre>
<p>因为 <code>localtraps</code> 不存在，而且在 3.0.6 中也确实不存在。</p>
<p><strong><code>PROMPT_PERCENT</code>, <code>PROMPT_SUBST</code></strong>\</p>
<p>如前所述，设置提示符将在稍后讨论，但目前有两种方法可以将信息放入提示符，例如决定新命令行开头的常规提示符的参数 <code>$PS1</code>。一种是使用<em>百分比转义</em>，即一个 <code>%</code> 后跟另一个字符，两者之间可能有一个数字。例如，默认的 zsh 提示符是 <code>%m%# </code>。第一个百分比转义变成主机名，第二个通常变成一个 <code>%</code>，但对于超级用户则是 <code>#</code>。然而，ksh 没有这些，所以你可以通过设置 <code>NO_PROMPT_PERCENT</code> 来关闭它们。</p>
<p>另一方面，通常的 ksh 做法是在提示符中放入参数以进行替换。要让 zsh 这样做，你必须设置 <code>PROMPT_SUBST</code>。然后赋值</p>
<pre><code>  PS1='${PWD}% '
</code></pre>
<p>是另一种将当前目录的名称（<code>$PWD</code> 大概是以 <code>pwd</code> 命令 <code>print working directory</code> 命名的）放入提示符的方法。注意单引号，这样这会在提示符显示时发生，而不是在赋值时发生。如果它们不存在，或者是双引号，那么 <code>$PWD</code> 会在赋值时扩展为目录，可能是你的主目录，并且不会改变以反映你实际所在的目录。当然，你也需要引号来表示空格，否则在执行赋值时它就会被吞掉。</p>
<p>由于参数中可能包含的信息比固定数量的预定义百分比转义要多得多，你可能无论如何都想设置 <code>PROMPT_SUBST</code>。此外，你可以将命令的输出放入提示符，因为对它们进行了其他形式的扩展，而不仅仅是参数的扩展；实际上，带有 <code>PROMPT_SUBST</code> 的提示符每次显示时都几乎像双引号内的字符串一样被扩展。</p>
<p><strong><code>RM_STAR_SILENT</code></strong>\</p>
<p>每个人在某个时候都会删除比他们想删除的更多的文件（而<em>那</em>是一个严重的轻描淡写）；我最喜欢的是：</p>
<pre><code>  rm *&gt;o
</code></pre>
<p>那个 <code>&gt;</code> 应该是一个 <code>.</code>，但我仍然按着 shift 键。这会删除所有文件，将输出（没有任何输出）回显到一个名为 <code>o</code> 的文件中。令人高兴的是，空文件 <code>o</code> 没有被删除。（不要在家里尝试这个。）</p>
<p>Zsh 内置了一个保护机制，以防止你不小心删除目录中的所有文件。如果 zsh 发现命令是 <code>rm</code>，并且命令行上有一个 <code>*</code>（可能还有其他东西），那么它会问你是否真的想删除所有这些文件。你可以通过设置 <code>RM_STAR_SILENT</code> 来关闭这个功能。过度依赖这个选项是个坏主意；它只是最后一道防线。</p>
<p><strong><code>SH_OPTION_LETTERS</code></strong>\</p>
<p>许多选项也有单字母来代表它们；你可以通过这种方式设置一个选项，例如，<code>set -f</code>，它设置了 <code>NO_RCS</code>。然而，即使 sh、ksh 和 zsh 共享选项，并非所有选项都有相同的字母。这个选项允许单字母选项更像 sh 和 ksh 中的那些。如果你想知道，可以在手册中查找它们，但我已经建议你无论如何都使用选项的全名。</p>
<p><strong><code>SH_WORD_SPLIT</code></strong>\</p>
<p>我已经谈过这个了，见上文，但在这里提到是为了让你不要忘记它，因为它是一个重要的区别。</p>
<p><strong>以 ksh 的身份启动 zsh</strong>\</p>
<p>最后关于兼容性的话题，你可能想知道，除了 <code>emulate</code> 之外，还有另一种方法可以强制 zsh 尽可能地像 sh 或 ksh 一样行事。这就是通过以 ksh 的名称实际调用 zsh。你不需要重命名 zsh，你可以从 zsh 这个名字创建一个到 ksh 这个名字的链接，这就足以让它信服了。</p>
<p>当你在 zsh 内部这样做时，有一个更简单的方法。参数 <code>$ARGV0</code> 是特殊的；它将作为由 shell 运行的命令的第一个参数传递的值。通常这是命令的名称，但它不必是，因为命令只有在它已经被运行之后才发现它是什么。你可以用它来欺骗一个程序，让它认为自己的名字不同。所以</p>
<pre><code>  ARGV0=ksh zsh
</code></pre>
<p>将启动一个试图使自己像 ksh 的 zsh 副本。请注意，除非你已经在 zsh 中，否则这不起作用，因为 <code>$ARGV0</code> 不会是特殊的。</p>
<p>我没有提到在命令名前面放一个参数赋值，但这只是在命令期间赋值该参数（在这种情况下严格来说是一个环境变量）；在该命令（类 ksh 的 zsh）结束后，<code>$ARGV0</code> 的值将不会被设置，你可以用 <code>print</code> 轻松测试。既然我在这里，我应该提一下它的其他一些特性。首先，该参数会自动导出到环境中，这意味着它可用于 zsh 启动的其他程序（包括，在这种情况下，新的 zsh）——请参阅下面关于环境变量的部分。其次，这不会像你可能期望的那样工作：</p>
<pre><code>  FOO=bar print $FOO
</code></pre>
<p>因为扩展的顺序：命令行及其参数在执行前被扩展，给出 <code>$FOO</code> 之前的任何值，可能没有，然后 FOO=bar 被放入环境，然后命令被执行，但不使用 <code>$FOO</code> 的新值。</p>
<p>[]{#l15}</p>
<h3 id="252-csh-爱好者的选项"><a class="header" href="#252-csh-爱好者的选项">2.5.2: csh 爱好者的选项</a></h3>
<p>除了旧的 ksh 用户，还有一些选项可以让旧的 csh 和 tcsh 用户感到更自在。正如你已经注意到的，语法非常不同，所以你永远不会完全感到自在，最好还是记住这个事实。但这里有一个简短的列表。最后一个，<code>CSH_NULL_GLOB</code>，实际上非常有用。</p>
<p><strong><code>CSH_JUNKIE_HISTORY</code></strong>\</p>
<p>Zsh 有旧的 csh 机制，可以使用 <code>!</code> 来引用前一个命令行上的单词；现在编辑器更强大了，它用得少了，但对于从前一行中提取短片段来说，它仍然是一个方便的简写。这个机制有时被称为<strong>bang-history</strong>，因为忙碌的人有时喜欢把 <code>!</code> 说成 <code>bang</code>。这个选项影响单个 <code>!</code> 的工作方式。例如，</p>
<pre><code>  % print foo bar
  % print open closed
  % print !-2:1 !:2
</code></pre>
<p>在最后一行，<code>!-2</code> 意味着两个条目之前，即 <code>print foo bar</code> 这一行。<code>:1</code> 选择了命令后的第一个单词，即 <code>foo</code>。在第二个表达式中，<code>!</code> 后面没有给出数字。通常 zsh 将其解释为应该使用刚刚选择的同一项，在这种情况下是 -2。设置了 <code>CSH_JUNKIE_HISTORY</code> 后，它会引用最后一个命令。请注意，如果你没有给出那个 -2，它无论如何都会引用最后一个命令，尽管引用最后一个命令的显式方式是 <code>!!</code>——如果没有 <code>:</code> 部分跟随，你必须使用它。总而言之，zsh 通常会给你 <code>print foo bar</code>；使用 <code>CSH_JUNKIE_HISTORY</code> 你会得到 <code>print foo closed</code>。</p>
<p>还有另一个控制这个的选项，<code>BANG_HIST</code>。如果你取消设置它，这个机制将完全不起作用。还有一个参数，<code>$histchars</code>。第一个字符是主要的历史扩展字符，通常当然是 <code>!</code>；第二个用于快速替换（通常是 <code>^</code>——下面描述了它的用法）；第三个是引入注释的字符，通常是 <code>#</code>。绝对不建议更改第三个字符。几乎没有真正的理由去改变任何一个。</p>
<p><strong><code>CSH_JUNKIE_LOOPS</code></strong>\</p>
<p>正常的 zsh 循环看起来像这样，</p>
<pre><code>  while true; do
    print Never-ending story
  done
</code></pre>
<p>它只是不断地打印消息（如果你喜欢，可以在提示符下一行一行地输入，然后按 <code>^C</code> 停止它）。设置了 <code>CSH_JUNKIE_LOOPS</code> 后，你可以这样做</p>
<pre><code>  while true
    print Never-ending story
  end
</code></pre>
<p>当然，这会使你的 zsh 代码与大多数其他人的不同，所以对大多数用户来说，最好学习正确的语法。</p>
<p><strong><code>CSH_NULL_GLOB</code></strong>\</p>
<p>这是像 <code>NO_NOMATCH</code> 这样的一系列选项中的另一个，已经提到过。在这种情况下，如果你有一个由一组模式组成的命令行，其中至少有一个必须匹配至少一个文件，否则会产生错误；任何不匹配的都会从命令行中删除。默认情况是所有模式都必须匹配。这组选项中还有最后一个成员，<code>NULL_GLOB</code>：所有不匹配的模式都从命令行中删除，不会产生错误。总结一下，假设你输入命令 <code>print file1* file2*</code>，并且目录中只有文件 <code>file1.c</code>。</p>
<ol>
<li>默认情况下，必须有文件匹配两个模式，所以会报告一个错误。</li>
<li>设置了 <code>NO_NOMATCH</code> 后，任何不匹配的模式都会被保留，所以会打印 <code>file1.c file2*</code>。</li>
<li>设置了 <code>CSH_NULL_GLOB</code> 后，<code>file1*</code> 匹配了，所以 <code>file2*</code> 被静默删除；报告 <code>file1.c</code>。如果那个文件不存在，就会报告一个错误。</li>
<li>设置了 <code>NULL_GLOB</code> 后，任何不匹配的模式都会被删除，所以同样会打印 <code>file1.c</code>，但在这种情况下，如果那个文件不存在，会打印一个空行，没有错误。</li>
</ol>
<p><code>CSH_NULL_GLOB</code> 是一个很好的设置，因为它可以通过让你保持在正轨上，而不会有太多不必要的错误消息，所以这次它不仅仅是为 csh 爱好者准备的。</p>
<p><strong><code>CSH_JUNKIE_QUOTES</code></strong>\</p>
<p>这里只是为了完整性。Csh 和它的朋友们不允许像 zsh 那样的多行引用；如果你在一行结束前没有完成一对引号，csh 会抱怨。这个选项让 zsh 也这样做。但是多行引用在 zsh 脚本和函数中非常有用且非常常见；这只适用于那些因为使用 csh 而思想真正被搞乱的人。</p>
<p>[]{#l16}</p>
<h3 id="253-历史机制历史的类型"><a class="header" href="#253-历史机制历史的类型">2.5.3: 历史机制：历史的类型</a></h3>
<p><code>历史机制</code> 这个名字指的是 zsh 会保留你输入过的命令的 <code>历史</code>。有三种方法可以取回这些命令；所有这些都使用同一组命令行，但获取它们的机制却大不相同。出于某种原因，历史列表中的项目（一次输入并执行的完整一行输入）被称为 <code>事件</code>。</p>
<p><strong>直接编辑历史</strong>\</p>
<p>首先，你可以使用编辑器；通常按向上箭头会带你到上一行，向下箭头会带你回来。这通常是最简单的方法，因为你可以确切地看到你在做什么。我将在<a href="zshguide04.html#zle">第四章</a>中详细介绍编辑器；首先要知道的是它的基本命令要么像 emacs，要么像 vi，所以如果你知道其中一个，你就可以马上开始编辑行。shell 会尝试从环境变量 <code>$VISUAL</code> 或 <code>$EDITOR</code> 中猜测是使用 emacs 还是 vi，按此顺序；这些传统上保存着你需要编辑文本的程序所偏好的编辑器的名称。在过去，<code>$VISUAL</code> 是一个全屏编辑器，而 <code>$EDITOR</code> 是一个行编辑器，比如 <code>ed</code> of blessed memory，但现在这种区别已经非常模糊了。如果其中任何一个包含字符串 <code>vi</code>，行编辑器将以 vi 模式启动，否则将以 emacs 模式启动。如果你在错误的模式下，在 <code>~/.zshrc</code> 中使用 <code>bindkey -e</code> 会带你到 emacs 模式，<code>bindkey -v</code> 会带你到 vi 模式。对于 vi 用户，要记住的是你从插入模式开始，所以输入 <code>ESC</code> 才能输入 vi 命令。</p>
<p><strong><code>Bang</code>-历史</strong>\</p>
<p>其次，你可以使用 csh 风格的 <code>bang-history</code> 机制（除非你设置了 <code>NO_BANG_HIST</code> 选项）；<code>bang</code> 是感叹号，<code>!</code>，也称为 <code>pling</code> 或 <code>shriek</code>（或阶乘，但那是另一个故事）。因此 <code>!!</code> 检索最后一个命令行并执行它；<code>!-2</code> 检索倒数第二个。你可以选择单词：<code>!!:1</code> 选取最后一个命令的命令后的第一个单词（如果你上面注意听了，你会注意到在这种情况下你只需要一个 <code>!</code>）；冒号后的 <code>0</code> 会选取命令词本身；<code>*</code> 选取命令后的所有参数；<code>$</code> 选取最后一个单词。你甚至可以有范围：<code>!!:1-3</code> 选取那三个单词，像 <code>!!:3-$</code> 这样的也行。</p>
<p>在单词选择器之后，你可以有第二组冒号，然后是一些称为<strong>修饰符</strong>的特殊命令——记住这些非常有用，因为它们可以应用于参数和文件模式，所以这里有更多细节。<code>:t</code>（尾部）修饰符选取文件名的最后一部分，即最后一个斜杠之后的所有内容；相反，<code>:h</code>（头部）选取之前的所有内容。所以对于一个历史条目，</p>
<pre><code>  % print /usr/bin/cat
  /usr/bin/cat
  % print !!:t
  print cat
  cat
</code></pre>
<p>注意两件事：首先，bang-history 机制总是打印它将要执行的内容。其次，你不需要单词选择器；shell 可以判断出 <code>:t</code> 是一个修饰符，并假设你想将它应用于整个前一个命令。（这里要小心，因为实际上 <code>:t</code> 会将表达式简化为<em>任何</em>单词中最后一个斜杠之后的所有内容，这有点出乎意料。）</p>
<p>对于参数：</p>
<pre><code>  % foo=/usr/bin/cat
  % print ${foo:h}
  /usr/bin
</code></pre>
<p>（你通常可以省略 <code>{</code> 和 <code>}</code>，但有了它们会更清晰、更安全）。最后是文件——如果你为 sh-like 行为设置了 <code>NO_BARE_GLOB_QUAL</code>，这将不起作用：</p>
<pre><code>  % print /usr/bin/cat(:t)
  cat
</code></pre>
<p>在这里你需要括号来告诉 shell <code>:t</code> 不仅仅是文件名的一部分。</p>
<p>要获得完整列表，请参阅 <code>zshexpn</code> 手册，或手册印刷版或 Info 版中的 <code>Modifiers</code> 部分，但这里还有一些最有用的。<code>:r</code> 删除文件的后缀，将 <code>file.c</code> 变成 <code>file</code>；<code>:l</code> 和 <code>:u</code> 使单词全部小写或全部大写；<code>:s/foo/bar/</code> 将单词中第一次出现的 <code>foo</code> 替换为 <code>bar</code>；<code>:gs/foo/bar</code> 替换所有出现的（<code>g</code> 代表全局）；<code>:&amp;</code> 重复上一次这样的替换，即使你在前一行做的；<code>:g&amp;</code> 也有效。所以</p>
<pre><code>  % print this is this line
  this is this line
  % !!:s/this/that/
  print that is this line
  that is this line
  % print this is no longer this line
  this is no longer this line
  % !!:g&amp;
  print that is no longer that line
  that is no longer that line
</code></pre>
<p>最后，有一个快捷方式：<code>^old^new^</code> 完全等同于 <code>!!:s/old/new/</code>；你甚至可以在它后面放另一个修饰符。<code>^</code> 实际上是上面提到的 <code>$histchars</code> 的第二个字符。如果后面没有其他东西，你可以省略最后一个 <code>^</code>。顺便说一下，你可以把修饰符放在一起，但每个都需要带上冒号：<code>:t:r</code> 应用于 <code>dir/file.c</code> 会产生 <code>file</code>，重复应用 <code>:h</code> 会得到越来越短的路径。</p>
<p>在我们离开 bang-history 之前，请注意 <code>HIST_VERIFY</code> 选项。如果设置了该选项，那么在替换之后，该行会再次出现并带有更改，而不是立即被打印和执行。由于你只需键入 <code>&lt;RET&gt;</code> 即可执行它，这是一个有用的技巧，可以避免你执行错误的东西，这在复杂的 bang-history 行中很容易发生；我自己就设置了这个。</p>
<p>最后一个提示：shell 的扩展和补全，我稍后会热情洋溢地详细介绍，允许你在输入完整的引用后立即按 <code>TAB</code> 来扩展 bang-history 引用，你通常可以按 control 和斜杠（在某些键盘上，你只能用 <code>^Xu</code>）来将其恢复原状，如果你不喜欢结果的话——这是编辑器 <code>撤销</code> 功能的一部分。</p>
<p><strong>Ksh 风格的历史命令</strong>\</p>
<p>第三种历史形式使用 <code>fc</code> 内建命令。这是最麻烦的：你必须告诉命令要执行哪些完整的行，并且可能会有机会先编辑它们（但使用外部编辑器，而不是在 shell 中）。你可能不会那样使用它，但有三件事实际上是由 <code>fc</code> 控制的，你可能会用到：首先，<code>r</code> 命令重复最后一个命令（忽略 <code>r</code>），这有点像 <code>!!</code>。其次，名为 <code>history</code> 的命令实际上也是 <code>fc</code> 的伪装。它会给你一个最近命令的列表。它们旁边有数字；你可以用这些数字和 bang-history 一起使用，而不是像我最初解释的那样用负数向后计数，优点是它们不会随着你输入更多命令而改变。你可以给 <code>history</code> 一个数字范围，第一个数字是开始列出的地方，第二个是停止的地方：一个特别的例子是 <code>history 1</code>，它列出所有命令（即使它仍然记住的第一个命令高于 1；它只是默默地省略所有那些）。<code>fc</code> 的第三个用途是读写你的历史，这样你就可以在会话之间保留它。</p>
<p>[]{#l17}</p>
<h3 id="254-设置历史"><a class="header" href="#254-设置历史">2.5.4: 设置历史</a></h3>
<p>实际上，shell 能够在不被告知的情况下读写历史。然而，你需要告诉它在哪里保存历史，为此你必须将参数 <code>$HISTFILE</code> 设置为你想要使用的文件名（一个常见的选择是 <code>~/.history</code>）。接下来，你需要将参数 <code>$SAVEHIST</code> 设置为你想要保存的历史记录的行数。当这两个都设置好后，shell 将在交互式会话开始时从 <code>$HISTFILE</code> 中读取 <code>$HISTSIZE</code> 行，并在会话结束时保存你执行的最后 <code>$SAVEHIST</code> 行。要让它在中间读写，你要么需要设置下面描述的选项之一（<code>INC_APPEND_HISTORY</code> 和 <code>SHARE_HISTORY</code>），要么使用 <code>fc</code> 命令：<code>fc -R</code> 和 <code>fc -W</code> 分别读取和写入历史，而 <code>fc -A</code> 将其附加到文件中（尽管如果它比 <code>$SAVEHIST</code> 长，会进行修剪）；<code>fc -WI</code> 和 <code>fc -AI</code> 类似，但 <code>I</code> 意味着只写出自上次写入历史以来的事件。</p>
<p>还有一个第三个参数 <code>$HISTSIZE</code>，它决定了 shell 在一个会话中将保留的行数；除了我不会谈论的特殊原因，你应该将 <code>$SAVEHIST</code> 设置为不大于 <code>$HISTSIZE</code>，尽管它可以更少。<code>$HISTSIZE</code> 的默认值是 30，对于今天的计算机的内存和磁盘空间来说有点吝啬；zsh 用户通常使用高达 1000。所以在 <code>.zshrc</code> 中设置的一组简单参数是</p>
<pre><code>  HISTSIZE=1000
  SAVEHIST=1000
  HISTFILE=~/.history
</code></pre>
<p>这就足以让事情正常工作了。请注意，你<em>必须</em>设置 <code>$SAVEHIST</code> 和 <code>$HISTFILE</code> 才能使历史行的自动读写工作。</p>
<p>[]{#l18}</p>
<h3 id="255-历史选项"><a class="header" href="#255-历史选项">2.5.5: 历史选项</a></h3>
<p>还有许多影响历史的选项；这些在 3.1.6 版本中大幅增加，该版本首次提供了 <code>INC_APPEND_HISTORY</code>、<code>SHARE_HISTORY</code>、<code>HIST_EXPIRE_DUPS_FIRST</code>、<code>HIST_IGNORE_ALL_DUPS</code>、<code>HIST_SAVE_NO_DUPS</code> 和 <code>HIST_NO_FUNCTIONS</code>。我已经描述了 <code>BANG_HIST</code>、<code>CSH_JUNKIE_HISTORY</code> 和 <code>HIST_VERIFY</code>，我不会再谈论它们。</p>
<p><strong><code>APPEND_HISTORY</code>, <code>INC_APPEND_HISTORY</code>, <code>SHARE_HISTORY</code></strong>\</p>
<p>通常，当 zsh 写入历史文件时，它只是覆盖那里的所有内容。<code>APPEND_HISTORY</code> 允许它将新的历史附加到旧的上面。shell 会努力不写出应该已经存在的行；如果你在不同的窗口中同时运行很多 zsh，这可能会变得复杂。这个选项对大多数人来说都很好用。<code>INC_APPEND_HISTORY</code> 意味着不是在 shell 退出时这样做，而是每行在执行时都以这种方式添加到历史中；这意味着，例如，如果你在主 shell 中启动一个 zsh，它的历史将看起来像主 shell 的历史，这非常有用。这也意味着同时运行的不同 shell 的命令排序更加合乎逻辑——基本上就是它们被执行的顺序——所以对于 3.1.6 及更高版本，推荐使用此选项。</p>
<p><code>SHARE_HISTORY</code> 更进一步：每添加一行，都会检查历史文件，看是否有其他 shell 写出的内容，如果有，则也包含在当前 shell 的历史中。这意味着在不同窗口中运行但在同一主机上（或更普遍地具有相同主目录）的 zsh 共享相同的历史。请注意，zsh 试图不让你因为弹出意外的历史条目而感到困惑：如果你使用 <code>!</code> 风格的历史，来自其他会话的命令在历史列表中不会出现，直到你明确输入 <code>history</code> 命令来显示它们，这样你就可以确定你实际重新执行的是哪个命令。Korn shell 的行为总是好像设置了 <code>SHARE_HISTORY</code>，大概是因为它不内部存储历史。</p>
<p><strong><code>EXTENDED_HISTORY</code></strong>\</p>
<p>这使得历史条目的格式更加复杂：除了命令本身，它还保存了命令开始的时间以及它运行了多长时间。<code>history</code> 命令有三个使用这个的选项：<code>history -d</code> 打印命令的开始时间；<code>history -f</code> 打印那个以及日期；<code>history -D</code>（你可以与 <code>-f</code> 或 <code>-d</code> 结合使用）打印命令的已用时间。日期格式可以用 <code>-E</code> 改为欧洲格式（<em>日</em>.<em>月</em>.<em>年</em>）和 <code>-i</code> 改为国际格式（<em>年</em>-<em>月</em>-<em>日</em>）。你<em>不</em>想设置这个的主要原因会是磁盘空间不足，或者因为你想让你的历史文件被另一个 shell 读取。</p>
<p><strong><code>HIST_IGNORE_DUPS</code>, <code>HIST_IGNORE_ALL_DUPS</code>, <code>HIST_EXPIRE_DUPS_FIRST</code>, <code>HIST_SAVE_NO_DUPS</code>, <code>HIST_FIND_NO_DUPS</code></strong>\</p>
<p>这些选项提供了处理历史中经常出现的重复行的方法。最简单的是 <code>HIST_IGNORE_DUPS</code>，它告诉 shell 如果一行与前一行相同，就不要存储它，从而将大量重复的命令压缩成一个；这是一个非常好的选项。当重复行不相邻时，它不起作用，所以例如交替的命令对总是会被存储。接下来的两个选项可以在这里提供帮助：<code>HIST_IGNORE_ALL_DUPS</code> 只是删除历史列表中仍然存在的行的副本，保留新添加的那个，而 <code>HIST_EXPIRE_DUPS_FIRST</code> 更微妙：当历史填满时，它会优先删除重复项，但在此之前什么也不做。<code>HIST_SAVE_NO_DUPS</code> 意味着无论当前会话设置了什么选项，shell 都不会多次保存重复的行；而 <code>HIST_FIND_NO_DUPS</code> 意味着即使重复的行已被保存，使用编辑器命令向后搜索时也不会多次显示它们。</p>
<p><strong><code>HIST_ALLOW_CLOBBER</code>, <code>HIST_REDUCE_BLANKS</code></strong>\</p>
<p>这些允许历史机制在行被输入时对其进行更改。第一个影响输出重定向，即你使用符号 <code>&gt;</code> 将一个或一组命令的输出重定向到一个命名文件，或使用 <code>&gt;&gt;</code> 将输出附加到该文件。如果你设置了 <code>NO_CLOBBER</code> 选项，那么</p>
<pre><code>  touch newfile
  echo hello &gt;newfile
</code></pre>
<p>会失败，因为 <code>touch</code> 命令创建了 <code>newfile</code>，而 <code>NO_CLOBBER</code> 不会让你在下一行覆盖（clobber）它。使用 <code>HIST_ALLOW_CLOBBER</code>，第二行在历史中显示为</p>
<pre><code>  echo hello &gt;|newfile
</code></pre>
<p>其中 <code>&gt;|</code> 覆盖了 <code>NO_CLOBBER</code>。所以要绕过 <code>NO_CLOBBER</code>，你只需回到前一行并执行它，而无需编辑。</p>
<p>第二个选项，<code>HIST_REDUCE_BLANKS</code>，会在行被输入到历史中时整理它，方法是删除任何对 shell 没有意义的多余空格。这也可能意味着即使在未整理的形式下它不是前一行的副本，该行也会成为副本。它足够聪明，不会删除重要的空格，即被引用的空格。</p>
<p><strong><code>HIST_IGNORE_SPACE</code>, <code>HIST_NO_STORE</code>, <code>HIST_NO_FUNCTIONS</code></strong>\</p>
<p>这三个选项允许你说某些行根本不应该进入历史。<code>HIST_IGNORE_SPACE</code> 意味着以空格开头的行不进入历史；其想法是，你在输入任何想在之后立即忘记的行之前，故意输入一个对 shell 没有其他意义的空格。在 zsh 4.0.1 中，这是这样实现的：你总是可以回忆起紧邻的前一行进行编辑，即使它有空格；但是当下一行被执行并输入到历史中时，以空格开头的行就被忘记了。</p>
<p><code>HIST_NO_STORE</code> 告诉 shell 不要存储 <code>history</code> 或 <code>fc</code> 命令，而 <code>HIST_NO_FUNCTIONS</code> 告诉它不要存储函数定义，因为这些虽然通常不频繁，但可能长得令人厌烦。函数定义是任何以 <code>function funcname {...</code> 或 <code>funcname () { ...</code> 开头的东西。</p>
<p><strong><code>NO_HIST_BEEP</code></strong>\</p>
<p>最后，<code>HIST_BEEP</code> 用于编辑器：如果你试图向上或向下滚动超出历史列表的末尾，shell 会发出哔哔声。它默认是打开的，所以使用 <code>NO_HIST_BEEP</code> 来关闭它。</p>
<p>[]{#l19}</p>
<h3 id="256-提示符"><a class="header" href="#256-提示符">2.5.6: 提示符</a></h3>
<p>大多数人在 <code>.zshrc</code> 中都有一些定义，用于更改你在每行开头看到的提示符。我已经提到了 <code>PROMPT_PERCENT</code>（默认设置）和 <code>PROMPT_SUBST</code>（默认未设置）；我在这里假设你没有更改这些设置，并指出<strong>提示符转义</strong>的一些可能性，即以 <code>%</code> 开头的序列。如果你变得非常老练，你可能需要打开 <code>PROMPT_SUBST</code>。</p>
<p>主提示符在一个名为 <code>$PS1</code> 或 <code>$PROMPT</code> 或 <code>$prompt</code> 的参数中；有所有这些名称的原因是历史性的——它们来自不同的 shell——所以我只用最短的。还有一个 <code>$RPS1</code>，它在屏幕右侧打印一个提示符。它的要点是，如果你输入的行太长以至于碰到它，它会自动消失，所以它可以帮助最好地利用空间来显示像目录这样的长东西。</p>
<p><code>$PS2</code> 在 shell 等待更多输入时显示，即它知道你到目前为止输入的内容不是一个完整的行：它可能包含一个引用表达式的开始，但没有结束，或者某个尚未完成的语法结构的开始。通常你会让它与 <code>$PS1</code> 不同，但在所有五个提示符中都理解所有相同的转义。</p>
<p><code>$PS3</code> 在由 shell 的 <code>select</code> 机制启动的循环中显示，当 shell 希望你输入一个选择时：请参阅 <code>zshmisc</code> 手册页，因为我不会对此说太多。</p>
<p><code>$PS4</code> 在调试时很有用：有一个 <code>XTRACE</code> 选项，它使 shell 打印出将要执行的行，前面加上 <code>$PS4</code>。直到 3.1.6 版本，它才开始像其他提示符一样被替换，尽管这被证明非常有用——请参阅下面列表中的 <code>脚本或函数中的位置</code>。</p>
<p>这里有一些你可能想包含在提示符中的东西。请注意，你可以在更改提示符之前通过使用 <code>print -P</code> 来尝试这个：这将像在提示符中一样扩展字符串。你可能需要将字符串放在单引号中。</p>
<p><strong>时间</strong>\</p>
<p>Zsh 允许你用很多不同的方式通过百分比转义将时间放入提示符。最简单的是 <code>%t</code> 和 <code>%T</code>，分别是 12 小时和 24 小时格式的时间，以及 <code>%*</code>，与 <code>%T</code> 相同但带有秒；你也可以用 <code>%w</code> 得到像 <code>Wed 22</code> 这样的日期，用 <code>%W</code> 得到 <code>9/22/99</code>（美国格式），或者用 <code>%D</code> 得到 <code>99-09-22</code>（国际格式）。然而，还有另一种使用 <code>%D</code> 的方法可以获得更多的可能性：一个跟在后面的花括号中的字符串，<code>%D{...}</code>，可以包含一个完全不同的百分比转义集，所有这些都指代时间和日期的元素。在大多数系统上，<code>strftime</code> 函数的文档会告诉你这些是什么。zsh 有一些自己的，在 <code>zshmisc</code> 手册页的 <code>PROMPT EXPANSION</code> 部分给出。例如，我使用 <code>%D{%L:%M}</code>，它以小时和分钟给出时间，小时对于 1 到 9 是一个单数；在我这种不老练的眼睛看来，它更亲切。</p>
<p>你可以通过使用 <code>%(*numX*.*true*.*false*)</code> 语法来获得更多乐趣，其中 <em>X</em> 是 <code>t</code> 或 <code>T</code> 之一。对于 <code>t</code>，如果分钟数与 <em>num</em>（默认为零）相同，则 <em>true</em> 将用作提示符此部分的文本，否则使用 <em>false</em>。<code>T</code> 对小时做同样的事情。因此</p>
<pre><code>  PS1='%(t.Ding!.%D{%L:%M})%# '
</code></pre>
<p>在整点时打印消息 <code>Ding!</code>，否则打印更常规的时间。<code>%#</code> 是标准序列，如果你是超级用户（root），则打印一个 <code>#</code>，对于其他所有人则打印一个 <code>%</code>，这出现在很多人的提示符中。同样，你可以使用 <code>%(30t.Dong!.)</code>...` 来在半点时显示消息。</p>
<p><strong>当前目录</strong>\</p>
<p>序列 <code>%~</code> 打印出目录，任何主目录或命名目录（见下文）都会被缩短为以 <code>~</code> 开头的形式；序列 <code>%/</code> 不做那种缩短，所以通常 <code>%~</code> 更好。目录可能很长，有各种方法可以处理它。首先，如果你正在使用窗口系统，你可以把目录放在标题栏里，而不是窗口内的任何地方。其次，你可以使用 <code>$RPS1</code>，当你输入靠近它时它会消失。第三，你可以通过在 <code>%</code> 后面给一个数字来从 <code>%~</code> 或 <code>%/</code> 中挑选出片段：例如，<code>%1~</code> 只挑选出当前目录路径的最后一段。</p>
<p>第四种方法给你最大的控制权。提示符或提示符的一部分，不仅仅是显示目录的部分，都可以被截断到你选择的任何长度。要从左边截断路径，使用类似 <code>%10&lt;*...*&lt;%~</code> 的东西。它的工作原理是这样的：<code>%&lt;&lt;</code> 是截断的基本形式。<code>%</code> 后面的 10 表示后面的任何东西都限制在 10 个字符以内，而字符 <code>*...*</code> 将在提示符否则会比那更长时显示（你可以留空）。这适用于后面的任何东西，所以现在 <code>%~</code> 不能超过 10 个字符，否则它将被截断（到 7 个字符，一旦 <code>...</code> 被打印出来）。你可以用 <code>%&lt;&lt;</code> 关闭截断，即 <code>%</code> 后面没有数字；然后截断适用于它被打开和关闭之间的整个区域（这与旧版本的 zsh 不同，旧版本只适用于单个 <code>%</code> 结构）。</p>
<p><strong>你在等什么？</strong>\</p>
<p>提示符 <code>$PS2</code> 在 shell 等待你完成输入时出现，知道 shell 在等什么很有用。序列 <code>%_</code> 显示了这个。它是默认 <code>$PS2</code> 的一部分，即 <code>%_&gt; </code>。因此，如果你输入 <code>if true; then</code> 和 <code>&lt;RET&gt;</code>，提示符会说 <code>then&gt; </code>。你也可以在跟踪提示符 <code>$PS4</code> 中使用它，以显示关于在脚本或函数中正在执行的相同信息，尽管由于那里通常有足够的信息（如下所述），它不是默认的一部分。在这种情况下，<code>%</code> 后面的数字将限制显示的深度，所以用 <code>%1_</code> 只会提到最近的事情。</p>
<p><strong>脚本或函数中的位置</strong>\</p>
<p>默认的 <code>$PS4</code> 包含 <code>%N</code> 和 <code>%i</code>，它们告诉你最近启动的函数、脚本或源文件的名称，以及正在执行的行号；它们在其他提示符中不是很有用。然而，<code>$PS1</code> 中的 <code>%i</code> 会告诉你当前的交互式行号，zsh 会跟踪它，但通常不显示；参数 <code>$LINENO</code> 包含相同的信息。</p>
<p>关于 <code>%i</code> 的另一点要记住的是，显示的行号适用于首次读入的函数版本，而不是它在 <code>functions</code> 命令中显示的样子，后者是整理过的。然而，如果你使用自动加载的函数，包含该函数的文件通常是你想要修改的，所以在调试时这应该不是问题。</p>
<p>记住，<code>$PS4</code> 的显示只有在设置了 <code>XTRACE</code> 选项时才会发生；由于选项可能是函数局部的，并且总是脚本局部的，你通常需要在你正在调试的任何东西的顶部放一个显式的 <code>setopt xtrace</code>。或者，你可以使用 <code>typeset -ft</code> <em>funcname</em> 来为该函数打开跟踪（这是我刚刚发现的东西）；使用 <code>typeset +ft</code> <em>funcname</em> 来再次关闭它。</p>
<p><strong>其他零碎</strong>\</p>
<p><code>zshmisc</code> 手册页中描述了许多其他的百分比转义，大多都很直接。例如，<code>%h</code> 显示你的历史条目号，如果你正在使用 bang-history 会很有用；<code>%m</code> 显示你当前的主机名，直到任何点为止；<code>%n</code> 显示用户名。</p>
<p>还有两个我自己碰巧使用的特性。首先，知道上一个命令是否失败有时很方便。每个命令都会返回一个状态，这是一个数字：零表示成功，其他一些数字表示某种类型的失败。你可以从参数 <code>$?</code> 或 <code>$status</code> 中得到这个（同样，它们指的是同一件事）。它在提示符中也可用作 <code>%?</code>，还有一个我为时间描述过的所谓的 <code>三元</code> 表达式，它根据测试选择不同的字符串。这里的测试，很合理地，是 <code>%(?...</code>。把这两个放在一起，你可以得到一个只在退出状态非零时显示的消息；我为了更清楚，在数字周围加了一组额外的括号，其中 <code>)</code> 需要变成 <code>%)</code> 以防止它标记组的结束：</p>
<pre><code>  PS1='%(?..(%?%))%# '
</code></pre>
<p>知道你是否在子 shell 中有时也很方便，也就是说，如果你通过输入 <code>zsh</code> 在主 shell 中启动了另一个 shell。你可以通过使用另一个三元表达式来做到这一点：</p>
<pre><code>  PS1='%(2L.+.)%# '
</code></pre>
<p>这会检查参数 <code>SHLVL</code>，每次启动新的 zsh 时它都会递增，所以如果已经有一个在运行（它会将 <code>SHLVL</code> 设置为 1），现在它将是 2；如果 <code>SHLVL</code> 至少是 2，提示符前会打印一个额外的 <code>+</code>，否则什么也不打印。如果你正在使用窗口系统，你可能需要将 2 变成 3，因为你第一次登录时可能已经有一个 zsh 在运行，所以窗口中的 shell 的 <code>SHLVL</code> 已经设置为 2。这在很大程度上取决于你的窗口系统是如何设置的；找出更多信息留给读者作为练习。</p>
<p><strong>颜色</strong>\</p>
<p>许多终端现在可以显示颜色，能够将这些颜色放入提示符以将它们与周围的文本区分开来非常有用。我经常发现一个程序刚刚在我的终端上倾倒了一大堆输出，而且不清楚它从哪里开始。能够找到之前的提示符有很大帮助。</p>
<p>颜色，就像粗体或下划线文本一样，使用不移动光标的转义序列。将任何此类转义序列插入提示符的黄金法则是用 <code>%{</code> 在开头和 <code>%}</code> 在结尾包围它们。否则，shell 会对行的长度感到困惑。这会影响行编辑器需要重画行时发生的情况，并且还会改变右提示符 <code>$RPS1</code> 的位置，如果你使用它的话。你不需要对特殊序列 <code>%B</code> 和 <code>%b</code> 这样做，它们分别开始和停止粗体文本，因为 shell 已经知道如何处理那些；只有你碰巧知道不移动光标但 shell 不知道的随机字符才会导致问题。</p>
<p>在颜色的情况下，标准发行版提供了一个 shell 函数 <code>colors</code> 来帮助你。加载并运行时，它定义了关联数组参数 <code>$fg</code> 和 <code>$bg</code>，你用它们来提取给定颜色的转义序列，例如 <code>${fg[red]}${bg[yellow]}</code> 产生红色文本在黄色背景上的序列。所以例如，</p>
<pre><code>  PS1="%{${bg[white]}${fg[red]}%}%(?..(%?%))\ 
  %{${fg[yellow]}${bg[black]}%}%# "
</code></pre>
<p>如果前一个程序以状态 1 退出，则产生一个红底白字的 <code>(1)</code>，但如果它以状态 0 退出，则什么也不产生，后面跟着一个黄底黑字的 <code>%</code> 或 <code>#</code>（如果你是超级用户）。注意这里使用双引号来强制参数立即展开——转义序列是固定的，所以它们不需要每次显示提示符时都从参数中重新提取。</p>
<p>即使你的终端确实支持颜色，也不能保证所有可能性都有效，尽管基本的 ANSI 颜色方案是相当标准的。理解的颜色有：青色、白色、黄色、品红色、黑色、蓝色、红色、灰色、绿色。你也可以使用 <code>default</code>，它将终端恢复到开始时的状态。此外，你可以将基本颜色与参数 <code>$bg_bold</code> 和 <code>$fg_bold</code> 一起使用以获得颜色的粗体变体，以及 <code>$bg_no_bold</code> 和 <code>$fg_no_bold</code> 来明确切换回非粗体。</p>
<p><strong>主题</strong>\</p>
<p>还有一组作为函数提供的主题，用于将你的提示符设置为各种预定义的可能性。这些利用了如上所述设置的颜色。请参阅 <code>zshcontrib</code> 手册页了解如何做到这一点（搜索 <code>prompt themes</code>）。</p>
<p>[]{#l20}</p>
<h3 id="257-命名目录"><a class="header" href="#257-命名目录">2.5.7: 命名目录</a></h3>
<p>如前所述，文件名开头的 <code>~/</code> 会扩展为你的主目录。更一般地，<code>~</code><em>user</em><code>/</code> 允许你引用任何其他用户的主目录。此外，zsh 允许你定义自己的使用此语法的命名目录。基本思想很简单，因为任何参数都可以是一个命名目录：</p>
<pre><code>  dir=/tmp/mydir
  print ~dir
</code></pre>
<p>打印 <code>/tmp/mydir</code>。到目前为止，这与使用参数 <code>$dir</code> 没有任何不同。区别在于如果你在提示符中使用 <code>%~</code> 结构，如上所述。然后当你切换到那个目录时，你不会看到消息 <code>/tmp/mydir</code>，而是会看到缩写 <code>~dir</code>。</p>
<p>在你至少一次自己使用 <code>~dir</code> 强制 shell 注册目录名称之前，shell 不会注册它。你可以在你的 <code>.zshrc</code> 中执行以下操作：</p>
<pre><code>  dir=/tmp/mydir
  bin=~/myprogs/bin
  : ~dir ~bin
</code></pre>
<p>其中 <code>:</code> 是一个什么都不做的命令——但它的参数会像往常一样被检查参数等，以便 shell 可以将 <code>dir</code> 和 <code>bin</code> 放入其命名目录列表中。这样做的一个更简单的方法是设置 <code>AUTO_NAME_DIRS</code> 选项；然后任何创建的引用目录的参数都会自动变成一个名称。目录必须有绝对路径，即其扩展值，在将开头的任何 <code>~</code> 转换为完整路径后，必须以 <code>/</code> 开头。参数 <code>$PWD</code>，显示当前目录，被保护不被变成 <code>~PWD</code>，因为那不会告诉你任何信息。</p>
<p>[]{#l21}</p>
<h3 id="258-高级用户的加速选项"><a class="header" href="#258-高级用户的加速选项">2.5.8: 高级用户的“加速”选项</a></h3>
<p>这里还有一些你可能想在你的 <code>.zshrc</code> 中设置的随机选项。</p>
<p><strong><code>NO_BEEP</code></strong>\</p>
<p>通常 zsh 在不喜欢某些东西时会发出哔哔声。这可能会非常烦人；<code>setopt nobeep</code> 会关闭它。我非正式地称之为 <code>OPEN_PLAN_OFFICE_NO_VIGILANTE_ATTACKS</code> 选项。</p>
<p><strong><code>AUTO_CD</code></strong>\</p>
<p>如果设置了此选项，并且你输入了没有参数且不是命令的东西，zsh 会检查它是否实际上是一个目录。如果是，shell 将切换到该目录。所以 <code>./bin</code> 本身等同于 <code>cd ./bin</code>，只要目录 <code>./bin</code> 确实存在。这在 <code>..</code> 的形式中特别有用，它会切换到父目录。</p>
<p><strong><code>CD_ABLE_VARS</code></strong>\</p>
<p>这是在切换目录时节省输入的另一种方法，尽管只有一个字符。如果你尝试切换到一个不存在的目录，zsh 会尝试找到一个同名的参数并使用它。你也可以在参数后面有一个 <code>/</code> 和其他东西。所以 <code>cd </code>foo/dir<code>，如果没有目录 `foo` 但有一个参数 `$foo`，就等同于 `cd `$foo/dir</code>。</p>
<p><strong><code>EXTENDED_GLOB</code></strong>\</p>
<p>在 zsh 中，用于匹配文件名和其他东西的模式可以非常复杂，但要充分利用它们，你需要使用这个选项，否则某些功能不会被启用，这样习惯于更简单模式（可能只是 <code>*</code>、<code>?</code> 和 <code>[...]</code>）的人就不会被奇怪的现象所迷惑。我将更多地谈论 zsh 的模式特性，但这只是提醒你，如果你正在用 <code>~</code>、<code>#</code>、<code>^</code> 或 globbing 标志做任何聪明的事情，你需要这个选项——并且也提醒你，如果你设置了该选项，那些字符可能会有奇怪的效果。</p>
<p><strong><code>MULTIOS</code></strong>\</p>
<p>我上面提到过，要让 zsh 表现得像 ksh，你需要设置 <code>NO_MULTIOS</code>，但我没有说 <code>MULTIOS</code> 选项是做什么的。它对输出和输入有两个不同的效果。</p>
<p>首先，对于输出。在这里，它是 <code>tee</code> 程序的替代品。我提到过一次，但没有详细描述，你可以使用 <code>&gt;filename</code> 来告诉 shell 将输出发送到一个给定名称的文件中，而不是发送到终端。设置了 <code>MULTIOS</code> 后，你可以在命令行上有多个这样的重定向：</p>
<pre><code>  echo foo &gt;file1 &gt;file2
</code></pre>
<p>在这里，<code>foo</code> 将被写入<strong>两个</strong>命名文件；zsh 复制输出。管道机制，我将在<a href="zshguide03.html#syntax">第三章</a>中更好地描述，是一种重定向到另一个程序而不是文件的机制：<code>MULTIOS</code> 也影响这个：</p>
<pre><code>  echo foo &gt;file1 | sed 's/foo/bar/'
</code></pre>
<p>在这里，<code>foo</code> 再次被写入 <code>file1</code>，但也被发送到 <code>sed</code>（<code>stream editor</code>）程序的管道中，该程序将 <code>foo</code> 替换为 <code>bar</code> 并（因为这部分没有输出重定向）将其打印到终端。</p>
<p>请注意，上面的第二个例子曾多次被报告为错误，通常形式如下：</p>
<pre><code> some_command 2&gt;&amp;1 &gt;/dev/null | sed 's/foo/bar/'
</code></pre>
<p>这里的意图大概是将标准错误发送到标准输出（<code>2&gt;&amp;1</code>，一个非常常用的 shell 象形文字），并且不将标准输出发送到任何地方（<code>&gt;/dev/null</code>）。（如果你没有遇到过 <code>标准错误</code> 的概念，它只是另一个输出通道，除非你重定向它，否则它会去与正常输出相同的地方；例如，它用于向终端发送错误消息，即使你的输出正在去别处。）在这个例子中，<code>MULTIOS</code> 功能也强制原始标准输出进入管道。如果我们放入一个 <code>some_command</code> 的版本，你可以看到这种情况发生：</p>
<pre><code> { echo foo error &gt;&amp;2; echo foo not error;  } 2&gt;&amp;1 &gt;/dev/null |
  sed 's/foo/bar/'
</code></pre>
<p>在这里，你可以将 <code>{...}</code> 内的东西视为一个黑匣子，它将消息 <code>foo error</code> 发送到标准错误，将 <code>foo not error</code> 发送到标准输出。然而，使用 <code>MULTIOS</code>，结果是</p>
<pre><code> error bar
  not error bar
</code></pre>
<p>因为两者都已发送到管道中。没有 <code>MULTIOS</code>，你会得到预期的结果，</p>
<pre><code> error bar
</code></pre>
<p>就像任何其他 Bourne 风格的 shell 会产生的那样。</p>
<p>在输入方面，<code>MULTIOS</code> 安排了一系列文件按顺序读取。这次它有点像使用 <code>cat</code> 程序，它会合并它后面列出的所有文件。换句话说，</p>
<pre><code>  cat file1 file2 | myprog
</code></pre>
<p>（其中 <code>myprog</code> 是某个读取所有作为输入发送给它的文件的程序）可以被替换为</p>
<pre><code>  myprog &lt;file1 &lt;file2
</code></pre>
<p>这做的是同样的事情。再一次，管道算作一个重定向，并且管道首先被读取，在任何 <code>&lt;</code> 后面列出的文件之前：</p>
<pre><code>  echo then this &gt;testfile
  echo this first | cat &lt;testfile
</code></pre>
<p><strong><code>CORRECT</code>, <code>CORRECT_ALL</code></strong>\</p>
<p>如果你设置了 <code>CORRECT</code>，shell 会检查你输入的所有命令，如果它们不存在，但有一个名称相似的命令，它会问你是否是指那个。你可以输入 <code>n</code> 表示不，不纠正，直接继续；<code>y</code> 表示是，纠正它然后继续；<code>a</code> 表示中止，什么也不做；<code>e</code> 表示编辑，返回编辑器再次编辑同一行。新补全系统的用户应该注意，这与你在那里得到的纠正不同：这只是对命令的简单纠正。</p>
<p><code>CORRECT_ALL</code> 适用于行上的所有单词。它稍微不那么有用，因为目前 shell 必须假设它们应该是文件名，并且如果它们不存在，会尝试纠正它们，但当然命令的许多参数不是文件名。如果特定命令产生太多对其参数的纠正尝试，你可以通过在命令名前面放上 <code>nocorrect</code> 来关闭它。别名是做到这一点的一个非常好的方法，如下所述。</p>
<p>[]{#l22}</p>
<h3 id="259-别名"><a class="header" href="#259-别名">2.5.9: 别名</a></h3>
<p>别名像命令一样使用，但它会扩展成一些其他文本，而这些文本本身又被用作命令。例如，</p>
<pre><code>  alias foo='print I said foo'
  foo
</code></pre>
<p>打印（猜猜看）<code>I said foo</code>。注意定义的语法——你需要 <code>=</code>，并且你需要确保整个别名被 shell 视为一个单词；你可以给同一个 <code>alias</code> 命令一个完整的别名列表。你可能会想到一些你想在启动文件中定义的别名；<code>.zshrc</code> 可能是正确的地方。如果你设置了 <code>CORRECT_ALL</code>，避免 <code>mkdir</code> 命令对其参数进行拼写检查的方法是——这是无用的，因为它们<em>必须</em>不存在才能使命令工作——定义：</p>
<pre><code>  alias mkdir='nocorrect mkdir'
</code></pre>
<p>这显示了别名的一个有用特性：别名可以包含与自身同名的东西。当它在扩展文本（右侧）中遇到时，shell 知道不要再次扩展别名，而是这次将其视为一个真正的命令。请注意，函数<em>没有</em>这个属性：函数比别名更强大，在某些情况下，它们调用自己是很有用的。让函数一遍又一遍地调用自己直到 shell 抱怨是一个常见的错误。我将在<a href="zshguide03.html#syntax">第三章</a>中描述解决这个问题的方法。</p>
<p>函数比别名更强大的另一种方式是，函数可以接受参数而别名不能——换句话说，没有办法在别名内部引用命令行上跟随它的内容，不像函数，也不像 csh 中的别名（因为那没有函数，这就是为什么）。它只是被盲目地扩展，命令行的其余部分被附加在末尾。因此，zsh 中的别名通常用于非常简单的事情，而任何更复杂的事情都用函数来编写。不过，你不能用函数来做那个 <code>nocorrect</code> 的技巧，因为函数被调用得太晚了：别名是立即扩展的，所以 <code>nocorrect</code> 被及时发现以发挥作用。你几乎可以把它们看作是纯粹的打字缩写。</p>
<p>普通别名只在命令位置工作，即在命令行的开头（更严格地说，当 zsh 期望一个命令时）。还有其他叫做 <code>全局别名</code> 的东西，你通过 <code>alias</code> 的 <code>-g</code> 选项来定义，它们会在命令行的任何位置被扩展。你应该在定义这些之前认真考虑，因为它们可能会产生巨大的影响。但是请注意，引用一个单词，甚至一个字符，都会阻止别名为其扩展。</p>
<p>我只倾向于在交互式 shell 中使用别名，所以我从 <code>.zshrc</code> 中定义它们，但如果你更广泛地使用别名，你可能想使用 <code>.zshenv</code>。事实上，为了保持我的 <code>.zshrc</code> 整洁，我把所有的别名都保存在一个名为 <code>.aliasrc</code> 的单独文件中，在 <code>.zshrc</code> 中我有：</p>
<pre><code>  if [[ -r ~/.aliasrc ]]; then
    . ~/.aliasrc
  fi
</code></pre>
<p>它检查是否存在一个可读的文件 <code>~/.aliasrc</code>，如果存在，它会以与正常启动文件完全相同的方式运行它。你可以用 <code>source</code> 代替 <code>.</code>，如果它对你更有意义的话；然而，<code>.</code> 是传统的 Bourne 和 Korn shell 名称。</p>
<p>[]{#l23}</p>
<h3 id="2510-环境变量"><a class="header" href="#2510-环境变量">2.5.10: 环境变量</a></h3>
<p>通常，一个程序的说明书会告诉你定义某些环境变量，通常是一组大写字母，可能还有数字和奇怪的下划线。这些可以在不需要你使用额外参数的情况下向程序传递信息。在 zsh 中，环境变量显示为普通的 shell 参数，尽管它们的定义方式略有不同：严格来说，环境是 shell 外部的一个特殊区域，zsh 必须被告知在那里放一个副本，同时自己也保留一个。通常的语法是</p>
<pre><code>  export VARNAME='value'
</code></pre>
<p>换句话说，就像一个普通的赋值，但在前面有 <code>export</code>。注意环境变量的名称前没有 <code>$</code>；所有 <code>export</code> 和类似的语句都以同样的方式工作。放置这些最简单的地方是 <code>.zshenv</code>——因此它的名字。环境变量将被传递给从 shell 运行的任何程序，所以将它们定义在 <code>.zlogin</code> 或 <code>.zprofile</code> 中可能就足够了：然而，任何为你非交互式启动的 shell 都不会运行那些，而且如果你使用一个由 zsh 以外的 shell 启动的窗口系统，或者根本不运行 shell 启动文件，还可能存在其他问题——我不得不调整我的来让它这样做。所以 <code>.zshenv</code> 是最安全的地方；定义环境变量并不需要很长时间。其他人无疑会给你完全矛盾的观点，但人就是这样。</p>
<p>请注意，你不能导出数组。如果你导出一个参数，然后给它赋一个数组，环境中不会出现任何东西；你可以使用外部命令 <code>printenv VARNAME</code>（同样没有 <code>$</code>，因为命令需要知道名称，而不是值）来检查。数组还有一个更微妙的问题。<code>export</code> 内建命令只是内建命令 <strong>typeset</strong> 的一个特例，它定义一个变量而不标记它以便导出到环境。你可能会认为你可以这样做</p>
<pre><code>  typeset array=(这不起作用)
</code></pre>
<p>但你不能——特殊的数组语法只有在赋值不跟在命令后面时才被理解，而不是在像这里这样的普通参数中，所以你必须把数组赋值放在下一行。这是一个非常容易犯的错误。<code>typeset</code> 的更多用法将在<a href="zshguide03.html#syntax">第三章</a>中描述；它们包括在函数中创建局部参数，以及为参数定义特殊属性（其中 <code>export</code> 属性只是一个）。</p>
<p>[]{#l24}</p>
<h3 id="2511-路径"><a class="header" href="#2511-路径">2.5.11: 路径</a></h3>
<p>能够找到外部程序，即任何不属于 shell 的部分，任何除了内建命令、函数或别名之外的命令，都很有帮助。<code>$path</code> 数组用于此目的。实际上，系统需要的是环境变量 <code>$PATH</code>，它包含一个目录列表，用于在其中搜索程序，目录之间用冒号分隔。这些目录是数组 <code>$path</code> 的各个组成部分。所以如果 <code>$path</code> 包含</p>
<pre><code>  path=(/bin /usr/bin /usr/local/bin .)
</code></pre>
<p>那么 <code>$PATH</code> 将自动包含</p>
<pre><code>  PATH=/bin:/usr/bin:/usr/local/bin:.
</code></pre>
<p>的效果，而无需你设置它。这个想法很简单，虽然系统需要 <code>$PATH</code> 因为它不理解数组，但在 shell 内部使用数组要灵活得多，因此几乎可以忘记 <code>$PATH</code> 的形式。</p>
<p>对路径的更改与上面描述的环境变量的更改类似，所以所有这些都适用。然而，在 <code>.zshenv</code> 中设置 <code>$path</code> 有一点困难，尽管上面给出的这样做的理由仍然适用。通常，路径会为你设置好，要么由系统，要么由系统管理员在某个全局启动文件中设置，如果你更改路径，你只想在它上面添加。但如果你的 <code>.zshenv</code> 包含</p>
<pre><code>  path=(~/bin ~/progs/bin $path)
</code></pre>
<p>——这是在 <code>$path</code> 前面添加东西的正确方法——那么每次调用 <code>.zshenv</code> 时，<code>~/bin</code> 和 <code>~/progs/bin</code> 都会被塞到前面，所以如果你启动另一个 zsh，你就会有两套在那里。</p>
<p>当然，你可以添加测试来看看某个东西是否已经存在。Zsh 方便地允许你测试数组中元素的存在。通过在数组索引前加上 <code>(r)</code>（表示反向），它会尝试找到一个匹配的元素并返回它，否则返回一个空字符串。这里有一种方法可以做到这一点（但先不要添加这个，请看下一段）：</p>
<pre><code>  for dir in ~/bin ~/progs/bin; do
    if [[ -z ${path[(r)$dir]} ]]; then
      path=($dir $path)
    fi 
  done
</code></pre>
<p>那个 <code>for</code>... <code>do</code> ... <code>done</code> 是另一个特殊的 shell 结构。它会依次取 <code>in</code> 后面的每个东西，并将其赋给 <code>in</code> 前面命名的参数——<code>$dir</code>，但因为这是一种赋值形式，所以 <code>$</code> 被省略了——所以第一次循环时它的效果是 <code>dir=~/bin</code>，下一次是 <code>dir=~/progs/bin</code>。然后它执行循环中的内容。测试 <code>-z</code> 检查后面的东西是否为空：在这种情况下，如果目录 <code>$dir</code> 尚未在 <code>$path</code> 中，它将为空，所以它会继续在前面添加它。请注意，目录的添加顺序与它们出现的顺序相反。</p>
<p>然而，实际上，zsh 为你省去了所有这些麻烦。咒语 <code>typeset -U path</code>，其中 <code>-U</code> 代表唯一，告诉 shell 如果 <code>$path</code> 中已经有了某个东西，就不应该再添加它。准确地说，它只保留最左边的出现，所以如果你在末尾添加了某个东西，它会消失，如果你在开头添加了某个东西，旧的那个会消失。因此，以下内容在 <code>.zshenv</code> 中工作得很好：</p>
<pre><code>  typeset -U path
  path=(~/bin ~/progs/bin $path)
</code></pre>
<p>你可以把那个 <code>for</code> 的东西当作 shell 编程的一课。你可以通过输入 <code>typeset +U</code> 来列出所有开启了唯一性的变量，用 <code>+</code> 代替 <code>-</code>，因为在后一种情况下，shell 也会显示参数的值，而这不是你这里需要的。<code>-U</code> 标志也适用于冒号分隔的数组，比如 <code>$PATH</code>。</p>
<p>[]{#l25}</p>
<h3 id="2512-邮件"><a class="header" href="#2512-邮件">2.5.12: 邮件</a></h3>
<p>Zsh 会为你检查新邮件。如果你只需要时不时地被提醒一下你的普通文件夹里有新东西，你只需要将参数 <code>$MAIL</code> 设置为那个位置：它通常是 <code>/usr/spool/mail</code>、<code>/var/spool/mail</code> 或 <code>/var/mail</code> 之一。</p>
<p>数组 <code>$mailpath</code> 提供了更多的可能性。像 <code>$path</code> 一样，它有一个大写的同事 <code>$MAILPATH</code>，这是一个冒号分隔的数组。这次系统不需要那个，所以它主要在那里以便你可以将它导出到另一个版本的 zsh；导出数组是行不通的。现在可能已经痛苦地清楚了，如果你在 <code>.zshenv</code> 或</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide02.html">上一章</a></li>
<li><a href="zshguide04.html">下一章</a></li>
</ul>
<hr />
<p>[]{#syntax}[]{#l29}</p>
<h1 id="第三章处理基本-shell-语法-1"><a class="header" href="#第三章处理基本-shell-语法-1">第三章：处理基本 shell 语法</a></h1>
<p>本章是对<a href="zshguide02.html#init">第二章</a>中出现的大部分内容的更深入的审视；更具体地说，我假设你正坐在你的终端前，准备使用你刚刚在初始化文件中设置的功能，并想知道足够多的知识来让它们运行起来。实际上，你可能会花大部分时间编辑命令行，特别是补全命令——这两个活动都将在后面的章节中介绍。现在我将讨论命令以及使用它们所伴随的语法。这将让你能够编写 shell 函数和脚本来为你做更多的工作。</p>
<p>在下文中，经常会有几个连续的段落是关于相当次要的功能的。如果你发现你第一次就通读了所有内容，也许你需要多出去走走。大多数人可能会发现，最好是粗略地浏览一下以了解主题是什么，然后在以后发现他们想更多地了解 shell 命令和语法的某个特定方面时再回来。</p>
<p>语法的一个方面留给了<a href="zshguide05.html#subst">第五章</a>：它的内容太多了，如果你知道得足够多以正确使用它，它会非常有用，以至于不能全部塞在这里。主题是展开，涵盖了诸如参数展开、通配符匹配和历史展开等多种内容。你已经在<a href="zshguide02.html#init">第二章</a>中遇到了这些的基础知识；但如果你想知道如何用通配符表达式精确地挑选一个特定的文件，或者如何让一个单一的参数展开将一个长表达式简化为你需要的单词，你应该阅读那一章；它或多或少是独立的，所以你不必知道本章的所有内容。</p>
<p>我们从任何命令行解释器中最基本的问题开始，即运行命令。如你所知，你只需输入用空格分隔的单词，其中第一个单词是命令，其余的是它的参数。区分命令的类型很重要。</p>
<p>[]{#l30}</p>
<h2 id="31-外部命令-1"><a class="header" href="#31-外部命令-1">3.1: 外部命令</a></h2>
<p>外部命令是最简单的，因为它们与 shell 的交互最少——shell 本身提供的许多命令，将在下一节中描述，被内置到 shell 中正是为了避免这种困难。</p>
<p>因此，唯一的主要问题是如何找到它们。这是通过参数 <code>$path</code> 和 <code>$PATH</code> 来完成的，正如我在<a href="zshguide02.html#init">第二章</a>中描述的，它们是绑在一起的，因为虽然前者在 shell 内部更有用——作为一个数组，它的各个部分可以被分开操作——但后者是 shell 调用的其他命令使用的；用行话来说，<code>$PATH</code> 被“导出到环境中”，这正意味着 shell 调用的其他命令可以看到它的值。</p>
<p>所以假设你的 <code>$path</code> 包含</p>
<pre><code>  /home/pws/bin /usr/local/bin /bin /usr/bin
</code></pre>
<p>然后你尝试运行 <code>ls</code>。shell 首先在 <code>/home/pws/bin</code> 中寻找一个名为 <code>ls</code> 的命令，然后在 <code>/usr/local/bin</code> 中，然后在 <code>/bin</code> 中，它在那里找到了，所以它执行 <code>/bin/ls</code>。实际上，如果你以正确的方式执行一个命令，操作系统本身也知道路径，所以 shell 严格来说并不需要这样做。</p>
<p>这里有一个微妙之处。shell 会尝试记住命令在哪里，以便下次能再次找到它们。它把它们保存在一个所谓的“哈希表”中，你会在文档中到处看到“hash”这个词：它只意味着一种快速找到某个值的方法，给定一个特定的键。在这种情况下，给定一个命令的名称，shell 可以快速找到它的路径。你可以通过输入 <code>hash</code> 来看到这个表，形式为 <code>*key*</code>=<code>*value*</code>。</p>
<p>事实上，只有当 <code>HASH_CMDS</code> 选项被设置时，shell 才会这样做，默认情况下是设置的。正如你可能预期的，当它找到包含它正在寻找的命令的目录时，它会停止搜索。<code>HASH_ALL</code> 选项中还有一个额外的优化，默认也是设置的：当 shell 扫描一个目录以寻找一个命令时，它会将该目录中的所有其他命令添加到哈希表中。这是合理的，因为在大多数类 UNIX 操作系统上，读取同一目录中的一大堆文件是相当快的。</p>
<p>命令的存储方式还有其他后果。特别是，如果 zsh 已经知道在哪里找到一个命令，它就不会去寻找一个新的命令。如果在上面的例子中，我在 <code>/usr/local/bin</code> 中放了一个新的 <code>ls</code> 命令，zsh 将继续使用 <code>/bin/ls</code>（假设它已经被找到了）。要解决这个问题，有一个 <code>rehash</code> 命令，它实际上会清空命令哈希表，这样寻找命令就会从头开始。csh 的用户可能记得在使用新命令时需要经常输入 <code>rehash</code>：在 zsh 中情况没那么糟，因为如果没有命令已经被哈希，或者现有的命令消失了，zsh 会自动再次扫描路径；此外，如果 <code>$path</code> 被改变，zsh 会自行执行一次 <code>rehash</code>。所以，在 <code>$path</code> 的头部某处添加一个新的重复命令是需要 <code>rehash</code> 的主要原因。</p>
<p>如果 zsh 没有填满它的命令哈希表，因此不知道所有的外部命令，可能会发生一件事，那就是 <code>AUTO_CD</code> 选项，在上一章提到过，下面还会再次提到，可能会认为你正在尝试切换到一个与命令同名的特定目录。这是 <code>AUTO_CD</code> 的缺点之一。</p>
<p>说得更技术化一点，实际上命令哈希是否需要并不那么明显；许多现代操作系统可以在没有它的情况下快速找到命令。在 zsh 的情况下，关键在于同一个哈希表对于命令补全也是必需的，这是一个非常常用的功能。如果你输入 <code>compr&lt;TAB&gt;</code>，shell 会将其补全为 <code>compress</code>。只有当它有一个要补全的命令列表时，它才能这样做，而这个列表就是哈希表。（在这种情况下，它不需要知道在哪里找到命令，只需要它的名字，但多存储一点东西也只是多一点工作而已。）如果你关注了前面的段落，你会意识到 zsh 在你按 <code>TAB</code> 的时候不一定知道<em>所有</em>可能的命令，因为它只在需要的时候才去查找。为此，有另一个选项，<code>HASH_LIST_ALL</code>，默认也是设置的，它会确保在你尝试补全一个命令时命令哈希表是满的。它只需要这样做一次（除非你改变 <code>$path</code>），但这确实意味着第一次命令补全会很慢。如果 <code>HASH_LIST_ALL</code> 没有设置，命令补全就不可用：shell 可以被重写为每次你尝试补全一个命令名时都费力地搜索路径，但这似乎不值得。</p>
<p><code>$PATH</code> 从 shell 传递给从它调用的命令（严格来说只有当变量被标记为导出时，通常是这样——这在下面用 <code>typeset</code> 系列内建命令更详细地描述）这一事实也有后果。一些命令使用 <code>$PATH</code> 调用它们自己的子命令。如果你把它设置成一些不寻常的东西，以至于一些标准命令找不到，可能会发生一个<em>被找到</em>的命令仍然不能正常运行，因为它在传递给它的路径中找不到它正在寻找的东西。这可能导致一些奇怪和令人困惑的错误消息。</p>
<p>关于外部命令，要记住的一件重要事情是，当它们运行时，shell 继续存在；它只是闲着什么也不做，等待作业完成（尽管你可以告诉它不要等，我们稍后会看到）。命令被给予一个全新的环境来运行；那里的变化不会影响 shell，它只是在命令运行后从它离开的地方重新开始。所以如果你需要做一些改变 shell 状态的事情，一个外部命令是不够的。这就引出了内建命令。</p>
<p>[]{#l31}</p>
<h2 id="32-内建命令-1"><a class="header" href="#32-内建命令-1">3.2: 内建命令</a></h2>
<p>内建命令，或简称内建，是 shell 本身的一部分的命令。由于内建对于控制 shell 自身的行为是必需的，介绍它们实际上也作为对 shell 中正在发生的大部分事情的介绍。所以，本应出现在本章后面的相当一部分内容，以某种方式在这里累积起来了。这确实使事情在某些地方有点棘手；数数我用了多少次“微妙”的词，然后留给你的孙子孙女看。</p>
<p>我刚刚描述了内建的一个原因，但还有一个更简单的原因：速度。如果你只想在屏幕上打印一条消息，那么经历在开始时为命令设置一个全新的环境，在这个命令和计算机上正在运行的任何其他东西之间切换，然后在结束时再次销毁它的整个过程，是相当过度的。所以有用于这类事情的内建。</p>
<p>[]{#l32}</p>
<h3 id="321-用于打印的内建命令"><a class="header" href="#321-用于打印的内建命令">3.2.1: 用于打印的内建命令</a></h3>
<p>命令 <code>echo</code> 和 <code>print</code> 是 shell 内建；它们只是显示你输入的内容，在 shell 移除了所有引用之后。两者之间的区别实际上是历史性的：<code>echo</code> 先出现，只处理一些简单的选项；ksh 提供了 <code>print</code>，它有更复杂的选项，因此成了一个不同的命令。zsh 中的这两个命令之间的区别仍然存在；如果你想要古怪的效果，你应该看看 <code>print</code>。请注意，通常还有一个名为 <code>echo</code> 的外部命令，它可能与 zsh 的不完全相同；没有标准的名为 <code>print</code> 的外部命令，但如果有人在你的系统上安装了一个，它很可能是把东西发送到打印机，而不是屏幕。</p>
<p>一个特殊效果是 <code>print -z</code> 将参数放到编辑缓冲区堆栈上，这是 shell 维护的一个你将要编辑的东西的列表。试试：</p>
<pre><code>  print -z print -z print 这是一个行
</code></pre>
<p>（看起来好像有什么需要引用的，但实际上不需要）然后按三次 return。第一次导致第一个 <code>print -z</code> 之后的所有内容出现让你编辑，依此类推。</p>
<p>对于更有用的东西，你可以编写函数来给你一行来编辑：</p>
<pre><code>  fn() { print -z print 现在的时间是 $(date); }
</code></pre>
<p>现在当你输入 <code>fn</code> 时，带有日期的那一行会出现在命令行上让你编辑。选项 <code>-s</code> 有点类似；该行出现在历史列表中，所以如果你使用向上箭头，你会看到它，但它不会自动重新出现。</p>
<p>一些其他有用的选项，其中一些你已经见过，是</p>
<p><strong><code>-r</code></strong>
:   不解释像 <code>\n</code> 这样的特殊字符序列</p>
<p><strong><code>-P</code></strong>
:   像在提示符中一样使用 <code>%</code></p>
<p><strong><code>-n</code></strong>
:   在末尾不加换行符，以防后面还有输出</p>
<p><strong><code>-c</code></strong>
:   以列的形式打印输出——这意味着 <code>print -c *</code> 的效果有点像一个穷人版的 <code>ls</code>，只是更快</p>
<p><strong><code>-l</code></strong>
:   每个参数占一行而不是一列，这有时对于将列表放入文件，以及计算数组参数的每个元素中有什么很有用。</p>
<p>如果你不使用 <code>-r</code> 选项，有一大堆特殊字符序列。其中许多你可能从 C 语言中很熟悉。</p>
<p><strong><code>\n</code></strong>
:   换行</p>
<p><strong><code>\t</code></strong>
:   制表符</p>
<p><strong><code>\e</code> 或 <code>\E</code></strong>
:   转义字符</p>
<p><strong><code>\a</code></strong>
:   响铃（警报），通常是可怕的哔哔声的委婉说法</p>
<p><strong><code>\b</code></strong>
:   后退一个字符。</p>
<p><strong><code>\c</code></strong>
:   不打印换行符——像 <code>-n</code> 选项，但嵌入在字符串中。这个替代方案来自伯克利 UNIX。</p>
<p><strong><code>\f</code></strong>
:   换页，从终端被称为电传打字机的时代开始，表示“前进到下一页”的短语，你可能更熟悉的是 <code>^L</code></p>
<p><strong><code>\r</code></strong>
:   回车——打印时，是你在 DOS 文件中得到的烦人的 <code>^M</code>，但实际上与 <code>print</code> 一起使用相当有用，因为它会擦除到行首的所有内容。<code>-n</code> 选项和打印字符串开头的 <code>\r</code> 的组合可以给人一种连续变化的状态行的错觉。</p>
<p><strong><code>\v</code></strong>
:   垂直制表符，我个人从未使用过（我刚才试了一下，它的行为像换行符，只是没有假设回车，但这取决于你的终端）。</p>
<p>实际上，你可以得到所有 255 个可能的字符，尽管你的终端可能不喜欢 127 以上的某些或所有字符，方法是在反斜杠后指定一个数字。通常这由三个八进制字符组成，但你也可以在 <code>\x</code> 后使用两个十六进制字符——所以 <code>\n</code>、<code>\012</code> 和 <code>\x0a</code> 都是换行符。<code>\</code> 本身会转义任何其他字符，即它们会以自身的形式出现，即使它们通常不会。</p>
<p>两点说明：首先，不要因为 <code>n</code> 是字母表的第十四个字母而感到困惑；打印 <code>\016</code>（八进制的十四）对你没有任何好处。补救措施是，在你发现你的文本不可读之后（对于像 xterm 这样的 VT100 类终端），打印 <code>\017</code>。</p>
<p>其次，那些反斜杠会让你陷入真正的引用困境。通常命令行上的反斜杠会转义下一个字符——这是与 <code>print</code> 的转义<em>不同</em>的形式——所以</p>
<pre><code>  print \n
</code></pre>
<p>不会产生换行符，它只是打印出一个 <code>n</code>。所以你需要引用它。这意味着</p>
<pre><code>  print \\n
</code></pre>
<p>传递一个反斜杠给引用，以及</p>
<pre><code>  print \\n
</code></pre>
<p>或</p>
<pre><code>  print '\n'
</code></pre>
<p>打印一个换行符（后面跟着通常会有的那个额外的换行符）。因此，要打印一个真正的反斜杠，你需要</p>
<pre><code>  print \\\
</code></pre>
<p>实际上，如果后面没有其他东西，你可以用两个——<code>print</code> 只是耸耸肩，输出它被给予的东西——但这不是一个好习惯。还有其他方法可以做到这一点：因为单引号引用任何东西，包括反斜杠（它们是使反斜杠表现得像普通字符的唯一方法），并且因为 <code>-r</code> 选项使 print 正常处理字符，</p>
<pre><code>  print -r '\'
</code></pre>
<p>有同样的效果。但你需要记住反斜杠的两级引用。引号对 <code>print</code> 来说不是特殊的，所以</p>
<pre><code>  print '
</code></pre>
<p>对于打印一个引号来说已经足够了。</p>
<p><strong><code>echotc</code></strong>\</p>
<p>有一个叫做 <code>echotc</code> 的怪东西，它以 <code>termcap</code> 功能作为其参数。它现在存在于自己的模块 <code>zsh/termcap</code> 中。</p>
<p>Termcap 是一种现在相当老式的方式，用于给出在终端上执行各种标准操作所需的命令：移动光标、清除到行尾、打开突出显示模式等等。它现在几乎在所有地方都被 <code>terminfo</code> 取代了，这是一种完全不同的指定功能的方式，以及 <code>curses</code>，一个更高级的用于在字符终端上操作对象的系统。这意味着你需要给 <code>echotc</code> 的参数可能相当难找；试试 <code>termcap</code> 手册页；如果有两个，可能是第五节中的那个给出了代码，即 <code>man 5 zsh</code> 或在 Solaris 上的 <code>man -s 5 zsh</code>。否则你就得在网上搜索了。<code>zsh</code> 手册没有给出列表的原因是，shell 只使用少数几个众所周知的序列，还有很多其他的序列可以与 <code>echotc</code> 一起工作，因为这些序列是由终端解释的，而不是 shell。</p>
<p>这段代码给你一个感觉：</p>
<pre><code>  zmodload -i zsh/termcap
  echotc md
  echo -n bold
  echotc mr
  echo -n reverse
  echotc me
  echo
</code></pre>
<p>首先我们确保模块被加载到 shell 中；在一些旧的操作系统上，这只有在 zsh 安装时被编译进去才行。<code>zmodload</code> 的 <code>-i</code> 选项阻止 shell 在模块已经加载时抱怨。这是在 shell 函数中确保你有正确设施可用的明智方法，因为加载一个模块会使其可用，直到它被明确卸载。</p>
<p>你应该看到 <code>bold</code> 是粗体字符，<code>reverse</code> 是粗体反白视频。<code>md</code> 功能打开粗体模式；<code>mr</code> 打开反白视频；<code>me</code> 关闭两种模式。一个更典型的 zsh 做法是：</p>
<pre><code>  print -P '%Bbold%Sreverse%b%s'
</code></pre>
<p>这应该显示同样的东西，但使用提示符转义——提示符是特殊字体的最常见用途。<code>%S</code> 是因为 zsh 称反白为“突出显示”模式，因为它就是这样。（在彩色 xterm 上，你可能会发现“粗体”被解释为“蓝色”。）</p>
<p>如果你真的尝试，你可以用 <code>echotc</code> 做更多的事情。shell 刚刚获得了一种打印 terminfo 序列的方法，可预见地称为 <code>echoti</code>，尽管它只在 zsh 需要 terminfo 来编译的系统上可用——这发生在 termcap 代码实际上是 terminfo 的一部分时。关于这个的好消息是，terminfo 往往有更好的文档，所以你很有可能从 <code>terminfo</code> 手册页中找到你想要的功能。<code>echoti</code> 命令存在于另一个可预见地命名的模块 <code>zsh/terminfo</code> 中。</p>
<p>[]{#l33}</p>
<h3 id="322-其他仅为速度而设的内建命令"><a class="header" href="#322-其他仅为速度而设的内建命令">3.2.2: 其他仅为速度而设的内建命令</a></h3>
<p>只有少数其他内建命令只是为了让事情变得更快。严格来说，测试可以归入这一类，但正如我在上一章中解释的，以以下形式进行测试是很有用的</p>
<pre><code>  if [[ $var1 = $var2 ]]; then
    print doing something
  fi
</code></pre>
<p>被 shell 视为一种特殊语法，以防 <code>$var1</code> 或 <code>$var2</code> 扩展为空，否则会使其混淆。这个例子包含了下面描述的两个特性：测试本身，在双方括号之间，如果两个替换后的值是相同的字符串，则为真；以及 <code>if</code> 结构，如果该测试为真，则运行中间的命令（这里只是 <code>print</code>）。</p>
<p>内建命令 <code>true</code> 和 <code>false</code> 什么也不做，除了分别返回命令状态零或一。它们只是用作占位符：要永远运行一个循环——<code>while</code> 稍后也会更详细地解释——你使用</p>
<pre><code>  while true; do
    print doing something over and over
  done
</code></pre>
<p>因为测试总是成功。</p>
<p><code>true</code> 的一个同义词是 <code>;</code>；它经常以这种形式用于给出有副作用但又不应该被使用的参数——有点像</p>
<pre><code>  : ${param:=value}
</code></pre>
<p>这是所有 Bourne shell 衍生物中的一个常见用法。在参数扩展中，如果 <code>$param</code> 之前是空的，它会被赋予 <code>value</code> 的值，否则保持不变。因为那是参数扩展的唯一原因，你使用 <code>:</code> 来忽略参数。实际上，shell 愉快地构建命令行——冒号，后面跟着 <code>$param</code> 的任何值，无论赋值是否发生——然后执行命令；只是恰好 <code>;</code> 不理会它被给予的参数。如果你是从 ksh 转换过来的，你可能会期望某些像这样的同义词是别名，而不是内建命令本身，但在 zsh 中它们实际上是内建命令；shell 没有预定义任何别名。（你仍然可以使用 <code>disable</code> 来摆脱它们，如下所述。）</p>
<p>[]{#l34}</p>
<h3 id="323-改变-shell-状态的内建命令"><a class="header" href="#323-改变-shell-状态的内建命令">3.2.3: 改变 shell 状态的内建命令</a></h3>
<p>内建命令更常见的用途是它们改变 shell 内部的某些东西，或者报告 shell 中正在发生的事情的信息。关于外部命令，有一件至关重要的事情要记住。它也适用于我们将会遇到的其他情况，即 shell “分叉”（fork），字面上是把自己分成两部分，其中分叉出来的部分行为就像一个外部命令。在这两种情况下，命令都在一个不同的<em>进程</em>中，这是 UNIX 运行事物的基本单位。（事实上，即使是 Windows 现在也知道进程，尽管它们之间的交互方式略有不同。）</p>
<p>至关重要的事情是，由 shell 启动的独立进程中的任何更改都不会影响 shell 本身。最常见的情况是当前目录——每个进程都有自己的当前目录。你可以通过启动一个新的 zsh 来看到这一点：</p>
<pre><code>  % pwd               # 显示当前目录
  ~
  % zsh               # 启动一个新 shell，它
                      # 是一个独立的进程
  % cd tmp
  % pwd               # 现在我在一个不同的
                      # 目录...
  ~/tmp
  % exit              # 离开新 shell...
  % pwd               # 现在我回到了我原来的地方...
  ~
</code></pre>
<p>因此 <code>cd</code> 命令必须是一个 shell 内建，否则每次运行它都会发生这种情况。</p>
<p>这里有一个更有用的例子。将命令放在括号中会要求 shell 为它启动一个不同的进程。当你特别<em>不</em>希望效果传播回来时，这很有用：</p>
<pre><code>  (cd some-other-dir; run-some-command)
</code></pre>
<p>运行该命令，但不会改变“真实” shell 所在的目录，只改变其分叉出来的“子 shell”。因此，</p>
<pre><code>  % pwd
  ~
  % (cd /; pwd)
  /
  % pwd
  ~
</code></pre>
<p>还有一个更微妙的情况：</p>
<pre><code>  cd some-other-dir | print Hello
</code></pre>
<p>记住，<code>|</code>（“管道”）将第一个命令的输出连接到下一个命令的输入——尽管实际上在这个例子中没有信息以这种方式传递。在 zsh 中，除了管道的最后一部分之外，所有部分都在不同的进程中运行。因此 <code>cd</code> 不会影响主 shell。我将称之为主 shell，这是 UNIX 对进程的标准语言；当你启动另一个命令或分叉一个子 shell 时，你正在创建“子进程”（无意冒犯，在这种情况下，子进程通常先死）。因此，正如你所猜测的，</p>
<pre><code>  print Hello | cd some-other-dir
</code></pre>
<p><em>确实</em>有改变目录的效果。请注意，其他 shell 的做法不同；在 zsh 中总是保证这样工作，因为许多人依赖它来设置参数，但许多 shell 的管道的<em>左侧</em>是在父 shell 中运行的部分。如果管道符号的两侧都是某种外部命令，那么两者当然都会在子进程中运行。</p>
<p>还有其他改变 shell 状态的方法，例如通过声明特定类型的参数，或者通过告诉它如何解释某些命令，或者，当然，通过改变选项。这里是最有用的，以一种模糊的逻辑方式分组。</p>
<p>[]{#l35}</p>
<h3 id="324-cd-和它的朋友们"><a class="header" href="#324-cd-和它的朋友们">3.2.4: cd 和它的朋友们</a></h3>
<p>你现在不会惊讶地知道 <code>cd</code> 命令会改变目录。有一个同义词，<code>chdir</code>，据我所知，从来没有人用过。（它与系统调用的名称相同，所以如果你一直在用 C 或 Perl 编程，然后忘了你现在正在使用 shell，你可能会用 <code>chdir</code>。但这似乎有点牵强。）</p>
<p><code>cd</code> 和 <code>chdir</code> 中内置了各种额外的功能。首先，如果你省略了要切换到的目录，你将被带到你的主目录，尽管 <code>cd ~</code> 并不难输入。</p>
<p>其次，命令 <code>cd -</code> 是特殊的：它会带你到你上一个所在的目录。如果你执行一系列 <code>cd</code> 命令，只有紧邻的前一个目录会被记住；它们不会被堆叠起来。</p>
<p>第三，有一个在相似名称的目录之间切换的快捷方式。如果你输入 <code>cd &lt;old&gt; &lt;new&gt;</code>，那么 shell 会在当前目录中寻找字符串 <code>&lt;old&gt;</code> 的第一次出现，并尝试用 <code>&lt;new&gt;</code> 替换它。例如，</p>
<pre><code>  % pwd
  ~/src/zsh-3.0.8/Src
  % cd 0.8 1.9
  ~/src/zsh-3.1.9/Src
</code></pre>
<p><code>cd</code> 命令实际上报告了新目录，就像它通常在不完全清楚它带你去了哪里时所做的那样。</p>
<p>请注意，只取 <code>&lt;old&gt;</code> 的<em>第一次</em>匹配。认为你可以用 <code>cd 1 2</code> 从 <code>/home/export1/pws/mydir1/something</code> 切换到 <code>/home/export1/pws/mydir2/something</code> 是一个容易犯的错误，但第一个 <code>1</code> 把它搞砸了。可以说 shell 在这里可以更聪明一些。当然，在这种情况下 <code>cd r1 r2</code> 会起作用。</p>
<p><code>cd</code> 的朋友 <code>pwd</code>（打印工作目录）告诉你当前的工作目录是什么；这个信息在 shell 参数 <code>$PWD</code> 中也可用，它是特殊的，当目录改变时会自动更新。稍后，当你了解了所有关于展开的知识后，你会发现你可以用它来玩一些花样来引用其他目录。例如，<code>${PWD/old/new}</code> 使用参数替换机制来引用一个不同的目录，其中 <code>old</code> 被 <code>new</code> 替换——而这一次 <code>old</code> 可以是一个模式，即包含通配符匹配的东西。所以如果你在上面的 <code>zsh-3.0.8/Src</code> 目录中，想从 <code>zsh-3.1.9/Src</code> 目录复制一个文件，你有一个简写：</p>
<pre><code>  cp ${PWD/0.8/1.9}/myfile.c .
</code></pre>
<p><strong>符号链接</strong>\</p>
<p>Zsh 尝试跨符号链接跟踪目录。如果你不熟悉这些，你可以把它们想象成一个行为像指向另一个文件的指针的文件名（有点像 Windows 的快捷方式，尽管 UNIX 拥有它们的时间要长得多，而且它们工作得更好）。你可以这样创建它们（<code>ln</code> 不是一个内建命令，但它用来创建符号链接的用法如今非常标准）：</p>
<pre><code>  ln -s existing-file-name name-of-link
</code></pre>
<p>例如</p>
<pre><code>  ln -s /usr/bin/ln ln
</code></pre>
<p>在当前目录中创建一个名为 <code>ln</code> 的文件，它除了指向文件 <code>/usr/bin/ln</code> 之外什么也不做。符号链接在表现得像原始文件方面非常出色，就像你通常希望的那样；例如，你可以运行你刚刚创建的 <code>ln</code> 链接，就好像它是 <code>/usr/bin/ln</code> 一样。它们在用 <code>ls -l</code> 进行长文件列表时显示得不同，最后一列显示它们指向的文件。</p>
<p>你可以让它们指向任何类型的文件，包括目录，这就是为什么在这里提到它们。假设你从你的主目录创建了一个到根目录的符号链接，并切换到它：</p>
<pre><code>  ln -s / ~/mylink
  cd ~/mylink
</code></pre>
<p>如果你不知道它是一个链接，你会期望能够通过执行 <code>cd ..</code> 来切换到父目录。然而，操作系统——它只有一套从 <code>/</code> 开始向下的目录，并且在跟随符号链接后会忽略它们，它们真的只是指针——认为你在根目录 <code>/</code>。这可能会令人困惑。因此，zsh 试图跟踪<em>你</em>可能认为你在哪里，而不是系统认为你在哪里。如果你输入 <code>pwd</code>，你会看到 <code>/home/you/mylink</code>（无论你的主目录在哪里），而不是 <code>/</code>；如果你输入 <code>cd ..</code>，你会发现自己回到了你的主目录。</p>
<p>你可以通过设置 <code>CHASE_LINKS</code> 选项来关闭所有这些猜测；然后 <code>cd ~/mydir; pwd</code> 会显示你在 <code>/</code>，在那里切换到父目录没有效果；根目录的父目录是根目录，除非在某些稍微迷幻的网络文件系统上。这确实有优点：例如，<code>cd ~/mydir; ls ..</code> 总是列出根目录，而不是你的主目录，无论选项设置如何，因为 <code>ls</code> 不知道你跟随的链接，只有 zsh 知道，它将 <code>..</code> 视为引用根目录。设置 <code>CHASE_LINKS</code> 允许 <code>pwd</code> 警告你系统认为你在哪里。</p>
<p>给非 UNIX 专家的旁注（据上次统计，占世界人口的 99.9% 以上）：我说“符号链接”而不是仅仅“链接”，因为还有其他叫做“硬链接”的。这就是如果你不使用 <code>-s</code> 选项时 <code>ln</code> 创建的。硬链接与其说是一个指向文件的指针，不如说是文件的一个替代名称。如果你这样做</p>
<pre><code>  ln myfile othername
  ls -l
</code></pre>
<p>其中 <code>myfile</code> 已经存在，你无法分辨 <code>myfile</code> 和 <code>othername</code> 哪个是原始的——事实上，系统也不在乎。你可以删除任何一个，另一个作为文件的名称会完全没问题。这几乎就是重命名文件的工作方式，只是在这种情况下，创建硬链接是为你完成的。硬链接有限制——你不能链接到目录，或者链接到另一个磁盘分区上的文件（如果你不知道什么是磁盘分区，你会看到那会是多大的限制）。此外，你通常想知道哪个是原始的，哪个是链接——所以对于大多数用户来说，创建符号链接更有用。唯一的缺点是跟随指针会慢一点点；如果你认为你能注意到区别，你肯定应该慢下来一点。</p>
<p>符号链接的目标，与硬链接不同，实际上不必存在，并且在尝试使用链接之前不会执行任何检查。最好的做法是在创建链接时运行 <code>ls -lL</code>；<code>-L</code> 部分告诉 <code>ls</code> 跟随链接，如果它工作了，你应该看到你的链接显示为与它指向的文件具有完全相同的特性。如果它仍然显示为链接，则没有这样的文件。</p>
<p>关于符号链接，我应该指出一个轻微的怪癖：被链接的文件名（第一个名字），如果它不是一个绝对路径（在任何 <code>~</code> 扩展后以 <code>/</code> 开头），则被视为相对于链接创建的目录——而不是你运行 <code>ln</code> 时的当前目录。这里：</p>
<pre><code>  ln -s ../mydir ~/links/otherdir
</code></pre>
<p>链接 <code>otherdir</code> 将引用<em>其自身</em>父目录中的 <code>mydir</code>，即 <code>~/links</code>——而不是，你可能认为的，你运行命令时所在的目录的父目录。更糟糕的是，第二个词，如果不是绝对路径，<em>是</em>相对于你运行命令的目录来解释的。</p>
<p><strong>$cdpath 和 AUTO_CD</strong>\</p>
<p>我们离用目录做的魔法还差得远呢（而且，事实上，我甚至还没讲到 zsh 特有的部分）。下一个技巧是 <code>$cdpath</code> 和 <code>$CDPATH</code>。它们看起来很像你在上一章遇到的 <code>$path</code> 和 <code>$PATH</code>，我在上一章的那个上下文中简要地提到了它们：<code>$cdpath</code> 是一个目录数组，而 <code>$CDPATH</code> 是一个冒号分隔的列表，行为上像一个标量变量。它们给出了一个目录列表，你可能想切换到它们的子目录。如果你使用一个普通的 cd 命令（即形式为 <code>cd *dirname*</code>，并且 <em>dirname</em> 不以 <code>/</code> 或 <code>~</code> 开头），shell 会在 <code>$cdpath</code> 的目录中查找，以找到一个包含子目录 <em>dirname</em> 的目录。如果 <code>$cdpath</code> 没有设置，如你所料，它只使用当前目录。</p>
<p>请注意，<code>$cdpath</code> 总是按顺序搜索，你可以在其中放一个 <code>.</code> 来代表当前目录。如果你这样做，当前目录将总是在<em>那个点</em>被搜索，不一定是第一个，这可能不是你所期望的。例如，让我们设置一些目录：</p>
<pre><code>  mkdir ~/crick ~/crick/dna
  mkdir ~/watson ~/watson/dna
  cdpath=(~/crick .)
  cd ~/watson
  cd dna
</code></pre>
<p>所以我已经移动到目录 <code>~/watson</code>，它包含子目录 <code>dna</code>，并执行了 <code>cd dna</code>。但由于 <code>$cdpath</code>，shell 会首先在 <code>~/crick</code> 中查找，并在那里找到 <code>dna</code>，然后带你到那个自我复制目录的副本，而不是 <code>~/watson</code> 中的那个。大多数人因此在他们的 <code>cdpath</code> 的开头都有 <code>.</code>。然而，至少 <code>cd</code> 会警告你——如果你试过，你会看到它在这种情况下会打印出它选择的目录的名称。</p>
<p>事实上，如果你的目录中根本没有 <code>.</code>，shell 总是会先在那里查找；没有办法让 <code>cd</code> 永远不切换到当前目录的子目录，除非把 <code>cd</code> 变成一个函数。有些 shell 不这样做；它们使用 <code>$cdpath</code> 中的目录，而且只使用那些。</p>
<p>还有一个更简便的方法，这是 zsh 特有的：我在上一章提到的 <code>AUTO_CD</code> 选项。那样，一个没有任何参数的命令，如果它实际上是一个目录，就会带你到那个目录。通常这是完美的——否则你只会得到一个“命令未找到”的消息，你还不如利用这个选项。然而，偶尔，一个目录的名称会与一个命令、内建命令或外部命令，或一个 shell 函数的名称冲突，然后可能会有一些混淆：只要 zsh 知道它，它总是会选择命令，但有些情况下它不知道，正如我上面描述的。</p>
<p>我在上一章没有说的是，<code>AUTO_CD</code> 尊重 <code>$cdpath</code>；事实上，它的实现方式是让 <code>*dirname*</code> 本身的行为尽可能地像 <code>cd *dirname*</code>，而不会把 shell 的内部搞得一团糟。</p>
<p><strong>目录栈</strong>\</p>
<p>Zsh 从 C-shell 家族继承的一个非常有用的功能是目录栈（传统的 Korn shell 没有这个功能）。这是你最近访问过的目录的列表。如果你使用 <code>pushd</code> 命令而不是 <code>cd</code>，例如 <code>pushd *dirname*</code>，那么你所在的目录会被保存在这个列表中，然后你会被带到 <em>dirname</em>，使用 <code>$CDPATH</code> 就像 <code>cd</code> 一样。然后当你输入 <code>popd</code> 时，你会被带回到你原来的地方。这个列表可以任意长；你可以 <code>pushd</code> 任意数量的目录，每个 <code>popd</code> 都会带你回到列表中的前一个（这就是“栈”，或者更准确地说，是“后进先出”栈在计算机行话中通常的操作方式，因此得名“目录栈”）。</p>
<p>你可以用 <code>dirs</code> 命令看到这个列表——它总是以当前目录开始。所以，例如：</p>
<pre><code>  cd ~
  pushd ~/src
  pushd ~/zsh
  dirs
</code></pre>
<p>显示</p>
<pre><code>  ~/zsh ~/src ~
</code></pre>
<p>下一个 <code>popd</code> 会带你回到 <code>~/src</code>。如果你这样做，你会看到 <code>pushd</code> 在进行时会自动报告 <code>dirs</code> 给出的列表；你可以用 <code>PUSHD_SILENT</code> 选项关闭这个功能，那时你就必须依赖明确输入 <code>dirs</code> 了。</p>
<p>实际上，这个功能的很多用途并非来自简单的 <code>pushd</code> 和 <code>popd</code> 组合，而是来自另外两个特性。首先，单独的 <code>pushd</code> 会交换栈顶的两个目录。其次，<code>pushd</code> 带有以 <code>+</code> 或 <code>-</code> 开头的数字参数，可以带你到列表中的其他目录之一。命令 <code>dirs -v</code> 会告诉你需要的数字；<code>0</code> 是当前目录。所以如果你得到，</p>
<pre><code>  0       ~/zsh
  1       ~/src
  2       ~
</code></pre>
<p>那么 <code>pushd +2</code> 会带你到 <code>~</code>。（这里需要一点点悬念，我没有直接用 <code>AUTO_CD</code> 然后输入 <code>..</code>。）如果你用 <code>-</code>，它会从列表的另一端开始计数；<code>-0</code>（向数学家们道歉）是最后一项，在这种情况下与 <code>~</code> 相同。有些人习惯于让 <code>-</code> 和 <code>+</code> 参数反过来工作；<code>PUSHD_MINUS</code> 选项就是为此存在的。</p>
<p>除了 <code>PUSHD_SILENT</code> 和 <code>PUSHD_MINUS</code>，还有一些其他相关的选项。设置 <code>PUSHD_IGNORE_DUPS</code> 意味着如果你 <code>pushd</code> 到一个已经在列表中的目录，重复的条目将被静默删除。这对大多数人类操作来说很有用——然而，如果你在函数或脚本中使用 <code>pushd</code> 来为将来的匹配 <code>popd</code> 记住以前的目录，这可能很危险，你可能想在函数内部局部地关闭它。</p>
<p><code>AUTO_PUSHD</code> 意味着任何改变目录的命令，包括自动 cd，都被视为一个带有目标目录作为参数的 <code>pushd</code> 命令。使用这个可能会让目录栈变得很长，有一个参数 <code>$DIRSTACKSIZE</code> 你可以设置来指定一个最大长度。当超过这个长度时，最旧的条目（<code>dirs -v</code> 列表中的最高数字）会自动被删除。除非明确设置，否则没有限制。</p>
<p>最后一个 <code>pushd</code> 选项是 <code>PUSHD_TO_HOME</code>。这使得单独的 <code>pushd</code> 行为像单独的 <code>cd</code> 一样，即它带你到你的主目录，而不是交换栈顶的两个目录。通常一系列的 <code>pushd</code> 命令的工作方式很像一系列的 <code>cd -</code> 命令，总是带你到你之前的目录，明显的区别是 <code>cd -</code> 不会查询目录栈，它只是自动记住前一个目录，因此如果你只用 <code>cd -</code>，它可能会让 <code>pushd</code> 感到困惑。</p>
<p>关于 <code>pushd</code> 还有一个最后的微妙之处，那就是当你用类似 <code>pushd +2</code> 的命令将一个特定的目录带到前面时，列表的其余部分会发生什么。通常列表只是简单地循环，所以之前是 +3 和 +4 的目录现在就在列表的新头部后面，而之前在它前面的两个目录被移到了末尾。如果之前的列表是：</p>
<pre><code>  dir1  dir2  dir3  dir4
</code></pre>
<p>那么在 <code>pushd +2</code> 之后你得到</p>
<pre><code>  dir3  dir4  dir1 dir2
</code></pre>
<p>这种行为在 zsh 的生命周期中改变了，我们中的一些人更喜欢旧的行为，即那个目录被拉到前面，其余的只是填补了空缺：</p>
<pre><code>  # 旧行为
  dir3  dir1  dir2  dir4
</code></pre>
<p>这样过了一段时间，你就会在列表的前面得到一个“热门精选”组。如果你也喜欢这种行为（我觉得我需要写过群论的论文才能喜欢新的行为），源代码中提供了一个 <code>pushd</code> 函数，尽管它足够短，可以在这里重复——这是 zsh 风格的自动加载形式：</p>
<pre><code>  # pushd 函数以模拟旧的 zsh 行为。
  # 有了它，pushd +/-n 会将选定的元素
  # 提升到栈顶，而不是循环
  # 栈。

  emulate -R zsh
  setopt localoptions

  if [[ ARGC -eq 1 &amp;&amp; "$1" == [+-]&lt;-&gt; ]] then
          setopt pushdignoredups
          builtin pushd ~$1
  else
          builtin pushd "$@"
  fi
</code></pre>
<p><code>&amp;&amp;</code> 是一个逻辑“与”，要求两个测试都为真。测试是函数只有一个参数，并且它的形式是 <code>+</code> 或 <code>-</code> 后跟任意数字（<code>&lt;-&gt;</code> 是一个特殊的 zsh 模式，用于匹配任意数字，是像 <code>&lt;1-100&gt;</code> 这样的形式的扩展，后者匹配 1 到 100 范围内的任意数字，包括两端）。</p>
<p><strong>引用其他目录</strong>\</p>
<p>Zsh 有两种方法可以让你引用特定的目录。它们的共同点是都以 <code>~</code> 开头（在非常旧的 zsh 版本中，第二种形式实际上使用了一个 <code>=</code>，但现在的方式更合乎逻辑）。</p>
<p>你肯定知道，因为我已经大量使用了，一个单独的 <code>~</code> 或后面跟着一个 <code>/</code> 指的是你自己的主目录。这个的扩展——同样来自 C-shell，尽管 Korn shell 在这种情况下也有——是 <code>~name</code> 可以引用系统上任何用户的主目录。所以如果你的用户名是 <code>pws</code>，那么 <code>~</code> 和 <code>~pws</code> 是同一个目录。</p>
<p>Zsh 对此有一个扩展；你实际上可以命名你自己的目录。这在<a href="zshguide02.html#init">第二章</a>中已经描述过了，关于提示符，因为那是主要用途：</p>
<pre><code>  host% PS1='%~? '
  ~? cd zsh/Src
  ~/zsh/Src? zsrc=$PWD
  ~/zsh/Src? echo ~zsrc
  /home/pws/zsh/Src
  ~zsrc?
</code></pre>
<p>请查阅那一章，了解强制一个参数被识别为命名目录的方法。</p>
<p>有一个稍微更复杂的方法可以直接做到这一点：</p>
<pre><code>  hash -d zsrc=~/zsh/Src
</code></pre>
<p>使得 <code>~zsrc</code> 像以前一样出现在提示符中，并且在这种情况下没有参数 <code>$zsrc</code>。这是纯粹主义者的方式（尽管很少有 zsh 用户是纯粹主义者）。你可以猜到 <code>unhash -d zsrc</code> 是做什么的；这也适用于通过参数命名的目录，但会保留参数本身。</p>
<p>可能会有一个与用户名同名的命名目录。在这种情况下，<code>~name</code> 指的是你明确命名的目录，没有简单的方法可以得到 <code>name</code> 的主目录，除非删除你定义的名称。</p>
<p>如果你正在使用命名目录和 <code>cd</code> 类的命令或 <code>AUTO_CD</code>，你可以设置 <code>CDABLEVARS</code> 选项，它允许你省略开头的 <code>~</code>；使用这个选项的 <code>cd zsrc</code> 会带你到 <code>~zsrc</code>。这个名字是一个历史遗留物，现在是一个用词不当；它实际上是命名目录，而不是参数（即变量）被使用。</p>
<p>用 <code>~</code> 引用目录的第二种方法是使用数字而不是名称：数字引用目录栈中的目录。所以如果 <code>dirs -v</code> 给你</p>
<pre><code>  0       ~zsf
  1       ~src
</code></pre>
<p>那么 <code>~+1</code> 和 <code>~-0</code>（不太数学，但如果你仔细想想很合逻辑）都指的是 <code>~src</code>。在这种情况下，与 pushd 参数不同，你可以省略 <code>+</code> 并使用 <code>~1</code>。<code>PUSHD_MINUS</code> 选项是被尊重的。你会看到这在上面的 <code>pushd</code> 函数中被使用了：诀窍是 <code>~+3</code>，例如，指的是与 <code>pushd +3</code> 相同的元素，因此 <code>pushd ~+3</code> 将那个目录推到了列表的前面。然而，我们设置了 <code>PUSHD_IGNORE_DUPS</code>，所以旧位置的值也被移除了，给了我们我们想要的效果，即简单地将目录拉到前面，没有棘手的循环。</p>
<p>[]{#l36}</p>
<h3 id="325-命令控制和信息命令"><a class="header" href="#325-命令控制和信息命令">3.2.5: 命令控制和信息命令</a></h3>
<p>存在各种内建命令，它们控制你如何访问命令，并显示可以运行的命令的信息。</p>
<p>前两个严格来说是“前置命令修饰符”而不是命令：这意味着它们放在命令行之前并修改其行为，而不是它们本身就是命令。如果你在命令行前放上 <code>command</code>，命令词（下一个词）将被视为外部命令的名称，无论它通常如何被解释；同样，如果你在前面放上 <code>builtin</code>，shell 将尝试将该命令作为内建命令运行。通常，shell 函数优先于内建命令，内建命令优先于外部命令。所以，例如，如果你的打印机控制系统有 <code>enable</code> 命令（许多 System V 版本都有），它与我将要谈论的一个内建命令冲突，你可以运行 <code>command enable lp</code> 来启用一个打印机；否则，内建的 enable 将被运行。同样，如果你已经将 <code>cd</code> 定义为一个函数，但这次想调用正常的内建 <code>cd</code>，你可以说 <code>builtin cd mydir</code>。</p>
<p><code>command</code> 的一个常见用途是在同名的 shell 函数内部。有时你想通过在普通命令周围添加一些额外的东西来增强它，然后调用那个命令，所以你编写一个同名的 shell 函数。要在 shell 函数内部调用命令本身，你使用 <code>command</code>。以下代码可以工作，尽管它显然不那么有用：</p>
<pre><code>  ls() {
    command ls "$[@]"
  }
</code></pre>
<p>所以当你运行 <code>ls</code> 时，它会调用函数，函数会调用真正的 <code>ls</code> 命令，并传递你给它的参数。</p>
<p>你可以用 <code>disable</code> 和 <code>enable</code> 命令对 shell 将运行的命令进行更持久的控制。前者通常接受内建参数；每个这样的内建命令在 shell 中都不会被识别，直到你为它发出一个 <code>enable</code> 命令。所以如果你想能够运行外部的 <code>enable</code> 命令，并且不特别关心内建版本，<code>disable enable</code>（抱歉如果这令人困惑）就能做到。哈，你在想，你不能运行 <code>enable enable</code>。没错：在遥远的过去，<code>builtin enable enable</code> 可能会起作用，但目前不行；如果我记得改的话，这可能会改变。你可以只用 <code>disable</code> 本身来列出所有被禁用的内建命令——大多数做这类操作的内建命令都像那样工作。</p>
<p>你可以通过给出不同的选项来用 <code>disable</code> 和 <code>enable</code> 操作其他命令集：用 <code>-a</code> 选项操作别名，用 <code>-f</code> 选项操作函数，用 <code>-r</code> 选项操作保留字。前两个你可能已经知道了，我稍后也会讲到，但“保留字”需要描述一下。它们本质上是对 shell 有一些特殊语法意义的内建命令，包括一些符号，如 <code>{</code> 和 <code>[[</code>。它们优先于除别名之外的所有东西——事实上，由于它们在语法上是特殊的，shell 需要很早就知道它找到了一个保留字，等到它尝试执行一个命令时就太晚了。例如，如果 shell 找到 <code>[[</code>，它需要知道直到 <code>]]</code> 的所有内容都必须被视为一个测试，而不是普通的命令参数。因此，你不会经常想禁用一个保留字，因为 shell 将无法正常工作。你可能这样做的最明显的原因是为了与某个没有该保留字的其他 shell 兼容。你可以用以下命令得到一个完整的列表：</p>
<pre><code>  whence -wm '*' | grep reserved
</code></pre>
<p>我将在下面解释，因为我马上就要讲到 <code>whence</code>。</p>
<p>此外，我倾向于发现，如果我想摆脱别名或函数，我使用 <code>unalias</code> 和 <code>unfunction</code> 命令来永久地摆脱它们，因为我总是在某个地方存储了原始定义，所以这两个选项可能也不是那么有用。禁用内建命令绝对是 <code>disable</code> 的四种可能性中最有用的。</p>
<p>外部命令必须以不同的方式操作。上面给出的类型由 shell 内部处理，所以它需要做的就是记住要调用什么代码。对于外部命令，问题在于如何找到它们。我上面提到了 <code>rehash</code>，但没有告诉你 <code>hash</code> 命令，你已经见过它的 <code>-d</code> 选项，可以用来告诉 shell 如何找到一个外部命令：</p>
<pre><code>  hash foo=/path/to/foo
</code></pre>
<p>使得 <code>foo</code> 使用显示的路径执行命令（它甚至不必以 <code>foo</code> 结尾）。这有点像一个别名——大多数人可能会用别名来做这个，事实上——尽管速度快一点，但你不太可能注意到区别。你可以用 <code>unhash</code> 来移除这个。这里有一个陷阱是，如果路径被重新哈希，无论是通过调用 <code>rehash</code> 还是当你改变 <code>$path</code> 时，整个哈希表都会被清空，包括你以这种方式放入的任何东西；所以它不是特别有用。</p>
<p>在所有这些之中，能够找出 shell 认为一个特定的命令名是做什么的，是很有用的。命令 <code>whence</code> 告诉你这个；它也以 <code>where</code>、<code>which</code> 和 <code>type</code> 的名称存在，选项略有不同，主要是为了提供与其他 shell 的兼容性。我只讲 <code>whence</code>。</p>
<p>它的标准输出实际上并不特别有趣。如果它是一个 shell 内部以某种方式知道的命令，它会被回显回来，如果是别名，别名会被展开；如果它是一个外部命令，它会以完整路径打印出来，显示它来自哪里；如果它不为人知，命令返回状态 1 并且不打印任何东西。</p>
<p>你可以用 <code>-v</code> 或 <code>-c</code> 选项让它更有用，它们更详细；前者打印一条信息消息，而后者打印出它被问及的任何函数的定义（这也是使用 <code>which</code> 而不是 <code>whence</code> 的效果）。一个非常有用的选项是 <code>-m</code>，它将任何参数作为使用通常的 zsh 模式格式的模式，换句话说，与用于匹配文件的格式相同。因此</p>
<pre><code>  whence -vm "*"
</code></pre>
<p>打印出 shell 知道的每个命令，以及它对它的看法。</p>
<p>注意 <code>*</code> 周围的引号——你必须在任何模式不用于在命令行上生成文件名，而是需要传递给命令以供解释的地方记住这些。如果这看起来是一个相当微妙的区别，想想如果你在一个有文件 <code>foo</code> 和（猜猜看）<code>bar</code> 的目录中运行</p>
<pre><code>  # 糟糕。最好不要在家里尝试这个。
  # （甚至更好，也不要在工作中这样做。）
  whence -vm *
</code></pre>
<p>会发生什么。当 shell 第一次看命令行时，它还没有决定要运行哪个命令；它只是看到 <code>*</code> 并将该行扩展为</p>
<pre><code>  whence -vm foo bar
</code></pre>
<p>这不是你想要的。</p>
<p>还有几个值得一提的技巧：<code>-p</code> 使 shell 在你的路径中搜索它们，即使该名称被匹配为其他东西（比如说，一个 shell 函数）。所以如果你将 <code>ls</code> 定义为一个函数，</p>
<pre><code>  which -p ls
</code></pre>
<p>仍然会告诉你 <code>command ls</code> 会找到什么。此外，选项 <code>-a</code> 搜索所有命令；在同一个例子中，这会向你显示 <code>ls</code> 命令和 <code>ls</code> 函数，而 <code>whence</code> 通常只会显示函数，因为那是将被运行的那个。<code>-a</code> 选项还会显示它是否在你的路径中找到了多个外部命令。</p>
<p>最后，选项 <code>-w</code> 很有用，因为它用一个单词标识命令的类型：<code>alias</code>、<code>builtin</code>、<code>command</code>、<code>function</code>、<code>hashed</code>、<code>reserved</code> 或 <code>none</code>。其中大多数是显而易见的，<code>command</code> 是一个普通的外部命令；<code>hashed</code> 是一个用 <code>hash</code> 内建命令明确给定了路径的外部命令，<code>none</code> 意味着它根本没有被识别为命令。现在你知道我们上面是如何提取保留字的了。</p>
<p><code>whence</code> 的一个近亲是 <code>functions</code>，它当然适用于 shell 函数；它通常列出作为参数给出的所有函数的定义，但它的亲戚（其中 <code>autoload</code> 是一个）执行各种其他技巧，将在下面关于 shell 函数的部分描述。小心 <code>function</code>，没有 <code>s</code>，它完全不同，不像 <code>command</code> 或 <code>builtin</code>——它实际上是用于<em>定义</em>函数的关键字。</p>
<p>[]{#l37}</p>
<h3 id="326-参数控制"><a class="header" href="#326-参数控制">3.2.6: 参数控制</a></h3>
<p>有各种用于控制 shell 参数的内建命令。你已经知道如何设置和使用参数，但当你查看细节时，它要复杂得多。</p>
<p><strong>局部参数</strong>\</p>
<p>操作参数行为的主要命令是 <code>typeset</code>。它最简单的用法是声明一个参数；你只需给它一个参数名列表，这些参数名被创建为标量参数。你可以通过赋值来创建参数，但 <code>typeset</code> 的主要作用是，如果一个参数以这种方式在函数内部创建，该参数将在函数结束时恢复其原始值，或者如果它以前不存在则被移除——换句话说，它具有“局部作用域”，就像你在大多数普通编程语言中声明的变量一样。事实上，用行话来说，它具有“动态”而非“语法”作用域，这意味着同一个参数在当前函数内调用的任何函数中都是可见的；这与 C 或 FORTRAN 不同，在 C 或 FORTRAN 中，任何被调用的函数或子程序都看不到父函数中声明的任何变量。</p>
<p>以下内容使这一点更具体。</p>
<pre><code>  var='原始值'
  subfn() {
    print $var
  }
  fn() {
    print $var
    typeset var='函数中的值'
    print $var
    subfn
  }
  fn
  print $var
</code></pre>
<p>这段代码打印出</p>
<pre><code>  原始值
  函数中的值
  函数中的值
  原始值
</code></pre>
<p>代码的前三块只是定义了参数 <code>$var</code> 和两个函数 <code>subfn</code> 和 <code>fn</code>。然后我们调用 <code>fn</code>。它做的第一件事是打印出 <code>$var</code>，得到 <code>原始值</code>，因为我们没有改变原始定义。然而，接下来的 <code>typeset</code> 改变了它；如你所见，我们可以在 typeset 期间给参数赋值。因此，当我们再次打印出 <code>$var</code> 时，我们得到 <code>函数中的值</code>。然后调用 <code>subfn</code>，它打印出与 <code>fn</code> 中相同的值，因为我们没有改变它——这就是 C 或 FORTRAN 会有所不同的地方，它们不会识别这个变量，因为它没有在那个函数中声明。最后，<code>fn</code> 退出，原始值被恢复，并由最后的 <code>print</code> 打印出来。</p>
<p>注意值改变了两次：一次在 <code>typeset</code>，另一次在 <code>fn</code> 的末尾。<code>$var</code> 在任何时候的值都将是这两个值之一。</p>
<p>虽然你可以在 <code>typeset</code> 语句中进行赋值，但你不能给数组赋值（我在上一章已经说过了）：</p>
<pre><code>  typeset var=(这不起作用！)
</code></pre>
<p>因为带括号的语法是特殊的；它只在行只包含赋值时才起作用。然而，如果你尝试将一个数组赋给一个标量，或者反过来，shell 不会抱怨；它只是默默地转换类型：</p>
<pre><code>  typeset var='标量值'
  var=(数组值)
</code></pre>
<p>我在 typeset 语句中加入了赋值，以强调它创建标量，但实际上在函数中设置数组的通常方法是</p>
<pre><code>  typeset var
  var=()
</code></pre>
<p>它创建一个空的标量，然后将其转换为空的数组。最近版本的 shell 有 <code>typeset -a var</code> 来一步完成——但你<em>仍然</em>不能在同一个语句中给它赋值。</p>
<p><code>typeset</code> 及其亲属只是带有普通参数集的普通命令，这一事实还带来了其他问题。考虑这个：</p>
<pre><code>  % typeset var=`echo 两个 词`
  % print $var
  两个
</code></pre>
<p>“词”去哪儿了？答案是，反引号替换，下面会讨论，在未被引用时会分割单词。所以 <code>typeset</code> 语句等同于</p>
<pre><code>  % typeset var=两个 词
</code></pre>
<p>有两种方法可以解决这个问题；首先，使用普通赋值：</p>
<pre><code>  % typeset var
  % var=`echo 两个 词`
</code></pre>
<p>它可以判断出是标量赋值，因此知道不要分割单词，或者引用反引号，</p>
<pre><code>  % typeset var="`echo 两个 词`"
</code></pre>
<p>我们还没有谈到三种重要的类型；这两种都只能用 <code>typeset</code> 或我稍后会列出的类似内建命令之一来创建。它们是整数类型、浮点类型和关联数组类型。</p>
<p><strong>数值参数</strong>\</p>
<p>整数是用 <code>typeset -i</code> 创建的，或者 <code>integer</code>，这是另一种说法。它们用于算术，shell 可以这样做：</p>
<pre><code>  integer i
  (( i = 3 * 2 + 1 ))
</code></pre>
<p>双括号包围一个完整的算术表达式：它的行为就像被引用了一样。里面的表达式可以是你可能在其他编程语言的算术中习惯的几乎任何东西。一个重要的注意事项是，参数前面不需要有 `$``，即使它们的值正在被取用：</p>
<pre><code>  integer i j=12
  (( i = 3 * ( j + 4 ) ** 2 ))
</code></pre>
<p>在这里，<code>j</code> 将被替换为 12，<code>$i</code> 得到值 768（十六的平方乘以三）。你可能不认识的一个东西是 <code>**</code>，这是 FORTRAN 和 Perl 中出现的“乘方”运算符。请注意，在双括号内有括号是没问题的——实际上，你甚至可以这样做</p>
<pre><code>  (( i = (3 * ( j + 4 )) ** 2 ))
</code></pre>
<p>而且 shell 不会感到困惑，因为它知道里面的任何括号都必须是成对的（直到你用你的有 bug 的代码故意迷惑它）。</p>
<p>你通常会用 <code>print $i</code> 来看看 <code>$i</code> 被赋予了什么值，当然，它会以十进制数的形式打印出来。然而，<code>typeset</code> 允许你指定另一个基数来打印。如果你这样做</p>
<pre><code>  typeset -i 16 i
  print $i
</code></pre>
<p>在上次计算之后，你应该会看到 <code>16#900</code>，这意味着以 16 为基数（十六进制）的 900。这就是选项 <code>-i 16</code> 对 <code>$i</code> 的唯一影响——你可以像平常一样给它赋值并在算术表达式中使用它，但当你打印它时，它会以这种形式出现。你也可以用这种基数表示法来输入数字：</p>
<pre><code>  (( i = 16#ff * 2#10 ))
</code></pre>
<p>这意味着 255（十六进制的 <code>ff</code>）乘以 2（二进制的 <code>10</code>）。shell 也理解 C 的表示法，所以 <code>16#ff</code> 可以表示为 <code>0xff</code>。</p>
<p>浮点变量非常相似。你可以用 <code>typeset -F</code> 或 <code>typeset -E</code> 来声明它们。两者唯一的区别，同样，是在输出上；<code>-F</code> 使用定点表示法，而 <code>-E</code> 使用科学（助记：指数）表示法。内建命令 <code>float</code> 等同于 <code>typeset -E</code>（因为 Korn shell 就是这么做的，所以就这样）。浮点表达式也以你可能习惯的方式工作：</p>
<pre><code>  typeset -E e
  typeset -F f
  (( e = 32/3, f = 32.0/3.0 ))
  print $e $f
</code></pre>
<p>打印</p>
<pre><code>  1.000000000e+01 10.6666666667
</code></pre>
<p>几点说明：<code>,</code> 可以分隔不同的表达式，就像在 C 中一样，所以 <code>e</code> 和 <code>f</code> 的赋值是分开执行的。<code>e</code> 的赋值实际上是一个整数除法，因为 32 和 3 都不是浮点数，浮点数必须包含一个点。这意味着进行了一个整数除法，产生 10，然后在最后才转换为浮点数。同样，这就像成熟的语言的工作方式，所以咒骂是没用的。<code>f</code> 的赋值是一个完整的浮点运算。浮点参数在 <code>3.1.7</code> 版本之前是不可用的。</p>
<p>虽然这实际上是后面章节的内容，但有一个浮点函数库你可以加载（实际上它只是链接系统数学库的一种方式）。通常的咒语是 <code>zmodload zsh/mathfunc</code>；你的系统上可能没有库的“动态加载”，这可能意味着那不起作用。如果可以，你可以做类似的事情</p>
<pre><code>  (( pi = 4.0 * atan(1.0) ))
</code></pre>
<p>广义上说，大多数系统数学库中出现的所有函数（参见 <code>math</code> 的手册页）在 zsh 中都可用。</p>
<p>像所有其他用 <code>typeset</code> 或其亲属之一创建的参数一样，整数和浮点参数是函数局部的。你可能想知道如何创建一个具有整数或浮点值的全局参数（即在函数外部和内部都有效的参数）。shell 最近增加了一个功能（在 3.1.6 版本中）允许这样做：在 typeset 中使用 <code>-g</code> 标志以及任何其他标志。例如，</p>
<pre><code>  fn() {
    typeset -Fg f
    (( f = 42.75 ))
  }
  fn
  print $f
</code></pre>
<p>如果你试试，你会看到 <code>$f</code> 的值在函数之外仍然存在。<code>g</code> 代表全局，显然，尽管它不完全那么简单：</p>
<pre><code>  fn() {
    typeset -Fg f
  }
  outerfn() {
    typeset f='标量值'
    fn
    print $f
  }
  outerfn
</code></pre>
<p>函数 <code>outerfn</code> 为 <code>f</code> 创建一个局部标量值；这就是 <code>fn</code> 所看到的。所以它实际上不是在操作一个“全局”值，它只是没有为 <code>fn</code> 的作用域创建一个新的。错误消息是因为它试图在改变其类型的同时保留 <code>$f</code> 的值，而该值不是一个正确的浮点表达式。错误消息，</p>
<pre><code>  fn: bad math expression: operator expected at `value'
</code></pre>
<p>是因为对数字参数赋值总是执行算术求值。在操作 <code>scalar value</code> 时，它找到了 <code>scalar</code> 并假设这是一个参数，然后寻找一个像 <code>+</code> 这样的运算符；但它找到了 <code>value</code>。如果你想实验，把字符串改成 <code>scalar + value</code> 并设置 <code>value=42</code>，或者别的什么，然后再试一次。这有点令人困惑（这是说它让我困惑的委婉说法），但与 zsh 通常对待参数的方式是一致的。</p>
<p>实际上，在某种程度上你不需要使用整数和浮点参数。任何时候 zsh 需要一个数字表达式，它都会强制一个标量到正确的值，任何时候它产生一个数字表达式并将其赋给一个标量，它都会将结果转换为字符串。所以</p>
<pre><code>  typeset num=3            # 这是*字符串* `3'。
  (( num = num + 1 ))      # 但这无论如何都有效
                           # ($num 仍然是一个字符串)。
</code></pre>
<p>如果你有一个参数有时是数字，有时是字符串，这可能很有用，因为 zsh 为你做了所有的转换工作。然而，如果你总是想要一个数字，这也可能令人困惑，因为 zsh 无法为你猜测；另外，不来回转换效率更高一些；另外，当你这样做时会失去精度，因为如果数字作为字符串而不是内部数字表示存储，你说的就是你得到的（尽管 zsh 在隐式转换为字符串时倾向于给你很多小数位）。无论如何，我建议如果你知道一个参数必须是整数或浮点值，你应该这样声明它。</p>
<p>有一个名为 <code>let</code> 的内建命令来处理数学表达式，但是因为</p>
<pre><code>  let "num = num + 1"
</code></pre>
<p>等同于</p>
<pre><code>  (( num = num + 1 ))
</code></pre>
<p>而且第二种形式更容易、更难忘，你可能不需要使用它。如果你确实使用它，请记住（与 BASIC 不同）每个数学表达式都应该作为引号中的一个参数出现。</p>
<p><strong>关联数组</strong>\</p>
<p>剩下的一种主要参数类型是关联数组；如果你使用 Perl，你可能会称之为“哈希”，但我们倾向于不这样做，因为那实际上是对它如何实现的描述，而不是它做什么。（好吧，它做的是哈希。现在闭嘴。）</p>
<p>这些必须用 typeset 语句声明——没有别的办法。有一些相当不拘一格的内建命令会为你生成一个填充好的关联数组，但告诉 zsh 你想要你自己的关联数组的唯一方法是</p>
<pre><code>  typeset -A assoc
</code></pre>
<p>来创建 <code>$assoc</code>。至于它做什么，最好用例子来展示：</p>
<pre><code>  typeset -A assoc
  assoc=(one eins two zwei three drei)
  print ${assoc[two]}
</code></pre>
<p>它打印 <code>zwei</code>。所以它的工作方式有点像一个普通数组，但普通数组中会出现在方括号内的数字<em>下标</em>被字符串<em>键</em>取代了，在这种情况下是 <code>two</code>。数组赋值有点欺骗性；“值”实际上是成对的，<code>one</code> 是值 <code>eins</code> 的键，依此类推。如果这样的列表中有奇数个元素，shell 会抱怨。这可能也让你想起了 Perl。你可以一次赋一个值：</p>
<pre><code>  assoc[four]=vier
</code></pre>
<p>也可以取消设置一个键/值对：</p>
<pre><code>  unset 'assoc[one]'
</code></pre>
<p>这里的引号阻止了方括号在命令行上被解释为模式。</p>
<p>展开被推迟了，但你可能想知道如何取回你放进去的东西。如果你这样做</p>
<pre><code>  print $assoc
</code></pre>
<p>你只会看到值——这与普通数组完全相同，其中下标 1、2、3 等不显示。注意它们的顺序是随机的——这是与普通数组的另一个主要区别；关联数组没有顺序的概念，除非你明确地对它们进行排序。</p>
<p>但在这里，键可能同样有趣。所以有：</p>
<pre><code>  print ${(k)assoc}
  print ${(kv)assoc}
</code></pre>
<p>得到（如果你已经执行了上面所有的命令）：</p>
<pre><code>  four two three
  four vier two zwei three drei
</code></pre>
<p>它打印出键而不是值，以及你输入的键和值对。你可以看到，虽然对的顺序不明显，但每次都是一样的。从这个例子中你可以得出如何将一个关联数组复制到另一个：</p>
<pre><code>  typeset -A newass
  newass=(${(kv)assoc})
</code></pre>
<p>其中 <code>(kv)</code> 很重要——就像赋值前的 <code>typeset</code> 一样，否则 <code>$newass</code> 会是一个糟糕的普通数组。你也可以证明 <code>${(v)assoc}</code> 做了你可能期望的事情。还有很多其他的技巧，但它们大多与聪明的参数展开类型有关，将在<a href="zshguide05.html#subst">第五章</a>中描述。</p>
<p><strong>其他 typeset 和类型技巧</strong>\</p>
<p><code>typeset</code> 有变体，上面零星提到了一些。没有任何一个能做 <code>typeset</code> 做不到的事情——情况并非总是如此；我们试图改进选项的正交性。它们在默认设置的选项和允许的附加选项上有所不同。这里有一个列表：<code>declare</code>、<code>export</code>、<code>float</code>、<code>integer</code>、<code>local</code>、<code>readonly</code>。我不会通过详细描述所有这些来迷惑你；请参阅手册。</p>
<p>如果有一个例外，那就是 <code>export</code>，它不仅标记一个参数以便导出，而且默认情况下打开了 <code>-g</code> 标志，因此该参数不是函数局部的；换句话说，它等同于 <code>typeset -gx</code>。然而，一个从选项不那么合乎逻辑的时代遗留下来的问题是，<code>typeset -x</code> 的行为像 <code>export</code>，换句话说，<code>-g</code> 标志默认是打开的。你可以通过取消设置 <code>GLOBAL_EXPORT</code> 选项来解决这个问题——该选项只为兼容性而存在；逻辑上它应该总是被取消设置。这部分是因为在过去你不能导出局部参数，所以 <code>typeset -x</code> 要么必须打开 <code>-g</code>，要么关闭 <code>-x</code>；这在 3.1.9 版本中得到了修复，并且（例如）<code>local -x</code> 创建一个导出到环境的局部参数；参数本身和环境中的值都将在函数退出时恢复。内建命令 <code>local</code> 本质上是 <code>typeset</code> 的一种形式，它放弃了 <code>-g</code> 标志及其所有功能。</p>
<p>另一个已经消失的旧限制是，你不能让特殊参数，特别是 <code>$PATH</code>，成为函数局部；你只是修改了原始参数。现在如果你说 <code>typeset PATH</code>，事情会像你可能期望的那样发生，<code>$PATH</code> 具有其通常的效果，并在函数退出时恢复其旧值。然而，由于 <code>$PATH</code> 仍然是特殊的，你应该确保在函数中调用外部命令之前给它赋一些值，否则它将为空，并且找不到任何命令。可能你特别不希望你创建的某个局部参数具有特殊属性；3.1.7 及更高版本允许 typeset 标志 <code>-h</code> 来隐藏该参数的特殊性，所以在 <code>typeset -h PATH</code> 中，<code>PATH</code> 在封闭函数期间将是一个普通变量。在内部，之前设置的相同值将继续用于查找命令，但它不会被导出。</p>
<p>我在上一章提到了另一个特殊的 typeset 选项：</p>
<pre><code>  typeset -T TEXINPUTS texinputs
</code></pre>
<p>以与 <code>$PATH</code> 和 <code>$path</code> 工作相同的方式将标量 <code>$TEXINPUTS</code> 和数组 <code>$texinputs</code> 绑定在一起。这是一次性的；这是 <code>typeset</code> 在命令行上只接受两个参数名的唯一一次。所有其他 <code>typeset</code> 的用法都接受一个参数列表，任何给定的标志都应用于这些参数。有关其余标志，请参阅手册，尽管大多数更有趣的已经讨论过了。</p>
<p>关于标志，你需要知道的另一件事是，你用 <code>+</code> 符号来关闭相应的属性。所以</p>
<pre><code>  typeset +r msg
</code></pre>
<p>允许你再次设置 <code>$msg</code>。从 <code>4.1</code> 版本开始，你将无法关闭特殊参数的只读属性；那是因为有太多的混淆空间，包括试图在代码中设置常量字符串。例如，<code>$ZSH_VERSION</code> 总是打印一个固定的字符串；试图改变那是徒劳的。</p>
<p><code>typeset</code> 的最后一个用途是列出参数。如果你只输入 <code>typeset</code>，你会得到一个完整的参数及其值的列表。从 3.1.7 开始，你可以为一个参数打开 <code>-H</code> 标志，这意味着在这样做时隐藏它的值。这对于一些更庞大的参数可能很有用，特别是我将在<a href="zshguide07.html#ragbag">第七章</a>关于模块的部分谈论的特殊参数，它们往往会淹没 <code>typeset</code> 产生的显示。</p>
<p>你也可以列出特定类型的参数，方法是列出你想知道的标志。例如，</p>
<pre><code>  typeset -r
</code></pre>
<p>列出所有只读参数。你可能会期望 <code>typeset +r</code> 列出<em>没有</em>该属性的参数，但实际上它列出相同的参数，但不显示它们的值。<code>typeset +</code> 以这种方式列出所有参数。</p>
<p>了解参数的另一种好方法是使用特殊扩展 <code>${(t)*param*}</code>，例如</p>
<pre><code>  print ${(t)PATH}
</code></pre>
<p>打印 <code>scalar-export-special</code>：<code>$PATH</code> 是一个标量参数，设置了 <code>-x</code> 标志，并且对 shell 有特殊含义。实际上，“特殊”的含义比那多一点：它意味着获取和设置参数的内部代码的行为方式对参数本身或 shell 的其他地方有副作用。还有其他参数，比如 <code>$HISTFILE</code>，被 shell 使用，但以正常方式获取和设置——它们只是特殊在 shell 会查看其值；毕竟，任何旧的 shell 函数也可以做到这一点。与此形成对比的是 <code>$PATH</code>，它在设置时需要处理所有关于哈希命令的繁琐事务，正如我上面讨论的，我希望你能看到区别。</p>
<p><strong>读入参数</strong>\</p>
<p>内建命令 <code>read</code>，顾名思义，是 <code>print</code> 的反面（shell 中没有 <code>write</code> 命令，尽管通常有一个同名的外部命令用于向另一个用户发送消息），但读取与打印不同，需要 shell 中的某些东西改变以接受值，所以与 <code>print</code> 不同，<code>read</code> 被迫成为一个内建命令。不可避免地，值被读入一个参数。通常它们从标准输入中获取，通常是终端（即使你正在运行一个脚本，除非你重定向了输入）。所以最简单的情况就是</p>
<pre><code>  read param
</code></pre>
<p>如果你输入一行，然后按回车，它将被放入 <code>$param</code>，不带最后的换行符。</p>
<p><code>read</code> 内建命令实际上对输入做了一些处理。它通常会从读入的行中剥离任何初始或末尾的空白（空格或制表符），但中间的任何空白都会被保留。你可以通过列出要赋值的参数来读取一组由空白分隔的值；最后一个参数会得到该行的所有剩余部分，而不会被分割。通常最简单的方法是直接读入一个数组：</p>
<pre><code>  % read -A array
        this is a line typed in now, \ 
      by me,    in this   space
  % print ${array[1]} ${array[12]}
  this space
</code></pre>
<p>（我假设你正在使用原生的 zsh 数组格式，而不是用 <code>KSH_ARRAYS</code> 设置的那个，并且将继续假设这一点。）</p>
<p>当你想要读取某些东西时，能够打印一个提示符是很有用的。你可以用 <code>print -n</code> 来做到这一点，但有一个简写：</p>
<pre><code>  % read line'?请输入一行： '
  请输入一行： some words
  % print $line
  some words
</code></pre>
<p>注意引号包围了 <code>?</code> 以防止它在命令行上被当作模式的一部分。如果你喜欢，你可以从 <code>line</code> 的开头引用整个表达式；我只是那样写，因为我知道参数名不需要引用，因为它们不能有奇怪的字符。这几乎是合乎逻辑的。</p>
<p><code>read</code> 的另一个有用技巧是读取单个字符；<code>-k</code> 选项可以做到这一点，实际上你可以在 <code>k</code> 后面紧跟一个数字，指定要读取的数量。更容易的是，<code>-q</code> 选项读取单个字符，如果是 <code>y</code> 或 <code>Y</code> 则返回状态 0，否则返回状态 1；因此你可以读取是/否问题的答案，而根本不使用参数。但是请注意，如果你不提供参数，回复无论如何都会被赋给 <code>$REPLY</code>（如果它是标量——就像 <code>-q</code> 的情况）或 <code>$reply</code>（如果它是数组——即如果你指定了 <code>-A</code>，但没有参数名）。这些是 shell 使用的非特殊参数的更多例子——它设置 <code>$REPLY</code> 或 <code>$reply</code>，但方式与你设置它们的方式相同；没有副作用。</p>
<p>像 <code>print</code> 一样，<code>read</code> 有一个用于原始模式的 <code>-r</code> 标志。然而，这对 <code>read</code> 只有一个效果：没有它，行尾的 <code>\</code> 指定下一行是当前行的延续（你可以在终端输入时这样做）。有了它，<code>\</code> 不被特殊对待。</p>
<p>最后，一个关于分词的更复杂的说明。我说过，当你读取多个参数或一个数组时，单词会在空白处被分割。实际上，shell 会在 <code>$IFS</code>（代表“输入字段分隔符”）参数中找到的任何字符处分割单词，这个参数是真正特殊的，因为它影响 shell 的内部。默认情况下——并且在绝大多数用途中——它包含空格、制表符、换行符和一个空字符（字符零：如果你知道这些通常用于标记字符串的结尾，你可能会惊讶于 shell 将这些作为普通字符处理，但它确实如此，尽管打印它们通常不显示任何东西）。然而，你可以将它设置为任何字符串：输入</p>
<pre><code>  fn() {
    local IFS=:
    read -A array
    print -l $array
  }
  fn
</code></pre>
<p>然后输入</p>
<pre><code>one word:two words:three words:four
</code></pre>
<p>Shell 会向你显示它读入的数组中的内容，每行一个“单词”：</p>
<pre><code>  one word
  two words
  three words
  four
</code></pre>
<p>你会看到香蕉，呃，单词（三十岁以上的人的笑话）被视为由冒号分隔，而不是由空白分隔。在旧版本的 zsh 中，将 <code>$IFS</code> 设为局部变量不起作用，与其他特殊变量一样；你必须保存它并恢复它。</p>
<p>Zsh 中的 <code>read</code> 命令不允许你进行行编辑，而一些 shell 可以。为此，你应该使用 <code>vared</code> 命令，它运行行编辑器来编辑一个参数，使用 <code>-c</code> 选项，它允许 <code>vared</code> 创建一个新参数。它还接受 <code>-p</code> 选项来指定一个提示符，所以上面的一个例子可以重写为</p>
<pre><code>  vared -c -p '请输入一行： ' line
</code></pre>
<p>它的工作方式很像 read，但有完整的编辑支持。如果你给出 <code>-h</code>（历史）选项，你甚至可以从以前的命令行中检索值。然而，它没有 read 的所有格式化选项，尽管在读取数组时（如果创建新数组，请与 <code>-c</code> 一起使用 <code>-a</code> 选项）它会执行分割。</p>
<p><strong>其他控制参数的内建命令</strong>\</p>
<p>其余处理参数的内建命令可以更快地处理。</p>
<p>内建命令 <code>set</code> 只是设置作为参数传递给函数或脚本的特殊参数，你可以通过 <code>$*</code> 或 <code>$@</code>，或 <code>$&lt;number&gt;</code>（Bourne-like 格式），或通过 <code>$argv</code>（csh-like 格式）来访问，无论你如何设置它们，它们都被称为“位置参数”：</p>
<pre><code>  % set a whole load of words
  % print $1
  a
  % print $*
  a whole load of words
  % print $argv[2,-2]
  whole load of
</code></pre>
<p>这完全就像你在一个函数中，并且用参数 <code>a whole load of words</code> 调用了该函数。实际上，set 也可以用来设置 shell 选项，无论是作为标志，例如 <code>set -x</code>，还是在 <code>-o</code> 之后的单词，例如 <code>set -o xtrace</code> 与前一个例子做同样的事情。通常使用 <code>setopt</code> 更容易，结果是，当你以这种方式设置参数时，你需要小心，以防它们以 <code>-</code> 开头。在真实参数前放上 <code>--</code> 可以解决这个问题。</p>
<p><code>set</code> 的另一个用途是通过</p>
<pre><code>  set -A any_array words to assign to any_array
</code></pre>
<p>来设置任何数组，这等同于（并且是标准的 Korn shell 版本）</p>
<pre><code>  any_array=(words to assign to any_array)
</code></pre>
<p><code>set</code> 版本更有用的一个情况是，如果一个数组的名称本身来自一个参数：</p>
<pre><code>  arrname=myarray
  set -A $arrname words to assign
</code></pre>
<p>在另一种形式中没有简单的等价物；普通赋值的左侧不会扩展一个参数：</p>
<pre><code>  # 不起作用；语法错误
  $arrname=(words to assign)
</code></pre>
<p>这在旧版本的 zsh 中是可行的，但那是在非标准方面。<code>eval</code> 命令，下面会描述，提供了另一种解决这个问题的方法。</p>
<p>接下来是 <code>shift</code>，它只是将一个数组向上移动一个元素，删除原来的第一个元素。没有数组名时，它作用于位置参数。你也可以在数组名前给它一个要移动的数字，而不是一。</p>
<pre><code>  shift array
</code></pre>
<p>等同于</p>
<pre><code>  array=(${array[2,-1]})
</code></pre>
<p>（几乎——我将把这里的微妙之处留给关于展开的章节）它选取数组的第二个到最后一个元素，并将它们赋回给原始数组。再次注意，<code>shift</code> 使用数组的<em>名称</em>而不是<em>值</em>来操作，所以前面不应该出现 <code>$</code>，否则你会得到类似于我为 <code>set -A</code> 展示的技巧。</p>
<p>最后，<code>unset</code> 取消设置一个参数，我已经展示了你可以取消设置一个关联数组的键/值对。这里有一个需要提到的微妙之处。通常，<code>unset</code> 只是让命名的参数从地球上消失。然而，如果你在函数中调用 <code>unset</code>，它的幽灵会以这样的方式存在：你在同名中创建的任何参数都将具有与原始参数相同的作用域。因此：</p>
<pre><code>  var='全局值'
  fn() {
    typeset var='局部值'
    unset var
    var='这个怎么样？'
  }
  fn
  print $var
</code></pre>
<p>最后的语句打印 <code>全局值</code>：即使 <code>$var</code> 的局部副本被取消设置，shell 也会记住它是局部的，所以函数中的第二个 <code>$var</code> 也是局部的，它的值在函数结束时消失。</p>
<p>[]{#l38}</p>
<h3 id="327-历史控制命令"><a class="header" href="#327-历史控制命令">3.2.7: 历史控制命令</a></h3>
<p>访问 shell 命令历史最简单的方法是直接编辑它。第二简单的方法是使用 <code>!</code>-历史机制。其他操作它的方法都基于 <code>fc</code> 内建命令，它可能曾经代表什么（根据 Oliver Kiddle 的说法，是“修复命令”，这和任何东西一样好）。我在上一章已经谈了很多，真的没有什么要补充的了。只需注意，另外两个基于它的命令是 <code>history</code> 和 <code>r</code>。</p>
<p>[]{#l39}</p>
<h3 id="328-作业控制和进程控制"><a class="header" href="#328-作业控制和进程控制">3.2.8: 作业控制和进程控制</a></h3>
<p>C-shell 的主要贡献之一是作业控制。你需要了解前台和后台任务，我在上一章连同控制它们的选项一起介绍了这些。这里是对相关内建命令的介绍。</p>
<p>你用两种方式启动一个后台作业。首先，直接地，通过在它后面放一个 <code>&amp;</code>：</p>
<pre><code>  sleep 10 &amp;
</code></pre>
<p>其次，通过以正常方式启动它（即在前台），然后输入 <code>^Z</code>，并使用 <code>bg</code> 命令将其放入后台。在输入 <code>^Z</code> 和 <code>bg</code> 之间，作业仍然存在，但没有运行；它被“挂起”或“停止”（系统对同一件事有不同的描述），等待你决定如何处理它。在任何一种情况下，作业然后继续，而 shell 不等待它。如果那是你启动它的方式，它仍然会尝试从终端读取或写入；如果你想改变这一点，你需要在作业已经启动后就无能为力了，你需要在开始时就使用 shell 的重定向功能。</p>
<p>顺便说句，<code>sleep</code> 不是一个内建命令。奇怪的是，你可以用 <code>^Z</code> 挂起一个内建命令或命令序列（比如 shell 函数），尽管由于 shell 必须继续执行你的命令以及被挂起，它只能做它能做的事——分叉，这样你挂起的命令就被放入后台。可能你很少会对内建命令这样做。据我所知，没有其他 shell 有这个功能。</p>
<p>如果一个作业需要从终端读取，它会停止。你会看到一条像这样的消息：</p>
<pre><code>  [1]  + 1348 suspended (tty input)  jobname and arguments
</code></pre>
<p>这意味着作业被挂起了，很像你刚刚输入了 <code>^Z</code>。你需要把作业带到前台，如下所述，这样你就可以给它输入一些东西。</p>
<p>顺便说句，用于挂起命令的键可能不是 <code>^Z</code>；通常是，但这可以改变。运行 <code>stty -a</code> 并查找 <code>susp =</code> 后面列出的内容——可能是，但不一定是 <code>^Z</code>。所以如果你想使用另一个字符——它必须是单个字符；这是在终端接口深处处理的，而不是在 shell 中——你可以运行</p>
<pre><code>  stty susp '^]'
</code></pre>
<p>或者别的什么。你会从 <code>stty</code> 的输出中注意到，各种其他的作业控制字符也可以类似地改变。<code>stty</code> 命令是外部的，它的输出和输入格式在不同系统之间可能会有很大差异。</p>
<p>除了将命令放入后台，你还可以用 <code>fg</code> 将其再次带回前台。这对于暂时停止你正在做的事情以便你可以做别的事情很有用。如今你可能会在另一个窗口中这样做；在过去，当人们从简单的终端登录时，这更有用。一个典型的例子是</p>
<pre><code>  more file                        # 查看文件
  ^Z                               # 挂起
  [1] + 8592 suspended  more file  # 打印的消息
  ...                              # 做别的事情
  fg %1                            # 恢复 `more`
</code></pre>
<p><code>%</code> 是引用作业的常用方式。它后面的数字是出现在挂起消息的方括号中的数字；我不知道为什么 shell 在那里也不用 <code>%</code> 表示法。你也会在将某物放入后台时的“继续”消息中看到它，以及在后台作业完成时告诉你它已完成的“完成”消息中再次看到它。<code>%</code> 可以有其他形式；最常见的是在它后面跟一个命令的名称，比如在这种情况下是 <code>%more</code>。形式 <code>%+</code> 和 <code>%-</code> 指的是最近和次近的作业——挂起消息中的 <code>+</code> 告诉你 <code>more</code> 作业可以那样被引用。</p>
<p>大多数作业控制命令实际上会假设你是在谈论 <code>%+</code>，如果你不给参数的话，所以假设我没有在后台启动任何其他命令，我本可以在上面的命令序列的末尾只放一个 <code>fg</code>。这实际上是双向的：<code>fg</code> 是对用 <code>%</code> 表示法引用的作业的默认操作，所以只输入 <code>%1</code> 而没有命令名也会起作用。</p>
<p>你可以用 <code>jobs</code> 命令来提醒自己正在发生什么。它看起来像一系列以方括号中的数字开头的消息；通常作业要么是“正在运行”要么是“已挂起”。这会告诉你需要的数字。</p>
<p>你可以对一个作业做的另一件有用的事是告诉 shell 忘记它。这只有在它已经在后台运行时才真正有用；然后你可以用作业标识符运行 <code>disown</code>。这对于你想在注销后继续运行的作业，以及那些有自己的窗口因此你可以直接控制的作业很有用。对于被 disown 的作业，shell 在你注销时不会警告你它们还在那里。你实际上可以在启动后台作业时通过在行尾放上 <code>&amp;|</code> 或 <code>&amp;!</code> 而不是简单的 <code>&amp;</code> 来 disown 它。请注意，如果作业在你 disown 它时被挂起，它将保持被 disown 的状态；这几乎没有意义，所以你可能应该先对它运行 <code>bg</code>。</p>
<p>你最可能想对一个作业做的下一件事是杀死它，或者当它已经在后台并且你不能只输入 <code>^Z</code> 时挂起它。这就是 <code>kill</code> 内建命令的用武之地。这比上面提到的内建命令要复杂得多。首先，你可以对不是从当前 shell 启动的其他进程使用 <code>kill</code>。在这种情况下，你会用一个数字来标识它，没有 <code>%</code>——这就是为什么在其他情况下有 <code>%</code> 的原因。当然，你需要找出这个数字；通常的方法是用 <code>ps</code> 命令，它不是一个内建命令，但出现在所有类 UNIX 系统上。作为一个愚蠢的例子，这里我启动一个做很少事情的被 disown 的进程，寻找它，然后杀死它：</p>
<pre><code>  % sleep 60 &amp;|
  % ps -f
  UID        PID  PPID  C STIME TTY          TIME CMD
  pws        623   614  0 22:12 pts/0    00:00:00 zsh
  pws       8613   623  0 23:12 pts/0    00:00:00 sleep 60
  pws       8615   623  0 23:12 pts/0    00:00:00 ps -f
  % kill 8613
  % ps -f
  UID        PID  PPID  C STIME TTY          TIME CMD
  pws        623   614  0 22:12 pts/0    00:00:00 zsh
  pws       8616   623  0 23:12 pts/0    00:00:00 ps -f
</code></pre>
<p>第二次我看时，进程已经消失了。注意，以通常的 UNIX 沉闷方式，shell 没有费心告诉你进程已经被杀死；然而，如果它发送信号失败，它会报告一个错误。发送信号是 shell 关心的全部；如果进程决定在被告知时不想死，shell 不会警告你，所以最好还是检查一下。</p>
<p>有时你想等待一个进程退出；<code>wait</code> 内建命令可以做到这一点，并且像 <code>kill</code> 一样，可以接受一个进程号以及一个作业号。然而，这有点欺骗性——你实际上不能等待一个不是直接从 shell 启动的进程。的确，等待的机制与 UNIX 处理进程的方式紧密相连；除非它的父进程等待它，否则一个进程会变成一个“僵尸”并徘徊，直到系统的养父，即“init”进程（总是进程号 1）等待它。这有点巴洛克风格，但对于 shell 用户来说，wait 只是意味着你可以坚持到你启动的某个东西完成。的确，这就是前台进程的工作方式：shell 实际上使用 <code>wait</code> 的内部版本来等待作业退出。（嗯，实际上那是个谎言；系统会从它正在做的任何事情中唤醒它，告诉它一个子进程已经完成，所以它所要做的就是打盹等待。）</p>
<p>此外，即使作业控制没有运行，你也可以等待一个进程。作业控制，基本上任何涉及那些 <code>%</code> 的东西，只有当你在终端上摆弄命令时才有用；当你运行脚本时，它不起作用。那时 shell 在如何控制其作业方面有更少的自由，但它仍然可以等待一个后台进程，并且如果它知道它的号码，它仍然可以对一个进程使用 <code>kill</code>。为此，shell 将最后一个在后台启动的进程的 ID 存储在参数 <code>$!</code> 中；<code>!</code> 可能有一个很好的理由，但我不知道是什么。无论作业控制如何，这都会发生。</p>
<p><strong>信号</strong>\</p>
<p><code>kill</code> 命令能做的远不止杀死一个进程。那是默认操作，这就是为什么该命令有那个名字。但它真正做的是向一个进程发送一个“信号”。信号是与另一个进程通信的最简单方式；事实上，如果你没有为进程从你这里读取消息做特殊安排，它们是大约唯一的简单方式。信号名称写成 <code>SIGINT</code>、<code>SIGTSTP</code>、<code>SIGKILL</code>；要向一个进程发送一个特定的信号，你去掉 <code>SIG</code>，在前面加一个连字符，并将其用作 <code>kill</code> 的第一个参数，例如：</p>
<pre><code>  kill -KILL 8613
</code></pre>
<p>你已经知道的一些事情实际上就是这样做的。当你输入 <code>^C</code> 来停止一个进程时，你实际上是在向它发送一个 <code>SIGINT</code>，代表“中断”，就好像你做了</p>
<pre><code>  kill -INT 8613
</code></pre>
<p><code>kill</code> 通常发送的信号不是，你可能猜到的，<code>SIGKILL</code>，而是 <code>SIGTERM</code>，代表“终止”；<code>SIGKILL</code> 更强，因为进程不能阻塞那个信号，而它可以对许多信号这样做（我们稍后会看到 shell 如何做到这一点）。它很熟悉</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide03.html">上一章</a></li>
<li><a href="zshguide05.html">下一章</a></li>
</ul>
<hr />
<p>[]{#zle}[]{#l75}</p>
<h1 id="第四章z-shell-行编辑器-1"><a class="header" href="#第四章z-shell-行编辑器-1">第四章：Z-Shell 行编辑器</a></h1>
<p>Zsh 行编辑器可能是你开始输入命令时最早使用的 shell 部分。即使是最基本的 shell，如 sh，也提供某种编辑能力，尽管在这种情况下可能只是系统本身的功能——输入字符、删除最后一个字符、删除整行。如今你可能使用的大多数 shell 功能都远不止于此。使用 zsh，你甚至可以使用 shell 函数来扩展编辑器命令集。</p>
<p>[]{#l76}</p>
<h2 id="41-zle-介绍-1"><a class="header" href="#41-zle-介绍-1">4.1: zle 介绍</a></h2>
<p>Zsh 行编辑器通常缩写为 <code>zle</code>。通常它会为任何交互式 shell 自行启动；在你决定需要改变其行为之前，你不需要做任何特别的事情。如果一切看起来正常，并且你对 zle 是如何启动的不感兴趣，请跳到下一小节。</p>
<p>如今，zle 存在于其自己的可加载模块 <code>zsh/zle</code> 中，这节省了在 shell 非交互式时拥有编辑器的所有开销。然而，你通常不需要担心这个；我将在<a href="zshguide07.html#ragbag">第七章</a>中更多地讨论模块，但 shell 知道你何时需要 zle 并会自动提供给你。通常模块位于一个名为 <code>/usr/local/lib/zsh/4.0.4/zsh/zle.so</code> 的目录中，其中 <code>4.0.4</code> 是 shell 的版本号，与参数 <code>$ZSH_VERSION</code> 的值相同，之后除了后缀 <code>.so</code> 之外的所有内容都是模块名。后缀可能是 <code>.sl</code> (HP-UX) 或 <code>.dll</code> (Cygwin)，但 <code>.so</code> 是迄今为止最常见的形式。它之所以不同，是因为 zsh 对动态可加载库，或 UNIX 术语中的“共享对象”，保持与操作系统相同的约定。</p>
<p>如果 shell 安装不当，你有时会看到错误消息，说它或像 <code>bindkey</code> 这样的命令无法加载。这意味着 shell 在模块加载路径，即数组 <code>$module_path</code> 中，任何地方都找不到 <code>zsh/zle</code>。那么你需要向你的系统管理员投诉。如果你刚刚编译了 zsh 并遇到这个问题，那是因为你必须在运行 shell 之前安装模块，即使 shell 本身没有安装。你可以通过说 <code>make install.modules</code> 来做到这一点。然后编译好的 zsh 应该可以从它所在的位置运行。</p>
<p>请注意，与 bash 的行编辑器 readline（一个完全独立的库）不同，zle 是 shell 的一个组成部分。因此，你通过在你的 <code>.zshrc</code> 中添加命令来配置它——因为它只对交互式 shell 有用，所以只有 <code>/etc/zshrc</code> 和 <code>.zshrc</code> 对此有意义。</p>
<p>如果你正在使用 info 查看 zsh 手册，无论是用同名命令还是在 Emacs 中用 <code>C-h i</code>，我发现这是最方便的方式：zle 的条目被称为 <code>Zsh Line Editor</code>，全称，而不仅仅是 <code>Zle</code>。顺便说一句，祝你在寻找 <code>Shell Builtin Commands</code>（而不是 <code>Builtins</code>）时玩得开心。</p>
<p>[]{#l77}</p>
<h3 id="411-简单事实"><a class="header" href="#411-简单事实">4.1.1: 简单事实</a></h3>
<p>与 <code>ed</code> 之后的任何编辑器一样，你可以使用各种“按键”，即一次输入的一个或多个键集，在行上移动和更改它。例如，向后移动一个单词的按键是（也许是）<code>ESC b</code>。这意味着你首先按 escape 键；此时什么也没发生。然后你按 <code>b</code>，光标立即跳回到单词的开头。（关于 zle 认为什么是“单词”，我还有更多要说的——它不一定与 shell 其余部分认为的单词相同。）</p>
<p>如果我马上介绍 shell 描述按键的方式，可能会有所帮助；然后当你需要输入它们时，你可以直接复制它们。Escape 键是 <code>\e</code>，所以那个按键将是 <code>\eb</code>。其他常见的按键包括按住 control 键，可能在键盘左下角，同时输入另一个键。指示一个 control 键最简单的方法是在前面放一个 <code>^</code>；所以例如 <code>^x^x</code> 意味着按住 control，并在 control 仍然按住的情况下按两次 <code>x</code>。它的效果与 <code>^X^X</code> 完全相同。（你可能会发现每次这样做时，它都会带你到行的开头，然后回到你原来的位置。）</p>
<p>我已经引入了“也许”这个含糊的词来试图避免撒谎。这是因为实际上 zle 有两种操作模式，一种（默认的）像 Emacs，另一种像 vi。如果你不知道这两个古老的 UNIX 编辑器中的任何一个，我建议你坚持使用 Emacs 模式，因为它对你正在做的事情的干扰要小一些，而且补全也更容易一些。补全是从 zle 行为中派生出来的一个分支，将在<a href="zshguide06.html#comp">第六章</a>中描述（你会注意到，那一章比这一章长）。</p>
<p>如果你通常使用 vi，你可能将环境变量 <code>$EDITOR</code> 或 <code>$VISUAL</code> 中的一个或两个设置为 <code>vi</code>。（如果你使用 <code>vim</code>，或者任何碰巧包含 <code>vi</code> 的编辑器，比如 <code>elvis</code>，它的工作方式完全相同。）在这种情况下，zle 将以其“vi”模式启动，其中的按键完全不同。这就是为什么你可能会发现 <code>\eb</code> 没有像我说的那样工作，即使你没有尝试配置 zle。你可以通过在你的 <code>.zshrc</code> 中放入以下任一命令来让 zle 始终使用 emacs 或 vi 模式：</p>
<pre><code>  bindkey -e
</code></pre>
<p>或</p>
<pre><code>  bindkey -v
</code></pre>
<p>这只是 <code>bindkey</code> 的众多用途之一。</p>
<p>如果你不熟悉“绑定”这个词的用法，它只是意味着“让一个按键执行一个特定的编辑器命令”。命令有带连字符的长名称，它们很好地描述了它们做什么，比如 <code>backward-delete-char</code>。对应于可打印字符的普通键通常“绑定到 <code>self-insert</code>”，这是一种反常的说法，意思是它们做你期望的事情，并显示你输入的字符。然而，你实际上可以把它们绑定到别的东西上。在 vi 命令模式下，这是完全正常的。</p>
<p>实际上，如果你使用窗口系统，你可能想说 <code>bindkey -me</code>，它绑定了一整套“meta”键。在 X Windows 中，你键盘上的一个键，可能是 <code>ALT</code>，可能被指定为一个“meta”键，它具有类似于 control 键的特殊效果。按住 meta 键的绑定描述有点像它们在 Emacs 中的样子，<code>\M-b</code>。（实际上，你可以类似地指定 control 键，比如 <code>\C-x</code>，但 <code>^x</code> 更短。）使用 <code>bindkey</code> 的 <code>-m</code> 选项告诉 zsh，无论它在哪里绑定一个像 <code>\eb</code> 这样的转义序列，它也应该绑定相应的像 <code>\M-b</code> 这样的 meta 序列。Emacs 总是把这些绑在一起，但 zsh 不会——你可以分别重新绑定它们，如果你想让两个序列都绑定到一个新命令，你必须明确地绑定它们两个。</p>
<p>然而，你需要小心使用 <code>bindkey -m</code>；shell 无法判断你是在输入一个最高位被设置的字符，还是在执行一个命令。随着用于字符的 UTF-8 编码变得越来越流行，这可能会变得更糟，因为一个非 ASCII 字符那时由一整串最高位被设置的字节组成。</p>
<p>如果你对绑定功能键感兴趣，你可能已经发现它们发送的键序列显然没有任何意义；更多信息请参见<a href="zshguide04.html#fkeys">下面的部分</a>。这将介绍名为 <code>zkbd</code> 的函数，它可以使这个过程不那么痛苦。该函数也对“meta”和“ALT”键有帮助。</p>
<p>[]{#l78}</p>
<h3 id="412-vi-模式"><a class="header" href="#412-vi-模式">4.1.2: Vi 模式</a></h3>
<p>我将专注于 Emacs 模式，原因有几个：首先，因为我自己使用它；其次，因为你使用 vi 模式最可能的原因是你已经熟悉 vi，不需要被告知它如何工作；第三，因为大多数命令在两种模式下都是相同的，只是绑定不同；最后，因为如果你<em>不</em>已经知道 vi，你很可能会发现 vi 编辑模式相当不直观且难以使用。</p>
<p>然而，这里有一些关于它的评论，只是为了把它讲完。就像真正的 vi 编辑器一样，有两种基本模式，插入模式，你在其中输入文本，和命令模式，在其中插入字符的相同按键被绑定到编辑命令。与真正的 vi 不同，行编辑器在你编辑的每个新命令上都以插入模式启动。这意味着你通常可以简单地输入一行直到最后的“回车”，而忘记你正处于 vi 模式。</p>
<p>要进入命令模式，你按“escape”，再次像普通的 vi 一样。此时你处于 vi 命令的魔法世界，输入一个普通字符可以产生任何效果。然而，绑定与普通的 vi 相似，所以 <code>h</code> 和 <code>l</code> 向左和向右移动。当你想插入更多文本时，你可以使用任何允许你这样做的普通 vi 命令，比如 <code>i</code> (<code>vi-insert</code>) 或 <code>a</code> (<code>vi-add-next</code>)。</p>
<p>除了独立的命令和插入模式以及完全不同的键绑定集之外，Emacs 模式和 vi 模式之间没有基本区别。你可以在两种 vi 模式中都绑定键——它们<em>不必</em>在插入模式下对应于 <code>self-insert</code>。下面，我将描述“键映射”，这是一套完整的关于所有键将做什么的描述（听起来比实际的要令人印象深刻，因为很多键可能被设置为“undefined-key”，这意味着它们不做任何有用的事情），你将看到如何改变两种模式下的行为。</p>
<p>[]{#l79}</p>
<h2 id="42-基本编辑-1"><a class="header" href="#42-基本编辑-1">4.2: 基本编辑</a></h2>
<p>如果你了解 Emacs 或 vi，你很快就会发现如何做一些简单的命令，比如移动光标、在历史列表中上下移动、删除和复制单词。如果你不了解，你应该阅读 <code>zshzle</code> 手册页，以简明地了解它能做什么。这里是 Emacs 模式的摘要。</p>
<p>[]{#l80}</p>
<h3 id="421-移动"><a class="header" href="#421-移动">4.2.1: 移动</a></h3>
<p>你可以使用光标键在行上向前和向后移动。关于光标键产生什么按键序列，有各种不同的约定。你可能天真地期望按，比如说，右光标键，会发送一个类似于“右光标”的信号给应用程序。不幸的是，ASCII 字符集中没有这样的字符，所以像 zsh 这样将输入作为字符流读取的程序必须被给予一个任意的字符串。 （对于理解其他输入形式的程序，比如窗口系统，情况就不同了。）</p>
<p>光标键最常见的两种约定是，向上键发送 <code>\e[A</code>，其他三个键在末尾分别发送 <code>B</code>、<code>C</code> 和 <code>D</code>，以及用 <code>O</code>（大写字母 <code>O</code>）替换 <code>[</code> 的约定。在旧版本的 zsh 中，只支持这两种约定中的第一种。第二种以及任何其他约定都不被支持，你必须自己绑定键。这是通过类似以下的方式完成的：</p>
<pre><code>  bindkey "\eOA" up-line-or-history
  bindkey "\eOB" down-line-or-history
  bindkey "\eOC" forward-char
  bindkey "\eOD" backward-char
</code></pre>
<p>现在 shell 更加努力了，只要你的系统有关于你的终端的正确信息（zsh 使用一个名为“termcap”的旧系统，它在很大程度上已被另一个名为“terminfo”的系统所取代），你应该会很幸运。如果 shell 认为你的键太反常——特别是，如果它想要绑定函数的按键序列已经被 zsh 定义了——你仍然需要手动操作。上面的列表应该可以作为一个模板。</p>
<p>除了光标键，传统的 Emacs 键也可用：<code>^b</code> 和 <code>^f</code> 用于向后和向前，<code>^p</code> 和 <code>^n</code> 用于上一行和下一行，所以即使光标键不工作，你也可以继续。</p>
<p>移动更长的距离是通过 <code>\eb</code> 和 <code>\ef</code> 向后或向前移动一个单词（或者，如你所见，<code>\M-b</code> 和 <code>\M-f</code>），以及 <code>^a</code> 和 <code>^e</code> 用于行的开始和结束。这差不多就是你最常使用的那些了。</p>
<p>[]{#l81}</p>
<h3 id="422-删除"><a class="header" href="#422-删除">4.2.2: 删除</a></h3>
<p>对于删除，退格键或删除键会向后删除。由于 PC 键盘上中央键盘区左上角的键是“退格”，即字符 <code>^h</code>，而传统 UNIX 键盘上是“删除”，即字符 127，通常写为 <code>^?</code>（zsh 也理解），这两个键之间存在着永恒的争论。当你在系统的原始行编辑模式下时，就像 sh（除非你的 sh 实际上是 bash），只有一个是“绑定”的，尽管它不是真正的键绑定，而是由系统的终端驱动程序进行的转换，而且通常是错误的一个。因此你经常发现系统在你想要删除时在屏幕上打印 <code>^h</code>。你可以用</p>
<pre><code>  stty erase '^h'
</code></pre>
<p>来更改键，但 zsh 保护你免受所有这些——<code>^h</code>（退格）和 <code>^?</code>（删除）都会向后删除一个字符。顺便说一句，请注意，zsh 不理解任何按键的智能名称——如果你尝试绑定一个名为“backspace”的键，zsh 会将一个命令绑定到该字符序列，而不是该名称的键。请参阅关于 <code>bindkey -s</code> 的评论，了解什么时候这样做甚至可能有用。</p>
<p>更令人困惑的是，在 101 或 102 键 PC 键盘上，通常标记为“Delete”的键，在光标键上方的 6 个键组中，又完全不同，并且可能不发送这两个序列中的任何一个。在我的键盘上，它发送序列 <code>\e[3~</code>。我发现让它删除下一个字符很方便，这是它在 PC 世界中的传统角色，我通过</p>
<pre><code>  bindkey '\e[3~' delete-char
</code></pre>
<p>来做到这一点。然而，删除下一个字符的传统 <em>Emacs</em> 方式是使用 <code>^d</code>，zsh 默认为你绑定了它。如果你查看绑定，你可以通过不给 bindkey 一个要绑定的编辑器命令来做到这一点，</p>
<pre><code>  % bindkey '^d'
  delete-char-or-list
</code></pre>
<p>你会看到它<em>不完全</em>像我建议的那样。<code>-or-list</code> 部分是用于补全的，你将在下一章中了解它。我所知道的第一个有这种奇怪组合的 shell 是 tcsh。</p>
<p>既然我喜欢混淆，我不如指出，通常 <code>^d</code> 还有另一个用途，那就是告诉终端驱动程序你已经到达了文件的末尾。在，比如说，磁盘上的文件的情况下，系统自己知道这一点，但如果你正在提供一个字符流，告诉它的唯一方法是发送一个特殊字符。默认通常是 <code>^d</code>。你会注意到，如果你在行的开头输入 <code>^d</code>，你会看到消息</p>
<pre><code>  zsh: use 'exit' to exit.
</code></pre>
<p>那是因为 zsh 在那个位置将 <code>^d</code> 识别为文件结束。默认情况下，shell 会警告你；你可以通过设置 <code>IGNORE_EOF</code> 选项来关闭它。你可以告诉系统你永远不想以这种方式发送文件结束，再次使用 <code>stty</code>：以下在 Linux 中是等效的，但你的系统可能需要其中一个或另一个：</p>
<pre><code>  stty eof '^-'
  stty eof undef
</code></pre>
<p>记住 <code>stty</code> 不是 shell 的一部分；它是控制系统终端驱动程序状态的一种方式。这意味着只要终端或终端窗口仍然连接，它就会一直存在，即使你启动一个新的 shell 或退出一个不是登录 shell 的 shell。</p>
<p>顺便说一句，如果你需要通过其编号来引用一个字符，最简单的方法可能是使用语法 <code>\x??</code>，其中 <code>??</code> 是键的两个十六进制数字。在删除的情况下，它是 <code>\x7f</code>。你可以通过以下方式确认：</p>
<pre><code>  % bindkey '\x7f'
  "^?" backward-delete-char
</code></pre>
<p>[]{#l82}</p>
<h3 id="423-更多删除操作"><a class="header" href="#423-更多删除操作">4.2.3: 更多删除操作</a></h3>
<p>你可以用 <code>\ed</code> 删除下一个单词，用 <code>\e^h</code> 或 <code>\e^?</code>（escape 后跟向后删除）删除前一个单词。<code>^u</code> 通常会删除整行，光标前后都删除——这不像 Emacs，在 Emacs 中 <code>^u</code> 引入数字参数，我将在下一小节中描述。然而，它像终端驱动程序本身提供的另一个原始编辑命令，这个命令在 <code>stty</code> 中被称为 <code>kill</code>。在 zsh 之外，这个最常见的用途是在登录时删除你的密码，当你确定你输错了但又看不到你输了多少个 !@?*! 字符，并且可能无法依赖终端与你在哪个 <code>^h</code> 或 <code>^?</code> 会删除单个字符上达成一致时。</p>
<p>严格来说，上一段中的所有按键都执行“kill”（zsh 术语，不要与 <code>stty</code> 的“kill”混淆）而不是“delete”（或 deletion，当我们对名词化和动词化有区别时我们过去常说）。区别与 Emacs 中相同——“killed”的文本被保存起来以便以后“yank”回别处，你用 <code>^y</code> 键来做，而像 <code>^?</code> 和 <code>^d</code> 那样“deleted”的文本则永远消失了。这就是所有没有在 Emacs 下长大的人称之为“剪切”和“粘贴”的东西（尽管由于 Emacs 可以追溯到七十年代，也可能是其他所有人都错了）。从 Emacs 借来的另一个特性是，如果你在中间没有任何其他编辑的情况下进行多次“kill”，被 kill 的文本会连接在一起，你可以一次性将它们全部 yank 回来。当我谈到点和标记（另一个 Emacs 的想法）时，我会说更多。</p>
<p>实际上，即使是删除的文本也不会永远消失：zsh 有一个类似 Emacs 的编辑历史，你可以撤销行上的前一个命令。这通常绑定到 <code>^xu</code> 和 <code>^x^u</code>，还有一个更短的绑定，被相当令人困惑地描述为 <code>^_</code>——令人困惑，因为在我用过的所有不完全奇怪的键盘上，你实际上是通过按住 control 并按 <code>/</code> 键来生成该序列的。Zsh 默认不使用 <code>^z</code>，如果你习惯于 Windows，那是 <code>undo</code> 的另一个合适的绑定。</p>
<p>Zsh 在一个方面胜过 Emacs——它也有“redo”，默认未绑定。这意味着如果你撤销得太多，你可以通过重复使用 <code>redo</code> 命令来放回你刚刚撤销的东西。</p>
<p>[]{#l83}</p>
<h2 id="43-更高级的编辑-1"><a class="header" href="#43-更高级的编辑-1">4.3: 更高级的编辑</a></h2>
<p>[]{#l84}</p>
<h3 id="431-控制-zle-的选项"><a class="header" href="#431-控制-zle-的选项">4.3.1: 控制 zle 的选项</a></h3>
<p>与补全不同，<code>zle</code> 没有很多与之关联的选项；大多数控制是通过键绑定和内建命令完成的。只有两个真正有用；都控制哔哔声。<code>beep</code> 选项可以被取消设置，以告诉 shell 在出错时永远不要发出声音；<code>histbeep</code> 选项可以被取消设置，以仅在尝试返回到第一个历史条目之前或前进到最后一个历史条目之后的情况下禁用哔哔声。</p>
<p>不太有用的选项是 <code>zle</code> 和 <code>singlelinezle</code>。前者控制 zle 是否完全活动，并且不是那么有用，因为它通常在你需要时自动打开，换句话说，在交互式 shell 中，并在你不需要时关闭。然而，通过 <code>[[ -o zle ]]</code> 进行测试有时很有用；这让你可以在交互式 shell 中让一个函数做一些更聪明的事情。</p>
<p><code>singlelinezle</code> 选项将编辑限制在一行；如果它变得太长，它将被截断，并在缺少的部分打印一个 <code>$</code>。它只用于与 ksh 的兼容性，以及如果你的终端真的搞砸了，作为一个保障，尽管即使在这种情况下，zsh 也会尝试猜测它需要的一切是否可用。</p>
<p>影响 zle 的其他函数包括历史函数。这些在<a href="zshguide02.html#init">第二章</a>中已经描述过了；一旦你设置好它，在 zle 中搜索历史的工作方式与用 <code>!</code> 历史命令基本相同。</p>
<p>[]{#l85}</p>
<h3 id="432-minibuffer-和扩展命令"><a class="header" href="#432-minibuffer-和扩展命令">4.3.2: minibuffer 和扩展命令</a></h3>
<p>“minibuffer”是另一个 Emacs 的概念；它是一个出现在命令行正下方的提示，供你输入编辑器本身需要的一些编辑。通常，它随心所欲地来来去去，你不需要考虑它。最常见的用途是输入搜索文本，以及输入一个没有绑定到字符串的命令。这又是另一个 Emacs 的特性：<code>\ex</code> 提示你输入一个命令的名称。幸运的是，由于名称往往相当长，补全是可用的。所以输入 <code>echo foo&lt;ESC&gt;xba&lt;TAB&gt;w&lt;TAB&gt;</code> 最终会得到：</p>
<pre><code>  % echo foo
  execute: backward-word
</code></pre>
<p>然后按回车执行该函数，带你到 <code>foo</code> 的开头；你可能能想到更容易的方法来做到这一点。这确实提供了一种运行你不经常使用的命令的方法。</p>
<p>（我希望我的表示法不会太令人困惑。当我显示你按下的单个字符时，我会写成 <code>&lt;TAB&gt;</code>，以使其与周围的文本区分开来。然而，当我不显示正在输入的文本时，我会写成 <code>\t</code>，这是你将字符输入到要绑定的键序列或要打印的字符串中的方式。）</p>
<p>minibuffer 只处理非常有限的一组编辑命令。输入一个它不理解的命令通常会退出你正在用 minibuffer 做的任何事情，然后执行该按键。然而，在这种特殊情况下，它不会让你退出，直到你输完一个命令；你唯一的其他选择是中止。通常的 zle 中止字符是 <code>^g</code>，<code>send-break</code>。这与更激烈的 <code>^c</code> 不同，后者向 shell 本身发送一个中断信号。然而，在 zle 中，它们通常有相同的效果。（你会注意到 <code>^c</code> 实际上“绑定到 <code>undefined-key</code>”，换句话说，zle 不认为它做任何事情。然而，终端驱动程序可能会导致它发送一个中断，而 zle 确实会对此做出响应。）</p>
<p>另一个对罕见命令有用的特性是 <code>where-is</code>。惊喜！它默认没有绑定，所以输入 <code>&lt;ESC&gt;xwhere-is</code> 是运行它的方式。然后你在 <code>Where is:</code> 提示符下输入另一个编辑器命令，shell 会告诉你哪些按键（如果有的话）绑定到了它。你也可以简单地对 <code>bindkey</code> 的输出使用 <code>grep</code>，<code>bindkey</code> 在没有参数的情况下会列出所有绑定。</p>
<p>[]{#l86}</p>
<h3 id="433-前缀数字参数"><a class="header" href="#433-前缀数字参数">4.3.3: 前缀（数字）参数</a></h3>
<p>许多命令可以通过给它们一个数字前缀或数字参数来重复。例如，在一长串文本的末尾，输入 <code>&lt;ESC&gt;4&lt;ESC&gt;b</code>。单独的 <code>&lt;ESC&gt;b</code> 会让你向后移动一个单词。<code>&lt;ESC&gt;4</code> 给它传递了数字四，它就向后移动四个单词。一般来说，只要重复一个命令有意义，这都有效。它也对 <code>self-insert</code> 有效，只是重复插入字符。如果它不起作用，前缀参数就会被简单地忽略。</p>
<p>你可以通过重复 <code>\e</code> 和它后面的数字或 <code>-</code> 来构建长参数或负参数；例如，<code>&lt;ESC&gt;-&lt;ESC&gt;1&lt;ESC&gt;0</code> 指定负十。负数有多大用处因命令而异，但它们通常会从后退切换到前进或类似：<code>&lt;ESC&gt;-&lt;ESC&gt;4&lt;ESC&gt;\f</code> 是执行与 <code>&lt;ESC&gt;4&lt;ESC&gt;b</code> 相同操作的无意义方式。</p>
<p>shell 也有 Emacs 的“universal-argument”特性，但它默认没有绑定——在 Emacs 中是 <code>\C-u</code>，但正如我们所见，那已经被占用了。这是所有那些转义的替代方案。如果你将该命令绑定到一个按键（否则它作为快捷方式绝对没有意义），并输入该键，那么一个可选的减号后跟任何数字都会被记作一个前缀。下一个不是这些之一的按键然后作为命令执行，带有在 <code>universal-argument</code> 后输入的数字形成的前缀。</p>
<p>例如，在我的键盘上，<code>F12</code> 键发送键序列 <code>\e[[24~</code>——参见下面了解如何找出功能键发送什么。因此我使用</p>
<pre><code>  bindkey '\e[[24~' universal-argument
</code></pre>
<p>然后如果我按 <code>F12</code>、<code>4</code>、<code>0</code>、<code>a</code>，一行四十个“a”就会被插入到命令行中。我不是说这个例子特别有用。</p>
<p>[]{#l87}</p>
<h3 id="434-单词区域和标记"><a class="header" href="#434-单词区域和标记">4.3.4: 单词、区域和标记</a></h3>
<p>在 zsh 中，单词的处理方式与大多数编辑器有点不同。首先，Emacs 模式和 vi 模式认为的单词之间有区别。也就是说，在这些模式下默认绑定的函数之间有区别；你可以通过重新绑定键在任一模式下使用相同的函数。</p>
<p>在 vi 和 Emacs 模式中，无论你是向前还是向后移动若干个单词，还是删除或剪切它们，关于单词的逻辑都适用；剪切时移除的文本量与光标在其他情况下移动的量相同。</p>
<p>在 vi 模式下，单词基本上与 vi 认为的单词相同：一串字母数字字符加上下划线——本质上，可以出现在标识符中的字符，实际上 zsh 内部就是这样识别 vi 的“单词字符”的。然而，关于 vi 的逐词行为有一个轻微的怪癖，你可以很容易地看到，如果你输入 <code>/a/filename/path/</code>，用 <code>ESC</code> 离开插入模式，然后用 <code>w</code> 或 <code>b</code> 在它上面逐词前进或后退。它会在移动单词中的字符和移动分隔符 <code>/</code> 中的字符之间交替。</p>
<p>然而，在 Emacs 中，做法有点不同。vi 的“单词字符”总是被认为是单词的一部分，但有一个参数 <code>$WORDCHARS</code>，它给出了一个<em>也</em>是单词一部分的字符的字符串。这可能与你期望的相反；鉴于字母数字总是单词的一部分，你可能会期望有一个参数，你可以向其中添加你<em>不</em>希望成为单词一部分的字符。但事实并非如此。</p>
<p>也与 vi 不同，跳过一个单词总是意味着跳到单词开头的单词字符。在跳过非单词字符时没有额外的“回合”用完。</p>
<p><code>$WORDCHARS</code> 的默认值是</p>
<pre><code>  *?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;
</code></pre>
<p>即，几乎所有东西和厨房水槽。因此，你通常会想要移除你不想被认为是单词一部分的字符；<code>-</code>、<code>/</code> 和 <code>.</code> 是特别可能的可能性。如果你想移除单个字符，你可以用一些模式匹配的技巧来做到（下一章）：</p>
<pre><code>  % WORDCHARS=${WORDCHARS//[&amp;.;]}
  % print $WORDCHARS
  *?_-[]~=/!#$%^(){}&lt;&gt;
</code></pre>
<p>显示该操作已从 <code>$WORDCHARS</code> 中移除了组中的那三个字符，即 <code>&amp;</code>、<code>.</code> 和 <code>;</code>。<code>//</code> 表示全局替换：方括号中的任何字符都被替换为空。</p>
<p>许多其他行编辑器，即使是像 <code>readline</code> 这样有 Emacs 绑定的，其行为也好像只有标识符字符是单词的一部分，即好像 <code>$WORDCHARS</code> 是空的。用一个 zle shell 函数做到这一点非常容易。最近版本的 zsh 提供了 <code>bash-forward-word</code>、<code>bash-kill-word</code> 以及一系列其他类似的函数，供你绑定到键上以获得那种行为。</p>
<p>通过编写函数，其他行为也是可能的；例如，你可以通过使用一些更多的替换技巧来跳过真正的 shell 单词（即单个命令参数），或者你可以只考虑以空格分隔的单词（尽管这与你通过向 <code>$WORDCHARS</code> 添加 <code> </code>"<code>'@ </code> 得到的结果相差不远）。</p>
<p>[]{#l88}</p>
<h3 id="435-区域和标记"><a class="header" href="#435-区域和标记">4.3.5: 区域和标记</a></h3>
<p>另一个来自 Emacs 的有用概念是区域和标记。在 Emacs 术语中，“点”是光标所在的位置，“标记”是你留下一个标记以便以后回来的地方。在当前点设置标记的命令是 <code>^@</code>，就像在 Emacs 中一样，这是一个象形文字，通常意味着按住 control 键并按空格键。在某些系统上，比如某个著名的非 UNIX 窗口系统提供的有限版本的 <code>telnet</code>，你无法发送这个序列，你需要将一个不同的序列绑定到 <code>set-mark-command</code>。一种可能性是 <code>\e </code>（escape 后跟空格），就像在 MicroEMACS 中一样。（一些 X Windows 配置也不允许 <code>^@</code> 在 xterm 中工作，尽管这通常是可以修复的。）</p>
<p>继续使用 Emacs 的语言，点和标记之间的区域被简单地描述为“区域”。在 zsh 中，你不能像你可能习惯于在直接在窗口系统下运行的编辑器中那样高亮显示这个区域，所以找出区域两端最简单的方法是使用 <code>^x^x</code>，<code>exchange-point-and-mark</code>，我之前提到过——默认情况下，标记留在行的开头，因此你看到了上面的行为。</p>
<p>各种编辑命令——通常是那些名称中带有“region”的命令——都作用于此。最常见的是那些剪切或复制区域的命令。令人烦恼的是，<code>kill-region</code> 没有被绑定——在 Emacs 中，它是 <code>^w</code>，但 zsh 遵循传统，将其绑定到 <code>backward-kill-word</code>，尽管那也可以通过传统的 Emacs 绑定 <code>\e^?</code> 来获得。所以重新绑定它可能很有用。要复制区域，通常的绑定 <code>\ew</code> 是有效的。</p>
<p>然后你用 <code>^y</code> 在另一点“粘贴”回复制或剪切的文本。shell 实现了“剪切环”功能，这意味着如果你执行一次粘贴，然后重复输入 <code>&lt;ESC&gt;y</code> (<code>yank-pop</code>)，shell 会循环回到以前剪切或复制的文本，这样你可用的就不止最后一个了。</p>
<p>[]{#l89}</p>
<h2 id="44-历史和搜索"><a class="header" href="#44-历史和搜索">4.4: 历史和搜索</a></h2>
<p>Zle 可以访问保存在 shell 历史中的行，如<a href="zshguide02.html#init">第二章</a>中的“设置历史”所述。基本上有三种方法可以检索历史的片段：逐行向后移动，向后搜索匹配的行，以及从历史中提取单个单词。实际上，前两种非常相似，并且有混合命令，允许你一步一步地向后移动，但仍然只匹配特定的行。</p>
<p>[]{#l90}</p>
<h3 id="441-在历史中移动"><a class="header" href="#441-在历史中移动">4.4.1: 在历史中移动</a></h3>
<p>最简单的行为是你用普通光标键绑定得到的那种，<code>up-line-or-history</code> 和 <code>down-line-or-history</code>。如果你在适合单行的文本中（这可能是一个续行，即行首有一个由 <code>$PS2</code> 给出的新提示），这会将整行替换为历史中的前一行或后一行。历史不是循环的，它有开始和结束。开始是 shell 仍然记住的第一行（即 <code>$HISTSIZE</code> 行之前，考虑到实际存在的行数会因你设置的任何特殊历史选项以删除不需要的行而修改）；结束是你正在输入的行。你可以使用 <code>\e&lt;</code> 和 <code>\e&gt;</code> 转到历史的第一行和最后一行。</p>
<p>最后一句话听起来微不足道，但并非如此。输入 <code>echo 这是最后一行</code>，用向上箭头返回几行，然后再向下回到末尾，你会明白我的意思——shell 记住了你正在输入的行，即使它还没有被输入，所以你可以上下滚动历史，仍然可以回到它。</p>
<p>当然，你可以编辑任何早期的历史行，然后按“回车”执行它们——这就是能够回滚历史的全部意义所在。可能不那么明显的是，shell 也会记住你对这些行所做的更改，直到你按“回车”。</p>
<p>例如，在一个新的 shell 提示符下输入 <code>echo this is the last line</code>，但不要按回车。现在按一次向上箭头，并将前一行编辑为 <code>echo this is the previous line</code>。如果你上下滚动，你会看到 shell 保留了这两行。当你决定使用哪一行并按回车时，该行被执行并添加到历史的末尾，对历史中前几行的任何更改都会被忘记。</p>
<p>有时你不想向历史添加新行，而是想逐个重新执行一系列早期的命令。这可以用 <code>^o</code>，<code>accept-line-and-down-history</code> 来完成。当你在历史中的一行上按 <code>^o</code> 时，该行被执行，历史中的下一行被显示。所以你只需要一直按它来继续执行命令。</p>
<p>还有两个我用得不多的类似命令，<code>infer-next-history</code>，绑定到 <code>^x^n</code>，和 <code>accept-and-infer-next-history</code>，默认未绑定。“推断”下一个历史意味着 shell 查看当前行中的内容，无论其来源如何——例如，你可能刚刚输入了它——并在历史中向后查找匹配的行；“推断”的下一个历史行是该行之后的行。在第一种情况下，你只是被显示那一行；在第二种情况下，当前行首先被执行，然后你被显示推断的行。如果你发现这是自切片面包以来最好的东西，请随时给我写信。</p>
<p>关于历史的一个轻微混淆是，很难记住你到底在历史的哪个位置，例如，如果你正在编辑一行，并且不得不回滚以寻找其他东西。在这种情况下，<code>\e&gt;</code> 是你的朋友，因为它会带你到最后一行。此外，无论何时你按回车，你都保证在历史的末尾，即使你正在编辑历史中靠前的某一行，不像某些其他系统（尽管 <code>accept-line-and-down-history</code> 可以模拟那些）。所以通常不难保持对你正在编辑的内容不感到困惑。</p>
<p>[]{#l91}</p>
<h3 id="442-搜索历史"><a class="header" href="#442-搜索历史">4.4.2: 搜索历史</a></h3>
<p>Zsh 有你期望的搜索历史的命令，即你按一个搜索键，然后输入要搜索的单词。然而，它还有其他功能，可能 zsh 社区用得更多，其中搜索是基于当前行的某个特征，特别是第一个单词或光标位置之前的行。这些通常使你能够更快地向后搜索，因为你不需要告诉 shell 你在寻找什么。</p>
<p><strong>普通搜索</strong>\</p>
<p>标准的搜索命令，我指的是你可能从普通文本编辑器（如果 Emacs 或 vi 可以这样称呼的话）中最熟悉的那些，旨在让 Emacs 和 vi 用户感到宾至如归。</p>
<p>在 Emacs 模式下，你有增量搜索：<code>^r</code> 向后搜索——这通常是你想要的，因为你通常从末尾开始——和 <code>^s</code> 向前搜索。请注意，<code>^s</code> 是另一个经常被终端驱动程序拦截的按键；在这种情况下，它通常会冻结终端的输出，直到你输入 <code>^q</code> 重新打开它。如果你不喜欢这样，你要么可以使用 <code>stty stop</code> 和 <code>stty start</code> 来更改字符，要么简单地 <code>unsetopt flowcontrol</code> 来完全关闭该功能。然而，绑定到 <code>^s</code> 的命令 <code>history-incremental-search-forward</code> 也绑定到 <code>^xs</code>，所以你可以用那个代替。</p>
<p>就像在 Emacs 中一样，对于你输入的每个字符，增量搜索都会带你到与所有字符匹配的最近的历史条目，直到匹配失败。在任何时候再次输入搜索按键都会带你到 minibuffer 中字符的下一个匹配项。</p>
<p>在 vi 命令模式下，默认可用的按键是熟悉的 <code>/</code> 和 <code>?</code>。然而，与 vi 有各种不同之处。首先，是 <code>/</code> 向后搜索——这是你会更经常使用的那个。其次，你不能搜索正则表达式（模式）；唯一的例外是行首的 <code>^</code> 将搜索锚定到行首。其他一切都只是纯字符串。</p>
<p>另外两个标准的 vi 搜索按键也存在：<code>n</code> 搜索当前字符串的下一个匹配项，<code>N</code> 做同样的事情，但反转搜索方向。</p>
<p><strong>按第一个单词搜索</strong>\</p>
<p>下一种搜索可能是最常用的，但只在 Emacs 模式下绑定：<code>\ep</code> 和 <code>\en</code> 向前或向后搜索与当前行第一个单词相同的下一个历史行。所以通常要重用一个命令，你只需输入命令名称本身，然后按 <code>\ep</code> 直到你想要的命令行出现。这些命令被简单地称为 <code>history-search-backward</code> 和 <code>history-search-forward</code>；这个名称并不能很好地描述其功能。</p>
<p><strong>前缀搜索</strong>\</p>
<p>最后，你可以向后搜索一个从开头到光标位置与当前行完全相同的行。这比 <code>history-search-</code><em>direction</em> 给你更多的控制。相应的命令，<code>history-beginning-search-backward</code> 和 <code>history-beginning-search-forward</code>，默认没有绑定。我发现将它们绑定到 <code>^xp</code> 和 <code>^xn</code> 很有用，因为这与初始单词搜索类似：</p>
<pre><code>  bindkey '^xp' history-beginning-search-backward
  bindkey '^xn' history-beginning-search-forward
</code></pre>
<p><strong>其他基于函数的搜索命令</strong>\</p>
<p>搜索命令是最常通过编写 shell 函数来定制的类型之一。最新版本的 shell 提供了一些；请查看 <code>zshcontrib</code> 手册页的 ZLE 部分。你应该能在你的 <code>$fpath</code> 中的某个地方找到函数本身，通常是</p>
<pre><code>  /usr/local/share/zsh/$ZSH_VERSION/functions
</code></pre>
<p>或该目录的子目录 <code>Zle</code>，取决于你的 zsh 版本是如何安装的。如果 shell 是预装的，最可能的位置是</p>
<pre><code>  /usr/share/zsh/$ZSH_VERSION/functions/Zle
</code></pre>
<p>这些应该能指导你编写自己的。</p>
<p>需要注意的一点是，当从函数调用时，<code>history-search-</code><em>direction</em> 和 <code>history-incremental-search-</code><em>direction</em> 可以接受一个字符串参数，指定要搜索的内容。在第一种情况下，这只是一次性搜索，而在第二种情况下，你保持在增量搜索中，并且该字符串用于填充 minibuffer，所以你可以编辑它。我稍后会更多地讲关于编写 zle 函数，但从用户定义的编辑函数中调用一个搜索命令就像这样简单：</p>
<pre><code>  zle history-search-backward search-string
</code></pre>
<p>你可以测试返回状态以查看搜索是否成功。</p>
<p>[]{#l92}</p>
<h3 id="443-从历史中提取单词"><a class="header" href="#443-从历史中提取单词">4.4.3: 从历史中提取单词</a></h3>
<p>有时，你不想编辑前一行，只想从中提取一个单词到当前行。如果这个单词是行尾的最后一个，并且该行在历史中不远，这就特别容易：只需重复按 <code>\e.</code>，shell 就会循环浏览前几行上的最后一个单词。你可以给它一个前缀参数，以从你上次挑选单词的那一行上面的那一行中挑选第 <em>N</em> 个倒数单词。正如你从描述中可以看出的，这有点棘手；shell 的 4.1 版本可能会提供一个稍微更灵活的版本。</p>
<p>虽然这严格来说与历史无关，但你可以用 <code>copy-prev-word</code> 复制当前行上的前一个单词，由于某种原因，它被绑定到 <code>\e^_</code>，即 escape 后跟（可能）control 和斜杠。我把它绑定到 <code>\e=</code>（在某些版本的 ksh 中，该键序列被 <code>list-choices</code> 的等价物占用）。这会复制以空白分隔的单词，但你可以通过使用 <code>copy-prev-shell-word</code> 来复制 shell 会看作是前一个完整参数的内容。这个默认没有绑定，因为它比另一个新，但它可以说更有用。</p>
<p>有时你想从历史中补全一个单词；这可以使用补全系统来完成，下一章会描述。</p>
<p>[]{#l93}</p>
<h2 id="45-绑定键和处理键映射"><a class="header" href="#45-绑定键和处理键映射">4.5: 绑定键和处理键映射</a></h2>
<p>在键绑定这个标题下有两个主题要讲：首先，如何绑定键本身，其次，键映射以及如何使用它们。操作键绑定和键映射都是用 <code>bindkey</code> 命令完成的。第一个主题更直接有用，所以我先从那个开始。</p>
<p>[]{#l94}</p>
<h3 id="451-简单键绑定"><a class="header" href="#451-简单键绑定">4.5.1: 简单键绑定</a></h3>
<p>你已经看到了 <code>bindkey</code> 的基本用法，用于将编辑命令链接到一个特定的键序列。你已经看到了命名键的简写，用 <code>\e</code> 表示 escape，<code>^x</code> 表示按住 control 键时按下的字符 <code>x</code>。我甚至提到了一些关于“meta”键绑定的事情。</p>
<p>现在让我更详细地讲一下。当你绑定一个键序列时，你用 <code>bindkey</code> <em>key-sequence</em> <em>editor-command</em> 来做，<em>key-sequence</em> 可以包含任意多个字符。即使键序列的某个初始集合已经被绑定了，也（几乎）没关系。例如，你可以做，</p>
<pre><code>  bindkey '\eA' backward-word
  bindkey '\eAA' beginning-of-line
</code></pre>
<p>在这里，我将遵循 shell 文档，将 <code>\eA</code> 称为 <code>\eAA</code> 的前缀。</p>
<p>这引入了两点。首先，请注意 <code>\eA</code> 的绑定与 <code>\ea</code> 的绑定是不同的；你会看到后者仍然执行 <code>accept-and-hold</code>（在 Emacs 模式下），这意味着它执行当前行，然后把它还给你编辑——这对于做很多非常相似的任务很有用。同时，<code>\eA</code> 带你向后一个单词。</p>
<p>这种大小写敏感性只适用于本身就是一个完整键的字母字符，而不适用于按住 control 键的那些字符——<code>^x</code> 和 <code>^X</code> 是相同的。（你可能发现在 Emacs 中，在窗口系统下运行时有办法分别绑定两者，因为窗口系统可以告诉 Emacs shift 键是否与其他键一起按住；如果你使用的是普通终端，那就没那么简单了。）</p>
<p>如果你输入了那两个 <code>bindkey</code> 命令，你可能会注意到在 <code>\eA</code> 生效之前有一个短暂的停顿。那是因为它在等待看你是否会输入另一个 <code>A</code>。如果你在那次停顿期间确实输入了额外的 <code>A</code>，你将被带到行的开头。那个停顿是 shell 决定是否单独执行前缀的方式。</p>
<p>它等待的时间是可配置的，由参数 <code>$KEYTIMEOUT</code> 给出，这是以百分之一秒为单位的延迟。默认是 40，即十分之四秒。它的使用通常取决于个人偏好；如果你打字不快，你可能想增加它，代价是在等待前缀执行时有更长的延迟。如果你在非常慢的链接上远程编辑机器，你也可能需要增加它，以便能够让具有这样前缀的完整键序列正常工作。</p>
<p>然而，只有当前缀本身被绑定时，shell 才会有这种矛盾的行为；如果初始的一个或多个键本身没有任何意义，它会一直等你输入一个被绑定的完整序列。这是迄今为止最正常的情况。唯一常见的单独绑定前缀的例子是在 vi 插入模式下，其中 <code>&lt;ESC&gt;</code> 带你回到命令模式，而可能还有其他以 <code>\e</code> 开头的绑定，比如光标键。我们将在下面看到如何移除那些如果它们冒犯了你的 vi 纯粹感。（别笑，vi 用户很奇怪。）</p>
<p>请注意，如果整个序列毕竟没有被绑定，shell 会在它读到一个不再是前缀的完整键序列后立即中止。例如，如果你输入 <code>\e[</code>，很可能 shell 还在等待更多，但如果你加上一个 <code>/</code>，比如说，它可能会认为你在胡闹并中止。你输入的下一个键然后开始一个新的序列。</p>
<p>[]{#l95}</p>
<h3 id="452-移除键绑定"><a class="header" href="#452-移除键绑定">4.5.2: 移除键绑定</a></h3>
<p>如果你想移除一个键绑定，你可以简单地将它绑定到别的东西上。几乎所有 <code>bindkey</code> 和 <code>zle</code> 命令的用法在处理这种情况时都很聪明，会自动移除死木。然而，你也可以使用 <code>bindkey -r</code> <em>key-sequence</em> 来明确地移除绑定。你也可以简单地将序列绑定到 <code>undefined-key</code> 命令；这有完全相同的效果——甚至可以完全修剪掉任何长序列的绑定。例如，假设你将 <code>\e\C-x\C-x</code> 绑定到一个命令，然后又绑定到 <code>undefined-key</code>。所有关于 <code>\e\C-x\C-x</code> 曾被绑定的记忆都会被移除；<code>\e\C-x</code> 将不再被标记为前缀键，除非你还有其他以该前缀开头的绑定。</p>
<p>你可以通过添加 <code>-p</code> 选项来移除以给定前缀开头的所有绑定。手册中给出的例子，</p>
<pre><code>  bindkey -rpM viins '\e'
</code></pre>
<p>（除了它使用了等效形式 <code>^[</code>）是最有用的之一，因为它将移除你在输入 <code>\e</code> 以进入 vi 命令模式后烦人的延迟。延迟是因为光标键通常也以 <code>\e</code> 开头，shell 在等待看你是否实际输入了其中一个。所以如果你能在 vi 插入模式下不用光标键，你可能想考虑这个。</p>
<p>请注意，前缀本身的任何绑定都不会被移除。在这个例子中，<code>\e</code> 在 <code>viins</code> 键映射中保持其原来的绑定，大概是 <code>vi-cmd-mode</code>。</p>
<p>所有像这样的操作都特定于一个特定的键映射。你需要用不同的 <code>-M</code> <em>...</em> 选项参数重复它们，才能在其他键映射中产生相同的效果，这将在下面描述。</p>
<p>[]{#l96}</p>
<h3 id="453-功能键等"><a class="header" href="#453-功能键等">4.5.3: 功能键等</a></h3>
<p>[]{#fkeys}</p>
<p>通常可以绑定你键盘上的功能键，包括像“Home”和“Page Up”这样的特殊命名的键。这在很大程度上取决于你的窗口系统或终端驱动程序如何处理它们，但如今，一个设置良好的系统几乎总是允许功能键向终端发送一个字符串。要绑定这些键，你需要找出那个字符串是什么。</p>
<p>幸运的是，你通常会得到帮助，因为字符串的第一个字符通常是“奇怪的”，即它做的不是插入一个字符。所以有一个技巧可以找出这个序列是什么。在一个 shell 窗口中，按 <code>^v</code>（如果你使用 vi 绑定，你需要处于插入模式），然后按有问题的功能键。你可能会看到一个像 <code>^[OP</code> 这样的字符串——这是我从 F1 键得到的。我的 <code>.zshrc</code> 中的一个注释表明我曾经得到 <code>\e[11~</code>，所以即使你像我一样使用标准的 xterm 终端模拟器，也要准备好会有所不同。对这个 Linux/GNU/XFree86 系统上的终端模拟器进行快速调查表明，这两种可能性是迄今为止最受欢迎的。</p>
<p>你甚至可能通过同时按住 shift 或 control 来得到不同的序列（当然，是在按 <code>^v</code> 之后）。在我的键盘上，将 F1 与 shift 组合会给我 <code>^[O2P</code>，与 control 组合会给我 <code>^[O5P</code>，两者都按会给我 <code>^[O6P</code>。同样，你的系统可能会做完全不同的事情。</p>
<p>如果你将光标移回那个 <code>^[</code>，你会发现它是一个单一的字符——你可以将光标定位在 <code>^</code> 上，但不能定位在 <code>[</code> 上。这是 zsh 将一个真实的、活生生的转义字符插入到行中的方式。事实上，如果你输入</p>
<pre><code>  bindkey '
</code></pre>
<p>然后是 <code>^v</code>，功能键，和另一个单引号，你就有一种在命令行上绑定该键的完全可接受的方式。Zsh 通常对你使用不可打印字符相当宽松；它们可能不会在你的终端上正确显示，但 shell 能够处理所有单字节字符。然而，它还不支持超过单字节的字符。</p>
<p>你也可以在你的 <code>.zshrc</code> 中做同样的事情；shell 会毫无怨言地处理输入中的奇怪字符。你也可以使用两个字符 <code>^[</code>，这只是输入转义键的另一种方式。然而，合乎规矩的做法是将其变成 <code>\e</code>。例如，</p>
<pre><code>  bindkey '\e[OP'  where-is           # F1
  bindkey '\e[O2P' universal-argument # shift F1
</code></pre>
<p>等等。使用这个，你可以给“Home”、“End”等赋予合理的含义。注意窗口系统避免前缀问题的明智方式——任何额外的字符都插入在最后一个字符之前，所以 shell 可以很容易地判断序列何时完成，而不必等待看是否还有更多。</p>
<p>Zsh 提供了一个名为 <code>zkbd</code> 的实用程序，它可以通过为你找出并记住定义来帮助处理所有这些。你可能只需自动加载并运行它就可以使用它，因为它通常与其他函数一起安装。它应该相当不言自明，否则请查阅 <code>zshcontrib</code> 手册。</p>
<p>如果你正在使用 X Windows 并且受过足够的教育，你可以修改你的 <code>.Xdefaults</code> 文件来调整终端模拟器如何解释键。例如，以下内容将任何使用“VT100 小部件”（这是 xterm 通常操作模式的基础）的东西中的退格键变成删除键：</p>
<pre><code>  *VT100.Translations: #override \ 
  &lt;Key&gt;BackSpace: string(0x7F)
</code></pre>
<p>展示这个的部分原因是为了让 zsh 的键绑定系统相比之下看起来非常精简。然而，在这个层面上进行修改可以让你对键修饰符（shift、alt、meta、control，如果你幸运的话甚至可能是 super 和 hyper）的使用有更多的控制。这远远超出了本指南的范围——正如你现在可能意识到的，我说这个是为了掩盖我对它知之甚少。不过，这里有另一个来自 Oliver Kiddle 的例子；它使用 control 和左光标键来发送一个转义序列：插入</p>
<pre><code>  Ctrl&lt;Key&gt;Left: string(0x1b) string("[159q") \
</code></pre>
<p>\</p>
<p>到上面例子的中间——这显示了如何处理多个定义。现代的 xterm 已经发送了特殊的转义序列，你可以像我描述的那样去研究和绑定。</p>
<p>[]{#l97}</p>
<h3 id="454-绑定字符串而不是命令"><a class="header" href="#454-绑定字符串而不是命令">4.5.4: 绑定字符串而不是命令</a></h3>
<p>通过给 <code>bindkey</code> <code>-s</code> 选项，可以将任意字符串绑定到一个键序列，而不是一个编辑器命令。这样做的一个好处是，字符串会被 zle 重新解释，所以它们可以包含活动的键序列。在过去，这经常被用作一种基本的宏形式，用来串联编辑器命令。例如，以下是通过重复 Emacs 模式绑定来向后移动两个单词的简单方法。我再次使用了我的 F1 绑定；你的可能完全不同。</p>
<pre><code>  bindkey -s '\e[OP' '\eb\eb'
</code></pre>
<p>将一个键序列绑定到包含其自身的另一个字符串不是一个好主意。</p>
<p>这种方法有一个明显的缺点，如果有人来重新绑定 <code>\eb</code>，那么 F1 也会停止工作。如今，这类任务可以通过编写用户定义的小部件来更灵活、更清晰地完成，这将在后面的部分描述。所以这类绑定有点过时了。然而，它们确实提供了快速的快捷方式。来自 Oliver Kiddle 的两个例子：</p>
<pre><code>  bindkey -s '^[[072q' '^V^I'                       # Ctrl-Tab
  bindkey -s "\C-x\C-z" "\eqsuspend\n"
</code></pre>
<p>你也可以很容易地做一些你可以用全局别名做的事情。</p>
<p>记住，“普通”字符也可以被重新绑定；它们只是通常碰巧有一个使它们被直接插入的绑定。作为一个特别无意义的例子，考虑：</p>
<pre><code>  bindkey -s secret 'Oh no!'
</code></pre>
<p>如果你足够快地输入 <code>secret</code>，这些字母会被吞掉，而 <code>Oh no!</code> 会出现。如果你在中间停顿足够长的时间，这个词就会像平常一样被插入。那是因为它的所有部分都可以被解释为它们自己的前缀，所以 <code>$KEYTIMEOUT</code> 在每个中间阶段都适用。不那么无意义的是，你可以用这个作为定义缩写的一种方式。</p>
<p>[]{#l98}</p>
<h3 id="455-键映射"><a class="header" href="#455-键映射">4.5.5: 键映射</a></h3>
<p>到目前为止，我所说的关于键映射的全部内容是，有三个标准的，一个用于 Emacs 模式，两个用于 vi 模式，并且 <code>bindkey -e</code> 和 <code>bindkey -v</code> 选择 Emacs 或 vi 插入模式绑定。没有简单的方法可以选择 vi 命令模式绑定，因为那通常不是直接可用的，而是通过 <code>vi-cmd-mode</code> 命令进入的，通常绑定到 vi 插入模式下的 <code>\e</code>。（有一个 <code>bindkey -a</code>，但那不选择用于正常使用的键映射；它等同于，但不如 <code>bindkey -M vicmd</code> 清晰。）</p>
<p>大多数对键映射的处理都是通过 <code>bindkey</code> 完成的。键映射有短名称，<code>emacs</code>、<code>viins</code> 和 <code>vicmd</code>，用于 <code>bindkey</code>。还有一个键映射 <code>.safe</code>，你通常不需要，但它永远不会改变，所以如果你的实验完全毁了所有其他键映射，你可以使用它。它只有 <code>self-insert</code>（大多数键）和 <code>accept-line</code>（<code>^j</code> 和 <code>^m</code>）的绑定，但这足以输入命令。</p>
<p>这些名称在两个地方最有用。首先，你可以使用 <code>bindkey -M</code> <em>keymap</em> 来在特定的映射中定义键：</p>
<pre><code>  bindkey -M vicmd "\e[OA" up-line-or-history
</code></pre>
<p>在 <code>vicmd</code> 模式下绑定通常的向上光标键，无论当前设置了哪个键映射。实际上，任何理解 <code>-M</code> 选项的 shell 版本可能都已经绑定了那个。</p>
<p>其次，你可以强制 zle 使用一个特定的键映射。这是以一种稍微不明显的方式完成的：zle 总是使用键映射 <code>main</code> 作为当前键映射（除非它在 vi 命令模式下关闭，那里的处理有点特殊）。要使用你自己的，你需要用 <code>bindkey -A</code> 使 <code>main</code> 成为它的一个别名。这之后的顺序与 <code>ln</code> 之后的顺序相同：你想要引用的现有键映射排在第一位，然后是你想要为它创建别名的东西，在这种情况下是 <code>main</code>。这意味着</p>
<pre><code>  bindkey -A emacs main
</code></pre>
<p>与</p>
<pre><code>  bindkey -e
</code></pre>
<p>有相同的效果，但更明确，如果有点巴洛克的话。不要将 <code>vicmd</code> 链接到 main，因为那样你就不能使用 <code>viins</code>，这很糟糕。请注意，<code>bindkey -M emacs</code> 没有这个效果；它只是列出 <code>emacs</code> 键映射中的绑定。</p>
<p>你也可以创建自己的键映射。最简单的方法是复制一个现有的键映射，比如</p>
<pre><code>  bindkey -N mymap emacs
</code></pre>
<p>它创建（或替换）<code>mymap</code> 并用 <code>emacs</code> 的绑定来初始化它。现在你可以像使用 <code>emacs</code> 一样使用 <code>mymap</code>。每个中的绑定是完全独立的。如果你用完了一个键映射，你可以用 <code>bindkey -D keymap</code> 来移除它，尽管你最好先确保它没有链接到 <code>main</code>。</p>
<p>你可以省略 <code>emacs</code> 来创建一个空的键映射；如果你的键映射只会在某些特殊的地方使用，并且你想要完全控制其中的内容，这可能是合适的。然而，目前 shell 在让你只在某些地方应用你自己的键映射方面做得不是很好。</p>
<p>你可能会遇到各种其他在特殊情况下使用的键映射。如果你列出所有键映射，这是通过 <code>bindkey -l</code> 完成的，你可能会看到 <code>listscroll</code> 和 <code>menuselect</code>。这些被新的补全系统使用，所以如果那个没有激活，你可能不会看到它们。它们存在于模块 <code>zsh/complist</code> 中。关于它们的效果，<a href="zshguide06.html#comp">第六章</a>中会有更多内容；<code>listscroll</code> 允许你在超过终端窗口的补全列表中上下移动，<code>menuselect</code> 允许你从显示的列表中交互式地选择项目。你可以像在任何其他键映射中一样在其中绑定键。</p>
<p>[]{#l99}</p>
<h2 id="46-高级编辑-1"><a class="header" href="#46-高级编辑-1">4.6: 高级编辑</a></h2>
<p>（在物理学中，“高级波”是一种假设的向后移动的波。不幸的是，尽管它对赶上最后期限很有用，但这并不是我所说的“高级编辑”。）</p>
<p>这里有一些超出了普通 shell 命令的行编辑范围的东西。尽管它们到目前为止在 shell 中并不普遍，但我每天都使用它们所有，所以它们不仅仅是为研究生 zsh 学者准备的。</p>
<p>[]{#l100}</p>
<h3 id="461-多行编辑"><a class="header" href="#461-多行编辑">4.6.1: 多行编辑</a></h3>
<p>所有类 Bourne shell 都允许你编辑续行；也就是说，如果 shell 可以确定你还没有输完，它会显示一个新的提示符，由 <code>$PS2</code> 给出，并允许你从上一行离开的地方继续。在 zsh 中，你甚至可以看到 shell 在等待什么。举个简单的例子，输入 <code>array=(</code>first<code>然后按“回车”。shell 在等待数组的最后一个括号，并向你打印</code>array&gt;<code>，除非你改变了 </code>$PS2`。你可以继续向数组添加元素，直到你关闭括号。</p>
<p>源自 csh 的 shell 对续行不太满意；从历史上看，这是因为它们试图一次性评估所有内容，如果不能就会感到困惑。最初的 csh 没有一个特别复杂的解析器。这一次，zsh 没有一个选项来匹配 csh 的行为；你只需要习惯于 zsh 中事情就是这样工作的。</p>
<p>Zsh 相对于其他 shell 的改进之处在于，你不仅限于编辑单个续行；你实际上可以在屏幕上编辑一整块行，就像在全屏编辑器中一样——尽管你不能滚动出你正在编辑的行块，那没有意义。</p>
<p>最简单的方法是在你还没有输完的时候，在输入换行符之前按 escape。实际上，你随时都可以这样做，即使到目前为止的行是完整的。例如，</p>
<pre><code>  % print 这是第一行&lt;ESC&gt;&lt;RET&gt;
  print 这是第二行
</code></pre>
<p>行尾的那些尖括号意味着你按 escape，然后按 return。什么也没发生，也没有新的提示符；你只是轻快地继续输入。这次按回车，没有转义，两行都会被执行。请注意，没有隐含的反斜杠，或类似的东西；当 zsh 读取整个东西时，那个转义的回车变成了一个真正的回车，就像 shell 从脚本中读取它一样。</p>
<p>这是因为 <code>\e\r</code> 实际上绑定到 <code>self-insert-unmeta</code> 命令，意思是“插入我刚刚输入的字符，去掉 escape 或最高位”——换句话说，一个字面上的回车。如果你输入 <code>^v^j</code>，你会得到完全相同的效果，因为 <code>^v</code> 同样会转义 <code>^j</code>（换行符），就像它对任何其他字符一样。</p>
<p>（仅供极度好奇者阅读的旁注：为什么这里是换行符而不是回车符——你可能期望的“enter”键？这是一个相当怪诞的故事。事实证明，出于主要是历史原因，UNIX 终端驱动程序喜欢交换换行符和回车符，所以当你输入回车符（由那个键和 <code>^m</code> 发送，与 <code>\r</code> 表示的字符相同）时，它出来的是换行符（在大多数键盘上，只由 <code>^j</code> 发送，与 <code>\n</code> 表示的字符相同）。换行符是你“看到”在行尾的那个字符（因为它就是行尾）。然而，<code>^v</code> 看穿了这一点，如果你在它后面输入 <code>^m</code>，它会插入一个字面上的 <code>^m</code>，它看起来就像一个 <code>^m</code>，因为 zsh 就是这样输出它的。所以这就是为什么那不起作用。实际上，<code>self-insert-unmeta</code> 也会看到 <code>^m</code>，因为那是你去掉 <code>\e</code> 后得到的东西，但它有一点额外的代码让 UNIX 用户感到宾至如归，并且行为就像它是一个换行符。通常，<code>^j</code> 和 <code>^m</code> 被同样对待（<code>accept-line</code>），但字面字符有不同的行为。如果你现在非常困惑，就庆幸我还没有告诉你输出换行符时发生的额外扭曲吧。）</p>
<p>这可能看起来还不是特别有用，因为你所做的只是省略了一个新的提示符。让它变得有用的是，你现在可以只用光标键在两行（或更多行）之间上下移动。我假设你没有重新绑定光标键，你的终端不是一个不支持向上光标的哑终端，并且 <code>singlelinezle</code> 选项没有生效——如果生效了就取消它，你以后会感激的。</p>
<p>所以例如，输入</p>
<pre><code>  % if [[ true = false ]]; then&lt;ESC&gt;&lt;RET&gt;
    print Fuzzy logic rules&lt;ESC&gt;&lt;RET&gt;
  fi
</code></pre>
<p>我只是用空格缩进了第二行，因为我通常在“if”里面这样做。这里没有续行提示符，只有原始的 <code>$PS1</code>；那不是印刷错误。现在，在按回车之前，向上移动两行，并将 <code>false</code> 编辑为 <code>true</code>。你可以看到这有多有用。在命令行上输入函数可能是一个更典型的例子。</p>
<p>假设你已经用 <code>$PS2</code> 以正常方式经历了几次续行？那时你就不能回滚了，即使块还没有被编辑。有一个神奇的方法可以将所有那些续行变成一个单一的块：编辑器命令 <code>push-line-or-edit</code>。如果你不在续行上，它的行为就像我们下面会遇到的普通 <code>push-line</code> 命令，但就目前的目的而言，当你在续行上时使用它。你会看到一个从（重绘的）提示符到末尾的无缝文本块，你可以像一个整体一样编辑它。将 <code>push-line-or-edit</code> 而不是 <code>push-line</code> 绑定到 <code>^q</code> 或 <code>\eq</code>（在 Emacs 模式下，我将像往常一样假设）是相当合理的。不过要小心 <code>^q</code>——如果 <code>flowcontrol</code> 选项被设置，它可能会被终端驱动程序吞掉，而无法到达 shell，这与我上面提到的 <code>^s</code> 的问题相同。</p>
<p>[]{#l101}</p>
<h3 id="462-内建-vared-和函数-zed"><a class="header" href="#462-内建-vared-和函数-zed">4.6.2: 内建 vared 和函数 zed</a></h3>
<p>我在<a href="zshguide03.html#syntax">第三章</a>中提到了 <code>vared</code> 命令；它使用普通的行编辑器来编辑一个变量，通常是一个你不想完全输入的长的变量，比如 <code>$path</code>，尽管你需要记住<em>不要</em>在前面放 <code>$</code>，否则 shell 会在 <code>vared</code> 运行之前替换它。然而，由于它就像任何其他输入一样只是一段文本，所以它也可以有多行，你以同样的方式输入——而且由于一个 shell 参数可以包含任何东西，你就有了一个相当通用的编辑器。shell 函数 <code>zed</code> 与 shell 一起提供，允许你使用所有现在熟悉的命令来编辑一个文件。因为在编辑文件时，你不期望回车会把你踢出编辑器，只是插入一个新行，所以 zed 将回车重新绑定到 <code>self-insert-unmeta</code>（这里的 <code>-unmeta</code> 只是为了得到将回车变成换行符的交换行为）。要保存并退出，你可以输入 <code>^j</code>，或者，如果你的终端对那个有奇怪的反应，你也可以使用 <code>^x^w</code>，这被设计成看起来像 Emacs 写文件的方式。</p>
<p>如果你看一下 <code>zed</code>，你会看到它有一些花里胡哨的功能——例如，<code>zed -f</code> 允许你编辑一个函数——但是将文件读入一个参数，编辑该参数，并将参数写回文件的代码非常简单；所有困难的编辑代码都已经在 <code>vared</code> 内部处理了。的确，<code>zed</code> 本质上是一个完全通用的编辑器，尽管对于长文件，特别是大于单个屏幕的文件，它很快变得低效；正如你所期望的，zle 是为高效处理短文本块而编写的。</p>
<p>如果你能通过使用一个特殊的键映射来创建只在 vared 中应用的键绑定，那可能会很好。也许有一天会实现。</p>
<p>顺便说一句，请注意，你可以用 vared 编辑数组，它会明智地处理不同的元素。像往常一样，空白分隔元素；当它向你呈现一个元素内包含空白的数组时，vared 会在它前面加上一个反斜杠，以表明它不是一个分隔符。你可以自己用反斜杠插入带引号的空格。只有空白字符需要这种引用，而且只有反斜杠有效。</p>
<p>例如，</p>
<pre><code>  array=('一个 词' '两个 或更多 词')
  vared array
</code></pre>
<p>呈现给你 <code>一个\ 词 两个\ 或\ 更多\ 词</code>。如果你添加 <code> 和\ 一些\ 更多.</code>，按回车，然后输入 <code>print -l $array</code> 来每行显示一个元素，你会看到</p>
<pre><code>  一个 词
  两个 或更多 词
  和 一些 更多.
</code></pre>
<p>一些旧版本的 shell 对元素内的空格不太小心。</p>
<p>[]{#l102}</p>
<h3 id="463-缓冲区堆栈"><a class="header" href="#463-缓冲区堆栈">4.6.3: 缓冲区堆栈</a></h3>
<p>现在将解释 <code>push-line-or-edit</code> 的神秘其他用途。实际上，让我们坚持使用 <code>push-line</code>，因为我已经处理了 <code>-or-edit</code> 部分。</p>
<p>输入</p>
<pre><code>  print 我刚才在目录
</code></pre>
<p>（没有换行符）。哦，天哪，你刚才在哪个目录？你不想打断文本流去查找。按 <code>\eq</code>；你一直在输入的行消失了——但别担心，它没有消失。现在输入</p>
<pre><code>  dirs
</code></pre>
<p>两件事发生了：最后那一行当然被执行了，显示了目录栈上的目录列表（你对 <code>pushd</code> 和 <code>popd</code> 的使用），但你之前去掉的那一行也重新出现了，所以你可以继续编辑它。</p>
<p>你可能不会马上意识到这有多有用，但就在我写上一段的时候，我就用了好几次。例如，我正在 zle 源代码和我保存本指南的目录之间交替切换，我在意识到我在错误的目录之前就开始输入一个 <code>grep</code> 命令。我所需要做的就是输入 <code>\eq</code>，然后 <code>pushd</code>，把我带到我想要的地方，然后完成 <code>grep</code>。</p>
<p>“缓冲区堆栈”，这是这个机制的行话，可以随你喜欢多深。它是一个后进先出（LIFO）的堆栈，所以由最近输入的 <code>\eq</code> 推到它上面的行将首先重新出现，然后是按相反顺序的旧行。你甚至可以从一个函数中填充缓冲区堆栈——不一定是 zle 函数，尽管那也行——用 <code>print -z</code> <em>command-line</em>。</p>
<p>如果你想，你可以用 <code>\eg</code> 从堆栈中明确地拉出一个东西，但这与清除当前行并按回车有相同的效果。你当然可以多次推送同一行：如果你在执行它之前需要做一整套事情，每次行弹回来时就再按一次 <code>\eq</code>。</p>
<p>我撒了一点谎，为了避免混淆。<code>push-line-or-edit</code> 对多行缓冲区的聪明之处也延伸到了这种情况。如果你对一个多行缓冲区做一个普通的 <code>push-line</code>，只有当前的单行被推送；推送整个东西的命令，这可能是你想要的，是 <code>push-input</code>。但如果你绑定了 <code>push-line-or-edit</code>，你可以忘记这个区别，因为它会为你做。如果你一直注意听，你可以算出以下序列（假设 <code>\eq</code> 已被重新绑定到 <code>push-line-or-edit</code>）：</p>
<pre><code>  % if [[ no = yes ]]; then
  then&gt; print&lt;ESC&gt;q&lt;ESC&gt;q
</code></pre>
<p>第一个 <code>\eq</code> 将两行变成一个单一的缓冲区，然后第二个将整个东西推到缓冲区堆栈上。这省去了很多关于绑定的思考。因此，我建议 Emacs 模式的用户在他们的 <code>.zshrc</code> 中添加</p>
<pre><code>  bindkey '\eq' push-line-or-edit
</code></pre>
<p>然后忘记这些区别。</p>
<p>[]{#l103}</p>
<h2 id="47-扩展-zle-1"><a class="header" href="#47-扩展-zle-1">4.7: 扩展 zle</a></h2>
<p>我们现在来到 zle 最新、最灵活的部分，即使用 shell 函数创建新的、随你喜欢多复杂的编辑命令的能力。这最初是由 Andrew Main（“Zefram”）在 zsh 3.1 中引入的，因此在所有 zsh 4 版本中都是标准的，尽管工作仍在继续。</p>
<p>[]{#l104}</p>
<h3 id="471-小部件"><a class="header" href="#471-小部件">4.7.1: 小部件</a></h3>
<p>如果你的母语不是英语，首先，恭喜你读到这里。其次，你可能认为“widget”只是一个技术词，应用于实现某些计算思想的对象，比如在窗口系统中实现文本编辑的东西。然而，对大多数英语使用者来说，“widget”是一个幽默的词，指一个物体，有点像“whatyoumacallit”或“thingummybob”，比如“那个能一次性解开箔纸并拔出软木塞的聪明小玩意在哪里”。Zsh 的用法在我看来更接近第二种，非技术的版本，但我可能因为 Zefram 引入的代表小部件的内部对象，用户永远看不到，被称为“thingy”而有偏见，我不会再提它了，因为你不需要知道。</p>
<p>无论如何，“小部件”本质上就是我到目前为止一直称之为编辑器命令的东西，你可以绑定到一个键序列。更精确的术语之所以有用，是因为一旦你有 shell 函数到处飞，单词“命令”就无可救药地不具体了，因为函数充满了可能是也可能不是小部件的命令。所以我毫不犹豫地使用这个词。</p>
<p>所以现在我们引入第二种类型的小部件：一种不是由内置到 shell 中的代码处理，而是由用户编写的函数处理。它们是完全等价的；<code>bindkey</code> 和公司不关心是哪一种。你创建小部件所需要做的就是</p>
<pre><code>  zle -N widget-name function-name
</code></pre>
<p>然后 <em>widget-name</em> 可以在 <code>bindkey</code> 或 <code>execute-named-cmd</code> 中使用，函数 <em>function-name</em> 将被运行。如果 <code>widget-name</code> 和 <code>function-name</code> 相同，这通常是最简单的事情，你只需要其中一个。</p>
<p>你可以通过使用 <code>zle -l</code> 来列出现有的小部件，尽管通常 <code>zle -lL</code> 是一个更好的选择，因为那时的输出格式与你定义小部件时使用的形式相同。如果你这样做时看到很多 <code>zle -C</code> 小部件，暂时忽略它们；它们是补全小部件，处理方式有点不同，将在<a href="zshguide06.html#comp">第六章</a>中描述。</p>
<p>现在你需要知道函数中应该放什么。</p>
<p>[]{#l105}</p>
<h3 id="472-执行其他小部件"><a class="header" href="#472-执行其他小部件">4.7.2: 执行其他小部件</a></h3>
<p>在实现小部件的函数内部，你能做的最简单的事情就是调用一个现有的函数。所以，</p>
<pre><code>  my-widget() {
    zle backward-word
  }
  zle -N my-widget
</code></pre>
<p>创建一个名为 <code>my-widget</code> 的小部件，它在各方面（除了速度）都像内建小部件 <code>backward-word</code> 一样。你甚至可以给它一个前缀参数，这个参数会被传递下去；<code>\e3</code> 然后无论你把小部件绑定到什么（或者 <code>\exmy-widget</code>）都会向后移动三个单词。</p>
<p>假设你想给 <code>backward-word</code> 传递你自己的前缀参数，而不是用户输入的那个？或者假设你想考虑前缀参数，但用它做一些不同的事情？两者都是可能的。</p>
<p>让我们来看第一个。你可以通过在小部件名称后放上 <code>-n</code> <em>argument</em> 来为这个命令单独提供一个前缀参数（注意这不是大多数选项去的地方）。</p>
<pre><code>  my-widget() {
    zle backward-word -n 2
  }
</code></pre>
<p>这总是向后移动两个单词，覆盖用户给出的任何数字参数。（顺便说一句，你可以重新定义函数而不用告诉 zle；zle 只是在小部件运行时调用碰巧被定义的任何函数。）如果你在名称后只放 <code>-N</code>，它会取消用户给出的任何前缀，而不会引入新的。</p>
<p>前缀处理的另一部分——拦截用户指定的那个并可能修改它——引入了用户定义小部件最重要的部分之一。Zle 提供了各种参数，可以读取并经常写入以改变编辑器的行为甚至正在编辑的文本。在这种情况下，参数是 <code>$PREFIX</code>。例如，</p>
<pre><code>  my-widget() {
    zle backward-word -n $(( ${NUMERIC:-1} * 2 ))
  }
</code></pre>
<p>这使用一个算术替换来为 <code>backward-word</code> 提供一个参数，该参数是用户给出的两倍。注意 <code>${NUMERIC:-1}</code> 这个表示法，它很重要：大多数时候，你根本不给命令一个数字参数，在这种情况下，zle 很自然地将 <code>$NUMERIC</code> 视为未设置。这会搞乱算术替换。</p>
<p>顺便说一句，如果你在 shell 函数中犯了错误，你不会看到它；你只会得到一个哔哔声，除非你用 <code>setopt nobeep</code> 关闭了它。来自这类函数的输出被丢弃了，因为它会弄乱显示。所以你应该在将函数变成小部件之前进行任何基本的调试，例如，在前面放一个 <code>print</code> 并直接运行它——你不能从编辑器外部执行小部件。</p>
<p>以下也有效：</p>
<pre><code>  my-widget() {
    (( NUMERIC = ${NUMERIC:-1} * 2 ))
    zle backward-word
  }
</code></pre>
<p>因为你可以直接改变 <code>$NUMERIC</code>，并且除非被 <code>-n</code> 参数覆盖，否则它会被函数中调用的任何小部件使用。如果你在函数内部调用更多的小部件——你可以调用任意多个——同样的参数将适用于所有没有显式 <code>-n</code> 或 <code>-N</code> 的小部件。</p>
<p>一些小部件允许你指定非数字参数。目前这些主要是搜索函数，你可以给它们一个明确的搜索字符串。然而，通常你每次都想指定一个新的搜索字符串。我能看到的最有用的使用方式是为增量搜索命令提供一个初始参数。稍后，我将展示你如何以类似于 Emacs 模式的 <code>^r</code> 绑定 <code>history-incremental-search-backwards</code> 的方式读取字符。</p>
<p>[]{#l106}</p>
<h3 id="473-一些特殊的内建小部件及其用途"><a class="header" href="#473-一些特殊的内建小部件及其用途">4.7.3: 一些特殊的内建小部件及其用途</a></h3>
<p>有些事情你可能想在 zle 函数中对编辑器做，但直接从 zle 执行是没用的。一个是像普通小部件那样产生一个错误。你可以用 <code>zle beep</code> 来做到这一点。然而，这不会自动在那个点停止你的函数；由你来从函数返回。</p>
<p>通过用 <code>zle -N</code> 声明并定义相应的函数，可以重新定义一个内建小部件。从现在开始，所有引用该小部件的现有绑定都会导致你的函数被运行，而不是内建的那个。这是因为 zle 实际上不关心一个小部件做什么，直到它被运行。你可以通过使用 <code>bindkey</code> 定义一个键序列来调用一个未定义的小部件，比如 <code>any-old-string</code>，来看到这一点。shell 不会抱怨，直到你实际按下该键序列。</p>
<p>然而，有时你想确保调用内建小部件，即使其行为已被重新定义。你可以通过在小部件名称前放一个 <code>.</code> 来做到这一点；<code>zle .up-line-or-history</code> 总是调用通常被称为 <code>up-line-or-history</code> 的内建小部件，即使后者已被重新定义。一个用途是重新绑定 <code>accept-line</code>，以便在 zle 即将把一行传递给 shell 时做一些事情，但无论如何都要接受该行：你编写自己的小部件 <code>accept-line</code>，确保它在完成前调用 <code>zle .accept-line</code>，然后使用 <code>zle -N accept-line</code>。这里有一个微不足道但并非完全愚蠢的例子：</p>
<pre><code>  accept-line() {
    print -n "\e]2;Executing $BUFFER\a"
    zle .accept-line
  }
  zle -N accept-line
</code></pre>
<p>现在每次你按回车执行一个命令时，那个 <code>print</code> 命令都会先被执行。如所写，它将 <code>Executing</code> 然后是命令行的内容（见下文）放入你的 xterm 窗口的标题中，假设它理解通常的 xterm 转义序列。实际上，这个特定的例子通常是用特殊的 shell 函数（不是 zle 函数）<code>preexec</code> 来处理的，它被传递一个即将被执行的命令行作为参数，而不是在 <code>$BUFFER</code> 中。重新绑定 <code>accept-line</code> 似乎有一个副作用，即在某些情况下，回车键在 minibuffer 中停止工作。</p>
<p>请注意，要撤销回车执行你的新小部件的事实，你需要将 <code>accept-line</code> 别名回 <code>.accept-line</code>：</p>
<pre><code>  zle -A .accept-line accept-line
</code></pre>
<p>如果你记不住顺序，就像 zsh 和 UNIX 中的大多数别名或重命名命令一样，包括 <code>ln</code> 和 <code>bindkey -A</code>，你想要保留其属性的现有命令排在第一位，而它的新名称排在第二位。此外，就像那些命令一样，如果行上的第二个名称当前意味着别的东西，那也没关系；那将被新的含义所取代。之后，你不需要担心你自己的 <code>accept-line</code> 小部件；zle 会处理移除不再被引用的小部件的细节。然而，函数仍然在那里，因为就 shell 的其余部分而言，它只是一个普通的 shell 函数，你需要用 <code>unfunction</code> 来移除它。</p>
<p>但是，请记住，不要用明显的命令删除一个重新定义了基本内部小部件的小部件</p>
<pre><code>  # 不不不！
  zle -D accept-line
</code></pre>
<p>这会使回车键除了抱怨没有这样的小部件之外没有任何效果。如果你真的陷入困境，<code>\ex.accept-line</code> 应该可以工作，因为你可以像使用任何其他小部件一样使用 <code>.</code>-小部件，除非它们会重新定义或删除一个 <code>.</code> 小部件。使用上面带有扩展命令形式的 <code>.accept-line</code> 的 <code>zle -A</code> 命令返回正常。如果你试图重新定义或删除一个 <code>.</code> 小部件，zle 会告诉你它受保护。然而，你可以用这种方式移除任何其他小部件，即使它仍然绑定到一个键序列；如果你输入那个序列，你会看到一个错误。</p>
<p>关于 <code>accept-line</code> 的一点需要注意的是，该行不会立即传递给 zsh，只有当你的函数退出时才会。当你思考一下时，这很明显；zle 是从主 shell 调用的，如果你的 zle 小部件还没有执行完，主 shell 还没有拿回控制权。但它确实意味着，例如，如果你在调用 <code>accept-line</code> 或 <code>.accept-line</code> 之后修改命令行，那些更改会反映在传递给 shell 的行中：</p>
<pre><code>  # 这个也别用！
  accept-line() {
    zle .accept-line
    BUFFER='哈哈！'
  }
</code></pre>
<p>这总是向主 shell 返回字符串 <code>哈哈！</code>。这并不是特别有用，除非你正在为巴黎艺术画廊的装置构建一个塞缪尔·贝克特 shell。</p>
<p>[]{#l107}</p>
<h3 id="474-特殊参数普通文本"><a class="header" href="#474-特殊参数普通文本">4.7.4: 特殊参数：普通文本</a></h3>
<p>shell 提供了各种参数，以便于操作命令行。你已经见过 <code>$NUMERIC</code>。你可能想知道如果你有自己的名为 <code>$NUMERIC</code> 的参数会发生什么；毕竟，它是一个相当简单的用作名称的字符串。好消息是你不需要担心；当 shell 运行一个 zle 函数时，它只是隐藏任何现有的参数出现，并使其特殊参数可用。然后当它退出时，原始参数被重新启用。所以你所要担心的就是确保你在 zle 小部件内部不将这些特殊参数用于任何其他事情。</p>
<p>有四个特别常见的 zle 参数。</p>
<p>首先，有三种引用命令行上文本的方式：<code>$BUFFER</code> 是整行作为一个字符串，<code>$LBUFFER</code> 是光标位置左边的行，<code>$RBUFFER</code> 是它后面的行，包括光标下的字符，所以分割总是在下一个插入字符将要去的地方。这些中的任何一个或所有都可能为空，并且 <code>$BUFFER</code> 总是字符串 <code>$LBUFFER$RBUFFER</code>。</p>
<p>这些的必要对应物是 <code>$CURSOR</code>，它是光标位置，1 是第一个字符。如果你知道 shell 如何在参数替换中处理子字符串，你将能够看到 <code>$LBUFFER</code> 是 <code>$BUFFER[1,$CURSOR-1]</code>，而 <code>$RBUFFER</code> 是 <code>$BUFFER[$CURSOR,-1]</code>（除非你正在使用 <code>KSH_ARRAYS</code> 选项以与 ksh 的索引兼容——这不推荐用于实现 zle 或补全小部件，因为它会与 shell 提供的那些造成混淆）。</p>
<p>关于这些真正有用的是它们是可修改的。如果你修改 <code>$LBUFFER</code> 或 <code>$RBUFFER</code>，那么 <code>$BUFFER</code> 和 <code>$CURSOR</code> 将被适当地修改；加长或缩短 <code>$LBUFFER</code> 会增加或减少 <code>$CURSOR</code>。如果你修改 <code>$BUFFER</code>，你可能需要自己设置 <code>$CURSOR</code>，因为 shell 无法确定光标应该在哪里。如果你改变 <code>$CURSOR</code>，字符将在 <code>$LBUFFER</code> 和 <code>$RBUFFER</code> 之间移动，但 <code>$BUFFER</code> 将保持不变。</p>
<p>这使得像基本移动和删除命令这样的任务变得极其简单，通常只是一个模式匹配的问题。然而，了解 zsh 更复杂的模式匹配和参数替换特性绝对是有益的，下一章将描述。例如，如果你用</p>
<pre><code>  emulate -L zsh
  setopt extendedglob
  LBUFFER=${LBUFFER%%[^[:blank:]]##}
</code></pre>
<p>来开始一个小部件函数，那么 <code>$LBUFFER</code> 包含光标左边的行，去掉了紧邻光标左边的所有非空白字符（通常是除了空格或制表符之外的任何东西）。</p>
<p>这个函数使用了参数替换特性 <code>$</code><em>param</em><code>%%</code><em>pattern</em><code>}</code>，它从 <code>$</code><em>param</em> 的末尾移除 <em>pattern</em> 的最长匹配。<code>emulate -L zsh</code> 确保为函数适当地设置了 shell 选项，并使所有选项设置都是局部的，<code>setopt extendedglob</code> 打开了扩展模式匹配特性；正是这个使得模式中出现的序列 <code>##</code> 意味着“前一个模式元素重复一次或多次”。前一个模式元素是“除了空白字符之外的任何东西”。因此，所有非空白字符的出现都从 <code>$LBUFFER</code> 的末尾被移除了。</p>
<p>如果你想将光标移过那些字符，你可以稍微调整一下函数：</p>
<pre><code>  emulate -L zsh
  setopt extendedglob
  chars=${(M)LBUFFER%%[^[:blank:]]##}
  (( CURSOR -= ${#chars} ))
</code></pre>
<p>字符串 <code>(M)</code> 出现在参数替换的开头。这是 zsh 独特的参数标志系统的一部分；这个意味着“插入替换的匹配部分”。换句话说，替换不是返回去掉了末尾非空白字符的 <code>$LBUFFER</code>，而是返回它本应去掉的那些字符。要跳过它们现在是一个简单的事情，只需将 <code>$CURSOR</code> 减去该字符串的长度。</p>
<p>如果你尝试这些例子，你会发现它们可能不完全是你想要的。特别是，它们不处理普通单词导向函数所做的在非空白字符旁边找到的任何空白字符。然而，你现在有足够的信息来自己添加对此的测试。</p>
<p>如果你变得更老练，你就可以添加对 <code>$NUMERIC</code> 的处理。记住，除非用户明确给出，否则这个不会被设置，所以在那种情况下，由你来将它视为 1。</p>
<p>[]{#l108}</p>
<h3 id="475-其他特殊参数"><a class="header" href="#475-其他特殊参数">4.7.5: 其他特殊参数</a></h3>
<p>你可能想要做的大部分事情都可以用我们已经见过的参数来完成。这里有一些关于你可能想如何使用一些其他可用参数的提示。一如既往，要获得一个完整的列表，但提示较少，请参阅手册。</p>
<p><code>$KEYS</code> 告诉你用于调用小部件的键；它是那些原始字符的字符串，没有转换成 <code>bindkey</code> 格式。换句话说，如果它是一个单键（可能包括一个控制键或一个 meta 键），<code>$KEYS</code> 将只包含一个单字符。所以你可以为不同的键改变小部件的行为。这里有一个非常（非常）简单的函数，像 <code>self-insert</code>：</p>
<pre><code>  LBUFFER=$LBUFFER$KEYS
</code></pre>
<p>请注意，这对于 <code>\ex</code> 扩展命令处理效果不佳；你只会得到行尾的 <code>^m</code>。你需要确保任何使用 <code>$KEYS</code> 的小部件都被合理地绑定。这也没有处理用于重复字符的数字参数；添加这个是一个相当简单的练习（特别是考虑到 zsh 的“repeat”循环）。</p>
<p><code>$WIDGET</code> 和 <code>$LASTWIDGET</code> 告诉你正在执行的当前小部件和前一个的名称。乍一听，这些听起来不那么有用。然而，你可以将 <code>$WIDGET</code> 与一个小部件不必与定义它的函数同名的事实结合起来使用。你可以定义</p>
<pre><code>  zle -N this-widget function
  zle -N that-widget function
</code></pre>
<p>并在 <code>function</code> 内部测试 <code>$WIDGET</code>，看它是否包含 <code>this-widget</code> 或 <code>that-widget</code>。如果它们有很多共享代码，那是一个相当大的简化，而无需编写额外的函数。</p>
<p><code>$LASTWIDGET</code> 倾向于用于一个稍微不同的目的：检查上一个要执行的命令是否与当前命令相同，或者可能只是与它友好。这里是 <code>up-line-or-beginning-search</code> 函数的编辑亮点，这是一个介于 <code>up-line-or-search</code> 和 <code>history-beginning-search-backward</code> 之间的混合体，已添加到 shell 的 <code>4.1</code> 发行版中。如果缓冲区中有前几行，它会在它们之间向上移动；否则，如果它是一系列调用此函数的第一个，它会记住光标位置并向后查找具有从开头到该点相同文本的行，并将光标放在行尾；否则，如果刚刚执行了相同的小部件，它会使用旧的光标位置在历史中更远的地方搜索另一个匹配项。</p>
<pre><code>  if [[ $LBUFFER == *$ '\n'* ]]; then
    zle .up-line-or-history
    __searching=''
  else
    if [[ $LASTWIDGET = $__searching ]]; then
      CURSOR=$__savecursor
    else
      __savecursor=$CURSOR
    fi
    __searching=$WIDGET
    zle .history-beginning-search-backward
    zle .end-of-line
  fi
</code></pre>
<p>我们测试 <code>$__searching</code> 而不是直接测试 <code>$WIDGET</code>，以便能够区分我们是在移动行还是在搜索。<code>$__savecursor</code> 给出了向后搜索的位置，之后我们将光标放在行尾。以 <code>__</code> 开头的参数不是函数局部的，因为我们需要从前一次执行中测试它们，所以它们前面加了下划线，以试图将它们与周围可能存在的其他参数区分开来。</p>
<p>你会看到发行版中提供的实际函数比这个稍微复杂一些；一方面，它使用用户设置的样式来决定其行为。样式在<a href="zshguide06.html#comp">第六章</a>中描述用于补全小部件，但你可以在 zle 函数中以完全相同的方式使用它们。</p>
<p><code>up-line-or-beginning-search</code> 的完整版本使用了另一个参数，<code>$PREBUFFER</code>。它包含 <code>zle</code> 已经吸收的任何你无法再编辑的文本——换句话说，在 shell 用 <code>$PS2</code> 提示剩余部分之前读入的文本。因此，测试 <code>[[ -n $PREBUFFER ]]</code> 实际上是测试你是否在 <code>$PS2</code>。你可以用这个来实现 <code>push-line-or-edit</code> 风格的行为。</p>
<p>[]{#l109}</p>
<h3 id="476-读取按键和使用-minibuffer"><a class="header" href="#476-读取按键和使用-minibuffer">4.7.6: 读取按键和使用 minibuffer</a></h3>
<p>时不时地，你希望编辑器在中间有用户输入的情况下执行一系列操作。这通常是通过两个命令的组合来完成的。</p>
<p>首先，你可能需要在 minibuffer 中提示用户，就像 <code>\ex</code> 做的那样。你可以用 <code>zle -R</code> 来做到这一点。它的基本功能是重新显示命令行，刷新你在函数中到目前为止所做的所有更改，但你可以给它一个字符串参数，它会出现在 minibuffer 中，就在命令行下方。你可以在那之后给它一个其他字符串的列表，它们会以类似于可能的补全列表的方式出现，但在这种情况下对 zle 没有特殊意义。</p>
<p>要从用户那里获取输入，你可以使用 <code>read -k</code>，它读取单个键（不是序列；不进行查找）。这个命令在 shell 中总是可用的，但在这种情况下，它是由 zle 自己处理的。键以原始字节的形式返回。算术求值的两个功能对于处理这个键很有用：<code>#key</code> 返回 <code>$key</code> 的第一个字符的 ASCII 码，而 <code>##</code><em>key</em> 返回 <em>key</em> 的 ASCII 码，其形式是 <code>bindkey</code> 会理解的。例如，</p>
<pre><code>  read -k key
  if (( #key == ##\C-g )); then
     ...
</code></pre>
<p>使用算术求值。左边的形式将 <code>$key</code> 中的第一个字符转换为一个数字，第二个将字面上的 bindkey 风格的字符串 <code>\C-g</code> 转换为一个数字（ASCII 7，因为 1 到 26 就是 <code>\C-a</code> 到 <code>\C-z</code>）。不要将这两种形式与 <code>$#key</code> 混淆，后者是参数中字符串的长度，在这种情况下对于单个字节几乎肯定是 1；这种形式在算术替换内外都有效，其他形式只在内部有效。只要可能，推荐使用 <code>(( ... ))</code> 形式进行算术替换；你可以用基本的 <code>[[ ... ]]</code> 形式来做，因为 <code>-eq</code> 和类似的测试将两边都视为算术，尽管你可能需要额外的引用；然而，我知道这样做的唯一好理由是避免在同一个复杂测试中使用两种条件语法。</p>
<p>这些技巧只对相当复杂的函数真正有用。举个例子，看看 zsh 源代码发行版中提供的 <code>incremental-complete-word</code> 函数。这个函数通过使用 <code>#\C-g</code> 的形式而不是 <code>##\C-g</code> 来增加清晰度；它做同样的事情，但双反斜杠非常令人困惑，这就是为什么引入了另一种形式。</p>
<p>[]{#l110}</p>
<h3 id="477-示例"><a class="header" href="#477-示例">4.7.7: 示例</a></h3>
<p><strong>transpose-words-about-point</strong>\</p>
<p>这个函数是 <code>transpose-words</code> 的一个变体。它有各种曲折。首先，所讨论的单词总是以空格分隔的，既不是 shell 单词，也不是 <code>$WORDCHARS</code> 意义上的单词。这使得它相当可预测。</p>
<p>其次，即使光标下的字符不是空白字符，它也会围绕当前点（因此得名）转置单词。我发现这很有用，因为我永远在输入像 <code>function_name</code> 这样的复合词，结果发现我应该输入的是 <code>name_function</code>。现在我只需将光标定位在下划线上并执行这个小部件。</p>
<pre><code>  emulate -L zsh
  setopt extendedglob

  local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

  pat1=${LBUFFER%%(#b)([^[:blank:]]##)([[:blank:]]#)}
  word1=$match[1]
  ws1=$match[2]

  match=()
  pat2=${RBUFFER##(#b)(?[[:blank:]]#)([^[:blank:]]##)}
  ws2=$match[1]
  word2=$match[2]

  if [[ -n $word1 &amp;&amp; -n $word2 ]]; then
    LBUFFER="$pat1$word2$ws1"
    RBUFFER="$ws2$word1$pat2"
  else
    zle beep
  fi
</code></pre>
<p>这里唯一聪明的东西是模式匹配。它大量使用了“反向引用”，这是一个扩展的 globbing 特性，用于所有形式的模式匹配，包括，如本例中，参数替换。下一章将完整描述它。要寻找的关键东西是 <code>(#b)</code>，它在 <code>EXTENDED_GLOB</code> 选项打开时激活反向引用，后面的括号标记出你想要引用的部分，以及对数组 <code>$match</code> 的元素的引用，它存储了那些部分。shell 还设置了 <code>$mbegin</code> 和 <code>$mend</code> 来给出那些匹配的开始和结束位置，这就是为什么那些参数被设为局部的；我们希望保护它们不被函数外部看到，即使我们实际上没有使用它们。</p>
<p>你可能还需要知道关于 <code>#</code> 字符：一个在模式后面意味着“零次或多次重复”，两个意味着“一次或多次重复”。最后，字符类中的 <code>[:blank:]</code> 指的是任何空白字符；当被否定时，如字符类 <code>[^[:blank:]]</code>，它意味着任何非空白字符。有了 <code>#</code>，我们匹配一系列空白或非空白字符。鉴于此，你可以算出其余的发生了什么。</p>
<p>这里有一个更复杂的版本。如果你觉得前一个很难，你可能不想仔细看这个。</p>
<pre><code>  emulate -L zsh
  setopt extendedglob

  local wordstyle blankpat wordpat1 wordpat2
  local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

  zstyle -s ':zle:transpose-words-about-point' word-style wordstyle

  case $wordstyle in
    (shell) local bufwords
            # 这会将行分割成 shell 理解的单词。
            bufwords=(${(z)LBUFFER})
            wordpat1="${"(q)bufwords[-1]}""
            # 取 RBUFFER 的子串以跳过第一个字符，
            # 即光标下的那个。
            bufwords=(${(z)RBUFFER[2,-1]})
            wordpat2="${"(q)bufwords[1]}""
            blankpat='[[:blank:]]#'
            ;;
    (space) blankpat='[[:blank:]]#'
            wordpat1='[^[:blank:]]##'
            wordpat2=$wordpat1
            ;;
    (*) local wc=$WORDCHARS
        if [[ $wc = (#b)(?*)-(*) ]]; then
          # 我们需要将任何 `-' 带到前面以避免混淆
          # 字符类... 我们用 `]' 侥幸过关，因为在 zsh 中
          # 如果它被引用，这不是一个模式字符。
          wc=-$match[1]$match[2]
        fi
        # 空白是任何不在由
        # 字母数字和 $wc 中的字符组成的字符类中的东西。
        # 在必要时引用 $wc，因为我们不希望那些
        # 字符稍后被认为是模式字符。
        blankpat="[^${"(q)wc}a-zA-Z0-9]#"
        # 并且一个单词字符是任何其他东西。
        wordpat1="[${"(q)wc}a-zA-Z0-9]##"
        wordpat2=$wordpat1
        ;;
  esac

  # eval 使参数中的任何特殊字符都处于活动状态。
  # 特别是，我们需要周围的 `[' 是 `真实的'。
  # 这就是为什么我们在 `shell' 选项中引用了 wordpats，其中
  # 它们此时必须被视为文字字符串。
  eval pat1='${LBUFFER%%(#b)('${wordpat1}')('${blankpat}')}'
  word1=$match[1]
  ws1=$match[2]

  match=()
  eval pat2='${RBUFFER##(#b)(?'${blankpat}')('${wordpat2}')}'
  ws2=$match[1]
  word2=$match[2]

  if [[ -n $word1 &amp;&amp; -n $word2 ]]; then
    LBUFFER="$pat1$word2$ws1"
    RBUFFER="$ws2$word1$pat2"
  else
    zle beep
  fi
</code></pre>
<p>增加的是使用样式来定义 shell 如何找到“单词”的能力。默认情况下，单词与 shell 通常认为的单词相同；这是由 case 语句的分支处理的，该分支使用 <code>$WORDCHARS</code> 和一点额外的技巧来获得一个匹配被认为是单词一部分的字符集的模式。我们使用 <code>eval</code> 是因为它允许我们让 <code>$wordpat1</code> 和朋友们的一些部分作为模式字符活动，而其他部分被引用。</p>
<p>这引入了两种类型的参数扩展标志：<code>${(q)</code><em>param</em><code>}</code> 添加反斜杠以引用 <code>$</code><em>param</em> 中的特殊字符，因此当参数出现在 <code>eval</code> 之后时，结果只是原始字符串。<code>${(z)</code><em>param</em><code>}</code> 像 shell 命令行被分割成命令和单词一样分割参数，所以结果是一个数组；<code>z</code> 代表 zsh-splitting 或你喜欢的 zplitting。</p>
<p>如果你设置</p>
<pre><code>  zstyle ':zle:*' word-style space
</code></pre>
<p>你会回到原始函数的行为。</p>
<p>最后，如果你在那个 <code>zstyle</code> 命令中用 <code>shell</code> 替换 <code>space</code>，你会得到在 shell 内部正常使用时被分割的单词；例如，试试</p>
<pre><code>  echo execute the widget 'between these' 'two quoted expressions'
</code></pre>
<p>整个带引号的表达式将被转置。你可能会发现，如果你在带引号的表达式中间这样做，你得不到一个合理的结果；那是因为 <code>(z)</code>-splitting 不知道如何处理其左右两边未正确完成的引号。一些版本的 shell 有一个 bug（在 4.0.5 中修复），即无法正确分割的表达式，因为引号未完成，末尾会有一个额外的空格字符。</p>
<p><strong>insert-numeric</strong>\</p>
<p>这里有一个小部件，允许你插入一个 ASCII 字符</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide04.html">上一章</a></li>
<li><a href="zshguide06.html">下一章</a></li>
</ul>
<hr />
<p>[]{#subst}[]{#l111}</p>
<h1 id="第五章替换-1"><a class="header" href="#第五章替换-1">第五章：替换</a></h1>
<p>本章首先会吸引那些对以下事实感到兴奋的人：</p>
<pre><code>  print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}
</code></pre>
<p>打印出数组 <code>$array</code> 中最长的元素。然而，对于构成其余人口的绝大多数人来说，在我们达到那个阶段之前，应该有很多有用的东西。无论如何，应该立即明白为什么没有混淆 zsh 代码竞赛。</p>
<p>对于那些不经常编写函数，大部分时间都在 shell 提示符下度过的人来说，本章最有用的部分可能是在本章末尾关于文件名生成（即通配）的部分。这将教你如何在为命令选择文件时避免浪费时间在 <code>find</code> 之类的事情上。</p>
<p>[]{#l112}</p>
<h2 id="51-引用-1"><a class="header" href="#51-引用-1">5.1: 引用</a></h2>
<p>我在本指南中一直使用某种形式的引用，但我从未深入细节。现在是时候了，因为使用引用是控制 shell 各种替换效果的重要部分。以下是基本的引用类型。</p>
<p>[]{#l113}</p>
<h3 id="511-反斜杠"><a class="header" href="#511-反斜杠">5.1.1: 反斜杠</a></h3>
<p>关于反斜杠，主要要说明的是它们其实很简单。你可以用反斜杠引用任何字符，即使它在未被引用时没有任何意义；所以如果情况最糟，你可以取任何旧字符串，无论它里面有什么——随机的引号、反斜杠、不可打印的字符——用反斜杠引用每个字符，shell 就会把它当作一个普通字符串：</p>
<pre><code>  print \T\h\i\s\ \i\s\ \*\p\o\i\n\t\l\e\s\s\*\ \ 
      \-\ \b\u\t\ \v\a\l\i\d\!
</code></pre>
<p>还要记住，这意味着你需要额外的一层引用来向 <code>print</code> 传递一个 <code>\n</code> 或其他什么。</p>
<p>然而，zsh 有一个更简单的方法来确保在需要时所有东西都用反斜杠引用。这是一种特殊的参数替换形式，只是你可以通过在括号中提供标志来做的众多技巧之一：</p>
<pre><code>  % read string
  This is a *string* with various `special' characters
  % print -r -- ${(q)string}
  This\ is\ a\ \*string\*\ with\ various\ \`special\'\ characters
</code></pre>
<p><code>read</code> 内建命令对你输入的内容没有做任何处理，所以 <code>$string</code> 只包含那些字符。<code>print</code> 的 <code>-r</code> 标志告诉它以原始方式打印后面的内容，这里是特殊部分：<code>${(q)string}</code> 告诉 shell 在需要时用反斜杠输出参数，以防止特殊字符被解释。所有参数标志都是 zsh 特有的；没有其他 shell 有它们。</p>
<p>这个标志在那里不是很有用，因为 zsh 通常（还记得 <code>GLOB_SUBST</code> 选项吗？）无论如何都不会对来自替换的字符做任何特殊处理。它<em>极其</em>有用的地方是，如果你要重新评估替换中的文本，但仍然希望它被当作一个普通字符串。所以在上面之后，</p>
<pre><code>  % eval print -r -- ${(q)string}
  This is a *string* with various `special' characters
</code></pre>
<p>你会得到你开始时的内容，因为在命令行的 <code>eval</code> 时，由 <code>(q)</code> 标志放入的反斜杠意味着该值被当作一个普通字符串。</p>
<p>你也可以去掉参数中的引号；标志 <code>(Q)</code> 可以做到这一点。它不关心是使用反斜杠还是单引号或双引号，它都以 shell 解析器的方式处理它们。只有当参数的值中不知何故包含了引号时，你才需要这个。这种情况发生的一种方式是，如果你尝试读取一个包含 shell 命令的文件，为此还有另一个技巧：<code>(z)</code> 标志将一行分割成一个数组，就像该行被读入并（比如说）被赋给一个数组一样。这里有一个例子：</p>
<pre><code>  % cat file
  print 'a quoted string' and\ another\ argument
  % read -r line &lt;file
  % for word in ${(z)line}; do
  for&gt; print -r "quoted:    $word"
  for&gt; print -r "unquoted:  ${(Q)word}"
  for&gt; done
  quoted:    print
  unquoted:  print
  quoted:    'a quoted string'
  unquoted:  a quoted string
  quoted:    and\ another\ argument
  unquoted:  and another argument
</code></pre>
<p>You会注意到 <code>(z)</code> 没有从读入的单词中移除任何引号，但 <code>(Q)</code> 标志做到了。注意 <code>read</code> 和 <code>print</code> 的 <code>-r</code> 标志：第一个防止反斜杠被 <code>read</code> 吸收，第二个防止它们被 <code>print</code> 吸收。恐怕反斜杠有点麻烦。</p>
<p>[]{#l114}</p>
<h3 id="512-单引号"><a class="header" href="#512-单引号">5.1.2: 单引号</a></h3>
<p>你唯一不能用单引号引用的东西是另一个单引号。然而，有一个选项 <code>RC_QUOTES</code>，在单引号字符串中的两个单引号会变成一个。显然 <code>RC</code> 指的是 plan9 中出现的 shell <code>rc</code>；它似乎是那种有些人会狂热地投入其中，而我们其他人却搞不懂为什么的程序之一。Zsh 用户可能会同情。（在我错误地猜测 <code>RC</code> 代表递归之后，Oliver Kiddle 和 Bart Schaefer 纠正了这一点，尽管你仍然可以那样想。然而，对于 <code>RC_EXPAND_PARAM</code> 来说，这确实行不通，它肯定来自 <code>rc</code> shell，如果你看源代码，你会发现一个名为 <code>plan9</code> 的变量，用于测试该选项是否生效。）</p>
<p>You可能还记得 BASIC 中的类似东西，尽管在那种情况下是双引号——在 zsh 中，出于某种原因，它只适用于单引号。所以，</p>
<pre><code>  print -r 'A ''quoted'' string'
</code></pre>
<p>通常会给你输出 <code>A quoted string</code>，但设置了该选项后，它会打印 <code>A 'quoted' string</code>。<code>print</code> 的 <code>-r</code> 选项在这里什么也没做，只是为了表明我没有隐藏任何东西。这通常是一个有用且无害的选项，因为在引号内有两个引号在一起没有其他好理由。</p>
<p>引用单引号的标准方法是结束引用，插入一个反斜杠转义的单引号，然后重新开始引用：</p>
<pre><code>  print -r 'A '\''quoted'\'' string'
</code></pre>
<p>这不受选项设置的影响，因为反斜杠紧随其后的引号总是被视为一个普通的、可打印的字符。你<em>永远不能</em>做的是用反斜杠作为在单引号内引用字符的方式；它们在那里只被当作普通字符。</p>
<p>你可以通过将 <code>q</code> 加倍来强制参数标志生成用单引号引用的字符串，而不是反斜杠：<code>${(qq)param}</code> 而不是 <code>${(q)param}</code>。这主要用于如果你知道字符串中有很多特殊字符，结果会更短，而且对于人类来说也比机器更容易阅读，但通常它比其他形式没有任何优势。它可以判断你是否设置了 <code>RC_QUOTES</code> 并使用它来使字符串更短，所以如果你可能在没有设置该选项的地方使用结果字符串，要小心。</p>
<p>[]{#l115}</p>
<h3 id="513-posix-引号"><a class="header" href="#513-posix-引号">5.1.3: POSIX 引号</a></h3>
<p>有一种单引号的亲戚，它使用语法 <code>$'</code> 来引入一个带引号的字符串，并用 <code>'</code> 来结束它；我称之为“POSIX 引号”，因为它们出现在 POSIX 标准中，我不知道还能叫它们什么；“字符串引号”是一种可能性，但听起来有点模糊（你还会引用什么呢？）。与单引号的区别在于，它们理解与 print 内建命令相同的反斜杠序列。因此，你可以方便地使用 <code>\n</code> 表示换行，<code>\e</code> 表示转义，<code>\xFF</code> 表示十六进制的任意字符，等等，对于任何命令：</p>
<pre><code>  % cat &lt;&lt;&lt;$'Line\tone\nLine\ttwo'
  Line    one
  Line    two
</code></pre>
<p>记住“here string”表示法 <code>&lt;&lt;&lt;</code>，它为命令提供标准输入。因此，输出准确地显示了带引号的字符串是如何被解释的。它与</p>
<pre><code>  % print 'Line\tone\n\Line\ttwo'
  Line    one
  Line    two
</code></pre>
<p>相同，但在那里解释是在 <code>print</code> 内部完成的，这并不总是方便。POSIX 引号目前使用得相当少。</p>
<p>这是提及 shell 完全是“八位干净”的最好时机，这意味着你可以在你的字符串中的任何地方拥有 256 个可能的字符中的任何一个。例如，<code>$'foo\000bar'</code> 中有一个嵌入的 ASCII NUL（那不是印刷错误——官方地，ASCII 非打印字符有两或三个字母的缩写）。通常这会终止一个字符串，但当你在内部使用它时，shell 会绕过这个问题；然而，当你尝试将其作为参数传递给外部程序时，一切都无法保证了。几乎可以肯定，在那种情况下，第一个 NUL 会导致程序认为字符串已经结束，因为没有关于参数长度的信息被传递下去，shell 也无能为力。因此，例如：</p>
<pre><code>  % echo $'foo\000bar'
  foobar
  % /bin/echo $'foo\000bar'
  foo
</code></pre>
<p>shell 的 <code>echo</code> 知道 shell 的 8 位约定，并打印出 NUL，终端不显示，然后是字符串的其余部分。外部版本的 <code>echo</code> 在到达 NUL 时除了停止之外别无他法。</p>
<p>嵌入的 NUL 实际上有用途：例如，某些版本的 <code>find</code> 和 <code>xargs</code> 会在其输入和输出的各个部分之间放置或接受 NUL 而不是换行符（与命令行参数不同），如果输入或输出有可能包含一个活动的换行符，这会安全得多。使用 <code>$'\000'</code> 允许 shell 非常舒适地与这些配合。如果你想尝试这个，相应的选项是 <code>find</code> 的 <code>-print0</code>（用 NUL 终止符而不是换行符打印）和 <code>xargs</code> 的 <code>-0</code>（假设 NUL 终止符读取输入）。</p>
<p>在旧版本的 shell 中，最高位被设置的字符，例如在 ISO 8859 字体中找到的非英语字符集中的字符，可能会导致问题，因为 shell 内部也使用这些字符来表示自己的特殊字符，但最近版本的 shell（从大约 3.0 开始）以与 NUL 相同的方式回避了这个问题。任何遗留的问题——要完全一致地处理这个问题相当棘手——都是 bug，应该被报告。</p>
<p>你可以通过一种相当荒谬的方式，即让引号标志中的 <code>q</code> 总共出现四次，来强制参数用 POSIX 引号引用。我想不出你为什么会想这样做，除非它会将换行符变成 <code>\n</code>，因此结果将适合单行（可能相当长）。另外，你还可以用转义序列替换特殊字符。</p>
<p>[]{#l116}</p>
<h3 id="514-双引号"><a class="header" href="#514-双引号">5.1.4: 双引号</a></h3>
<p>双引号允许内部进行某些，但不是所有形式的替换。更具体地说，它们允许参数展开、命令替换和算术替换，但不允许任何其他形式：进程替换不会发生，花括号和初始的波浪号和等号不会被展开，模式也不是特殊的。这里有一个表格；左边的每个表达式都是某个命令行参数，结果显示了如果它出现在引号外或双引号内被替换的内容。</p>
<pre><code>  表达式      引号外          双引号内
  ------------------------------------------------
  =(echo hi mum)  /tmp/zshTiqpL     =(echo hi mum)
  $ZSH_VERSION    4.0.1             4.0.1
  $(echo hi mum)  hi mum            hi mum
  $((6**2 + 6))   42                42
  {a,b}cd         acd bcd           {a,b}cd
  ~/foo           /home/pws/foo     ~/foo
  .zl*            .zlogin .zlogout  .zl*
</code></pre>
<p>那个 <code>/tmp/zshTiqpL</code> 可以是任何临时文件名，而且确实，其他一些替换在你的情况下也会有所不同。</p>
<p>You可能已经猜到 <code>${(qqq)string}</code> 会强制 <code>$string</code> 使用双引号来引用其特殊字符。与其他形式一样，这一切都得到了妥善处理——shell 知道哪些字符在双引号内需要引用，哪些不需要。</p>
<p><strong>双引号中的分词</strong>\</p>
<p>在允许替换的地方，双引号的（几乎）不变的副作用是分词被抑制了。你可以使用 <code>print -l</code> 来看到这一点，它每行打印一个参数：</p>
<pre><code>  % array=(one two)
  % print -l $(echo foo bar) $array
  foo
  bar
  one
  two
  % print -l "$(echo foo bar) $array"
  foo bar one two
</code></pre>
<p>这之所以是“几乎”不变，是因为参数替换允许你指定将进行正常的分词。有两种方法可以做到这一点；都使用符号 <code>@</code>。你可能从参数 <code>$@</code> 中记得这个，当它出现在双引号中时就有这种效果：脚本或函数的参数被分割成单词，就像一个普通的数组一样，只是空参数不会被移除。我在<a href="zshguide03.html#syntax">第三章</a>中详细地讲过这个。</p>
<p>这对于其他参数也以以下方式扩展：</p>
<pre><code>  % array=(one two three)
  % print -l "${array[@]}"
  one
  two
  three
</code></pre>
<p>更普遍地，对于所有形式的替换，使用另一个标志 <code>(@)</code>：</p>
<pre><code>  % print -l "${(@)array}"
  one
  two
  three
</code></pre>
<p><strong>关于下标的题外话</strong>\</p>
<p>带标志的版本可能不如另一个清晰，但它可以出现在很多不同的地方。例如，这里是如何在 zsh 中选取一个数组的切片：</p>
<pre><code>  % print -l ${array[2,-1]}
  two
  three
</code></pre>
<p>其中负数从数组的末尾开始计数。方括号中的数字被称为下标。这也可以得到 <code>(@)</code> 的处理：</p>
<pre><code>  % print -l "${(@)array[2,-1]}"
  two
  three
</code></pre>
<p>虽然可能不明显，但在这种情况下你可以使用另一种表示法：</p>
<pre><code>  % print -l "${array[@][2,-1]}"
  two
  three
</code></pre>
<p>shell 实际上可以处理参数替换中任意数量的下标，而不仅仅是一个；每个都应用于前一个的结果：</p>
<pre><code>  % print -l "${array[@][2,-1][1]}"
  two
</code></pre>
<p>你必须注意的是，最后一个下标选择了一个单词。你可以继续应用下标，但它们将只应用于该单词中的<em>字符</em>，而不是数组元素：</p>
<pre><code>  % print -l "${array[@][2,1][1][2,-1]}"
  wo
</code></pre>
<p>我们现在严重偏离了主题：下标当然会完全独立于单词是否被分割或出现在双引号中而工作。尽管在双引号中会发生单词的连接，但数组的下标仍然选择数组元素。这是参数展开规则应用顺序的结果。在 <code>zshexpn</code> 手册条目中有一个关于这个的冗长、复杂的部分（在那里查找标题“Rules”或在相应的 Info 或 HTML 文件的“Parameter Expansion”节点中查找）。</p>
<p><strong>带引号的命令替换的分词</strong>\</p>
<p>Zsh 有一个有用的特性，你可以强制 shell 将参数展开的规则应用于命令替换的结果。要看这在哪里可能有用，考虑特殊“命令替换”（尽管它完全在 shell 中处理，而不是通过运行外部命令）的情况，它将文件的内容放在命令行上：</p>
<pre><code>  % args() { print $#; }    # 报告参数数量
  % cat file
  Words on line one
  Words on line two
  % args $(&lt;file)
  8
  % args "$(&lt;file)"
  1
</code></pre>
<p>未引用的替换将文件分割成单个单词；引用的替换根本没有分割它。这些是标准的 shell 规则。</p>
<p>然而，很常见的情况是，你想要每行一个参数，而不是在行内按空格分割。这就是参数展开可以派上用场的地方。有一个标志 <code>(f)</code>，它表示“分割展开的结果，每行一个单词”。这里是如何在这种情况下使用它：</p>
<pre><code>  % args "${(f)$(&lt;file)}"
  2
</code></pre>
<p>在你通常会放参数名的地方，你放了命令替换，shell 会对那个的结果进行操作（注意它不会将结果视为参数名，而是视为一个值——这在下面会更详细地讨论）。双引号是必需的，因为否则文件在参数替换看到结果之前就已经被分割成单个单词了。你可以很容易地验证这两个参数是文件的各个行。我不记得 <code>f</code> 代表什么，但当它出现时，我们已经很快地用完了标志代码；Bart Schaefer 认为它代表“fold”，这至少可能帮助你记住它。</p>
<p>[]{#l117}</p>
<h3 id="515-反引号"><a class="header" href="#515-反引号">5.1.5: 反引号</a></h3>
<p>关于反引号，主要要说的是你应该使用另一种形式的命令替换。有两个好理由。</p>
<p>首先，另一种形式可以嵌套：</p>
<pre><code>  % print $(print $(print a word))
  a word
</code></pre>
<p>显然那是一个愚蠢的例子，但主要的一点是，在 shell 中，唯一应该出现未被引用的括号的地方是成对的（case 语句中的模式是一个例外，但模式周围的成对括号也是有效的，我在本指南中已经使用过那种形式）。因此你可以确信，任何格式良好的 shell 代码块都可以出现在命令替换内部。</p>
<p>这显然不适用于 <code>`...`</code>，即使基本效果相同。任何碰巧出现在反引号内代码块中的未被引用的 <code>`</code> 都会被视为引用的结束。</p>
<p>第二个原因，与此密切相关，是可能很难决定在反引号表达式内部需要多少层引用。考虑：</p>
<pre><code>  % print "`echo \"hello\"`"
  hello
  % print "$(echo \"hello\")"
  "hello"
</code></pre>
<p>很难解释这里的区别是什么，而不挥舞我的手，这会妨碍我打字，但本质上的一点其实与嵌套相同：你不能用反引号来做，因为开始和结束符号是相同的，但你可以用括号来做。所以在第二种情况下，毫无疑问，嵌入的命令行，<code>echo \"hello\"</code>，将被完全视为好像它出现在命令替换之外；而在第一种情况下，引号内的引号必须被，嗯，引用。</p>
<p>因此，在</p>
<pre><code>  % print "$(echo "hello")"
  hello
</code></pre>
<p>你需要小心：乍一看，成对的双引号包围着 <code>$(echo </code> 和 <code>)</code>，但它们没有，它们是通过替换嵌套的。你在参数替换中也看到了同样的事情：</p>
<pre><code>  % unset foo
  % print "${foo:-"a string"}"
  a string
</code></pre>
<p>第三个，不太好的，使用带括号形式的理由是，否则你更老练的朋友会嘲笑你。在这个复杂的世界里，同伴压力是如此重要。</p>
<p>关于命令替换，我就说这么多，因为我在<a href="zshguide03.html#syntax">第三章</a>讨论基本语法时已经说了很多了。</p>
<p>[]{#l118}</p>
<h2 id="52-修饰符及其修饰对象-1"><a class="header" href="#52-修饰符及其修饰对象-1">5.2: 修饰符及其修饰对象</a></h2>
<p>修饰符是在<a href="zshguide02.html#init">第二章</a>中我谈论“bang history”时引入的，因为它们来自那里。然而，在 zsh 中，它们可以在其他几个地方使用。它们在每种情况下的形式都相同：一个冒号，后面跟着一个字母，该字母是修饰符所做事情的代码，可能（在替换的情况下）后面跟着一些其他字符串。所以，为了唤醒你的记忆，除非你设置了 <code>NO_BANG_HIST</code>：</p>
<pre><code>  % print ~/file
  /home/pws/file
  % print !-1:t
  file
</code></pre>
<p>其中 <code>:t</code> 取文件名的尾部（非目录部分）。</p>
<p>第二个用途是在参数中。这很自然地延续了下去。请注意，这和任何后来使用修饰符的情况都不依赖于 <code>NO_BANG_HIST</code> 选项；那纯粹是为历史准备的。</p>
<pre><code>  % param=~/file
  % print ${param:t}
  file
</code></pre>
<p>通常你可以省略参数替换中的花括号，但为了清晰起见，我倾向于在有修饰符时使用它们。无论修饰符来自哪里，都使用 shell 的相同部分，这一事实有一定的后果：</p>
<pre><code>  % print foo
  foo
  % ^foo^bar
  bar
  % param='this sentence contains a foo.'
  % print ${param:&amp;}
  this sentence contains a bar.
</code></pre>
<p>与号重复上一次的替换，这对于参数修饰符和历史修饰符是相同的。我发现参数修饰符比历史修饰符更有用；提取路径的头部或尾部是对参数非常常见的操作。</p>
<p>修饰符也足够聪明，可以以一种有用的方式处理数组。请注意，这对于历史展开中的参数集是不成立的；<code>:t</code> 在那种情况下只会提取一个尾部，这可能不完全是你所期望的：</p>
<pre><code>  % print a sentence with a /real/live/bogus/path in it.
  % print !!:t
  path in it.
</code></pre>
<p>然而，数组<em>是</em>以你可能希望的方式处理的：</p>
<pre><code>  % array=(~/.zshenv ~/.zshrc ~/.zlogout)
  % print ${array:t}
  .zshenv .zshrc .zlogout
</code></pre>
<p>同样的逻辑也适用于替换。这意味着数组中每个元素的第一个匹配项都会被替换：</p>
<pre><code>  % array=('a bar of chocolate' 'a bar of barflies' 
  array&gt; 'a barrier of barns')
  % print ${array:s/bar/car/}
  a car of chocolate a car of barflies a carrier of barns
</code></pre>
<p>除非，当然，你做一个全局替换：</p>
<pre><code>  % print ${array:gs/bar/car/}
  a car of chocolate a car of carflies a carrier of carns
</code></pre>
<p>然而，请注意，参数替换有其自己<em>更</em>强大的等价物，它做模式匹配、部分替换原始字符串的修改部分等等。我们会在适当的时候讲到这个。</p>
<p>修饰符的最后一种用法是在文件名生成中，即通配。由于这通常通过在命令行上有特殊字符来工作，而修饰符只包含普通字符，所以语法有点不同：</p>
<pre><code>  % print *.c
  parser.c lexer.c input.c output.c
  % print *.c(:r)
  parser lexer input output
</code></pre>
<p>所以你需要用括号把它们括起来。这是“通配限定符”的一个特例，你将在下面遇到；你可以混合使用它们，但修饰符必须出现在末尾。例如，</p>
<pre><code>  % print -l ~/stuff/*
  /home/pws/stuff/onefile.c
  /home/pws/stuff/twofile.c
  /home/pws/stuff/subdir
  % print ~/stuff/*(.:r:t)
  onefile twofile
</code></pre>
<p>通配限定符 <code>.</code> 指定文件必须是常规文件，即不是目录也不是某种特殊文件。<code>:r</code> 从结果中移除后缀，<code>:t</code> 去掉目录部分。因此，如果你设置了 <code>NO_BARE_GLOB_QUAL</code> 选项，文件名修饰符将被关闭。</p>
<p>关于带文件名的修饰符，最后有两点需要注意。首先，它是唯一一种结果不再是文件名的通配形式；它总是在最后执行，在所有正常的文件名生成之后。大概，在上面的例子中，插入到命令行中的单词实际上不再对应于一个真实的文件了。</p>
<p>其次，虽然如果命令行上的单词不是一个模式，而是一个带修饰符的普通单词，它<em>确实</em>有效，但如果那个模式，在修改之前，不对应于一个真实的文件，它就<em>不</em>起作用。所以 <code>foo.c(:r)</code> 只有在当前目录中有 <code>foo.c</code> 时才会去掉后缀。鉴于匹配文件的尝试会启动通配系统，包括修饰符，这是完全合乎逻辑的。如果这对你是个问题，有办法绕过；例如，在像这样的简单情况下手动插入正确的值，或者更现实的，将值存储在一个参数中并对其应用修饰符。</p>
<p>[]{#l119}</p>
<h2 id="53-进程替换-1"><a class="header" href="#53-进程替换-1">5.3: 进程替换</a></h2>
<p>关于进程替换，我没有太多新的要说，但我有一个我发现它很有用的例子。如果你使用分页器 <code>less</code>，你可能知道它有预处理你查看的文件的功能，例如通过环境变量 <code>$LESSOPEN</code>（可能还有 <code>$LESSCLOSE</code>）临时解压文件。Zsh 可以非常容易地，而且在我完全不偏不倚的看来，更方便地做同样的事情。这里是我的 zsh 函数前端到 less 的一个子集——或者实际上是任何分页器，这里由标准环境变量 <code>$PAGER</code> 给出，默认为 <code>less</code>。如果你愿意，你可以在那个点硬编码任何文件显示命令。</p>
<pre><code>  integer i=1
  local args arg
  args=($*)

  for arg in $*; do
    case $arg in
      (*.bz2) args[$i]="=(bunzip2 -c ${(q)arg})"
              ;;
      # 这假设你的 zcat 是与 gzip 一起安装的那个：
      (*.(gz|Z)) args[$i]="=(zcat ${(q)arg})"
                 ;;
      (*) args=${(q)arg}
          ;;
    esac
    (( i++ ))
  done

  eval command ${PAGER:-less} $args
</code></pre>
<p>主要有趣的部分是数组 <code>$args</code> 的元素是如何被替换的。每个参数都被赋予了额外的一层引号，通过 <code>(q)</code>，原因在于最后的 <code>eval</code>；<code>$args</code> 首先被转换成一个文字字符数组，因此需要引用以保护特殊字符。没有那个，带有空格或星号等的文件名将无法正确显示。</p>
<p><code>eval</code> 在那里的原因是为了让进程替换在运行分页器时在命令行上被评估，而不是之前。它们被赋回给 <code>$args</code> 的元素时是带引号的，所以在那一点上不会被评估。效果是将：</p>
<pre><code>  less file.gz file.txt
</code></pre>
<p>变成</p>
<pre><code>  less =(zcat file.gz) file.txt
</code></pre>
<p>函数末尾的 <code>command</code> 在那里只是为了以防函数与分页器同名（即在这个例子中是 <code>less</code>）；它强制调用外部命令而不是函数。进程替换在这种情况下是理想的；它为 <code>less</code> 提供了一个文件名，解压后的 <code>file.gz</code> 的内容被发送到该文件，并且在命令退出后它会删除该文件。此外，替换的发生方式使得你仍然可以像通常使用 less 那样在命令行上指定多个文件。唯一的问题是出现在 <code>less</code> 提示符中的文件名是无意义的。</p>
<p>如果你没见过，<code>bzip2</code> 是一个与 <code>gzip</code> 非常相似的程序，它的使用方式几乎相同，但它提供更好的压缩。</p>
<p>输出进程替换有一个不便之处，就像 multios 一样。</p>
<pre><code>  echo hello &gt; &gt;(sed s/hello/goodbye)
</code></pre>
<p>shell 派生 <code>sed</code> 进程来处理来自命令行的输出——然后就忘了它。它不等待它（至少，直到它退出后，它才会使用 <code>wait</code> 系统调用来清理）。所以依赖于进程的结果在下一个命令中可用是危险的。如果你交互式地尝试它，事实上，你很可能会发现在 <code>sed</code> 的输出显示在终端之前，下一个提示符就已经打印出来了。这可能被认为是一个 bug，但修复起来相当困难。</p>
<p>[]{#l120}</p>
<h2 id="54-参数替换-1"><a class="header" href="#54-参数替换-1">5.4: 参数替换</a></h2>
<p>你可能从上面可以看出，参数替换是 zsh 命令行转换能力的许多核心所在。更重要的是，我们甚至还没有覆盖到所提供的功能的很大一部分。</p>
<p>[]{#l121}</p>
<h3 id="541-使用数组"><a class="header" href="#541-使用数组">5.4.1: 使用数组</a></h3>
<p>zsh 中的数组语法相当强大（惊讶吗？）；只是不要期望它像，比如说，perl 那样高效。像 zsh 的其他特性一样，它的存在是为了让用户的生活更轻松，而不是让你的电脑运行得飞快。</p>
<p>我已经零星地讲了如何设置数组，以及如何提取它们的部分——以下说明了这一点：</p>
<pre><code>  % array=(one two three four)
  % print ${array}
  one two three four
  % print ${array[3]}
  three
  % print ${array[2,-1]}
  two three four
</code></pre>
<p>记住，如果你想让数组成为函数局部的，你需要 <code>typeset</code> 或等价物。简洁的方法是 <code>typeset -a</code>，它创建一个空数组，但只要你在尝试使用数组之前给它赋值，任何旧的 <code>typeset</code> 都可以。</p>
<p>你可以使用数组索引和数组切片表示法来给数组赋值，换句话说，在 <code>=</code> 的左边：</p>
<pre><code>  % array=(what kind of fool am i)
  % array[2]=species
  % print $array
  what species of fool am i
  % array[2]=(a piece)
  % print $array
  what a piece of fool am i
  % array[-3,-1]=(work is a man)
  % print $array
  what a piece of work is a man
</code></pre>
<p>所以你可以用单个元素替换数组的单个元素，或者用一个数组切片；同样，你可以一次性用一个不同长度的切片替换一个切片——只有你明确告诉它要替换的部分会被改变，其余的保持不变，可能会被移动以为新内容腾出空间。这类似于 perl 的 <code>splice</code> 命令，只是这一次可能更容易记住。注意，你不应该在左边提供任何花括号。表达式出现在赋值中就足以触发下标的特殊行为，即使 <code>KSH_ARRAYS</code> 生效——尽管在这种情况下你需要从你的下标中减一。</p>
<p>你也可以移除中间的部分，但注意你应该使用一个空数组：</p>
<pre><code>  % array=(one two three four)
  % print $#array
  4
  % array[2]=
  % print $#array
  4
  % array[2]=()
  % print $#array
  3
</code></pre>
<p>第一个赋值将元素 2 设置为空字符串，它没有移除它。第二个用一个长度为零的数组替换了该数组元素，这确实移除了它。</p>
<p>就像参数替换有用于特殊目的的标志一样，下标也有。你可以强制它们搜索数组，匹配值。你可以返回匹配的值（(r)everse 下标）：</p>
<pre><code>  % array=(se vuol ballare signor contino)
  % print ${array[(r)s*]}
  se
  % print ${array[(R)s*]}
  signor
</code></pre>
<p><code>(r)</code> 标志接受一个模式并替换匹配的数组的第一个元素，而 <code>(R)</code> 标志做同样的事情，但从数组的末尾开始。如果没有匹配，你会得到空字符串；像往常一样，对于参数，如果它是未引用参数中唯一的东西，它将被省略。再次使用我们的 <code>args</code> 函数来计算传递给命令的参数数量：</p>
<pre><code>  % array=(some words)
  % args() { print $#; }
  % args ${array[(r)s*]}
  1
  % args ${array[(r)X*]}
  0
  % args "${array[(r)X*]}"
  1
</code></pre>
<p>在最后一种情况下，空字符串被引用，并作为单个空参数传递下去。</p>
<p>你也可以返回匹配的索引；<code>(i)</code> 从头开始匹配，<code>(I)</code> 从尾开始。</p>
<pre><code>  % array=(se vuol venire nella mia scuola)
  % print ${array[(i)v*]}
  2
  % print ${array[(I)v*]}
  3  
</code></pre>
<p>第一次匹配“vuol”，第二次匹配“venire”。如果它们不匹配会发生什么可能有点出乎意料，但相当合乎逻辑：你会得到下一个索引。换句话说，在末尾匹配失败会给你数组的长度加一，在开头匹配失败会给你零，所以：</p>
<pre><code>  array=(three egregious words)
  for pat in '*e*e*' '*a*a*'; do
    if [[ ${array[(i)$pat]} -le ${#array} ]]; then
      print "Pattern $pat matched in array: ${array[(r)$pat]}."
    else
      print "Pattern $pat failed to match in array"
    fi
  done
</code></pre>
<p>打印：</p>
<pre><code>  Pattern *e*e* matched in array: three.
  Pattern *a*a* failed to match in array
</code></pre>
<p>如果你调整那段代码，你会看到你得到的索引是 1 和 4。注意 <code>$pat</code> 中的字符被当作一个模式，即使把 <code>$pat</code> 放在命令行上通常只会产生字符本身。下标在这方面是特殊的；试图在这一点上控制语法有点棘手。在手册的 <code>zshparam</code> 手册页的“Subscript Parsing”部分或“Array Parameters”信息节点中有更详细的描述；要引用 <code>pat</code> 中的字符，你实际上需要提供命令行字符串 <code>'\*e\*e\*'</code> 和 <code>'\*a\*a\*'</code>。只要到处咕哝“额外的模式扩展层”，大家就会认为你知道你在说什么（这对我来说，断断续续地有效）。</p>
<p>目前没有办法用下标标志从普通数组中提取一个完整的匹配集。然而，我们将在下面看到其他方法。</p>
<p>[]{#l122}</p>
<h3 id="542-使用关联数组"><a class="header" href="#542-使用关联数组">5.4.2: 使用关联数组</a></h3>
<p>如果你忘了关联数组，请回顾<a href="zshguide03.html#syntax">第三章</a>。它们像普通数组一样接受下标，但这里的下标是与存储在数组元素中的值相关联的任意字符串（或键）。记住，你需要使用 <code>typeset -A</code> 来创建一个，或者 <code>typeset</code> 的亲戚们使用相同的选项。这意味着如果你在函数内部创建它，它将被限制在局部作用域，所以如果你想创建一个全局关联数组，你还需要给出 <code>-g</code> 标志。这对于关联数组尤其常见，它们经常用于存储全局信息，如配置细节。</p>
<p>从关联数组中检索信息可能会让你陷入一些已经在使用数组的下标标志时暗示过的问题。然而，由于正常的下标不会激活模式，这里有一个解决方法：将下标变成另一个参数：</p>
<pre><code>  % typeset -A assoc
  % assoc=(key value Shlüssel Wert clavis valor)
  % subscript='key'
  % print ${assoc[$subscript]}
  value  
</code></pre>
<p>我在这里用了相当无聊的键，但它们可以是任何字符串：</p>
<pre><code>  % assoc=(']' right\ square\ bracket '*' asterisk '@' at\ sign)
  % subscript=']'
  % print ${assoc[$subscript]}
  right square bracket
</code></pre>
<p>而<em>那个</em>更难用另一种方式得到。尽管如此，如果你定义自己的键，你通常会使用简单的单词，在这种情况下，它们可以愉快地直接出现在方括号中。</p>
<p>我在<a href="zshguide03.html#syntax">第三章</a>中介绍了两个参数标志，<code>(k)</code> 和 <code>(v)</code>：</p>
<pre><code>  % print ${(k)assoc}
  * ] @
</code></pre>
<p>打印出键，而</p>
<pre><code>  % print ${(kv)assoc}
  * asterisk ] right square bracket @ at sign
</code></pre>
<p>剩下的两种可能性做同样的事情：</p>
<pre><code>  % print ${(v)assoc}
  asterisk right square bracket at sign
  % print ${assoc}
  asterisk right square bracket at sign
</code></pre>
<p>你现在知道这些是应用于替换的更大技巧家族的一部分。没有什么能阻止你组合标志：</p>
<pre><code>  % print -r ${(qkv)assoc}
  \* asterisk \ ] right\ square\ bracket @ at\ sign
</code></pre>
<p>这有助于看清分词。不要忘记 <code>print -l</code> 技巧，用于分离不同的单词，从而分离数组和关联数组的元素：</p>
<pre><code>  % print -l ${(kv)assoc}
  *
  asterisk
  ]
  right square bracket
  @
  at sign
</code></pre>
<p>这清晰多了。像往常一样，如果你用 <code>SH_WORD_SPLIT</code> 进行非 zsh 的活动，这会失败，但明智地使用 <code>@</code>，无论是作为标志还是下标，以及双引号，总是有效的：</p>
<pre><code>  % print -l "${(@kv)assoc}"
  *
  asterisk
  ]
  right square bracket
  @
  at sign
</code></pre>
<p>无论选项设置如何。</p>
<p>除了下标，关联数组和普通数组之间的第二个主要区别是前者没有定义的顺序。如果你使用过 Perl，这将完全熟悉；这里的原则是相同的。然而，zsh 根本没有关联数组切片的概念，即使是作为一种便利。你可以赋单个元素或整个关联数组——记住在第二种情况下，右侧必须由键/值对组成——但你不能赋子组。任何使用带逗号的切片表示法的尝试都会遇到严厉的错误消息。</p>
<p>然而，zsh 确实有额外的下标标志，供你匹配和检索一个或多个元素。如果你使用一个以 <code>(i)</code> 标志为前缀的下标，而不是一个普通的下标，shell 将搜索一个匹配的键（而不是值），并返回它。这被故意设计成与搜索普通数组以获取其键（在这种情况下只是一个数字，即索引）相同，但请注意，这次它不匹配值，它确实匹配并返回键：</p>
<pre><code>  % typeset -A assoc
  % assoc=(fred third\ man finnbar slip roger gully trevor long\ off)
  % print ${assoc[(i)f*]}
  fred
</code></pre>
<p>你仍然可以使用参数标志 <code>(k)</code> 和 <code>(v)</code> 来告诉 shell 你想返回键和/或值的哪一部分：</p>
<pre><code>  % print ${(kv)assoc[(i)f*]}
  fred third man
</code></pre>
<p>注意分工。下标标志告诉 shell 要匹配什么，而参数标志告诉它你实际上想看到匹配元素的哪一部分。</p>
<p>由于关联数组的本质上是随机排序的，你无法在这里判断是选择 fred 还是 finnbar。然而，你可以使用大写形式 <code>(I)</code> 来告诉 shell 检索所有匹配项。这一次，让我们看看键被匹配的元素的值：</p>
<pre><code>  % print -l ${(v)assoc[(I)f*]}
  third man
  slip
</code></pre>
<p>在这里我们也得到了 <code>finnbar</code> 占据的位置。关于模式的规则与普通数组中的 <code>(r)</code> 相同——下标被视为一个模式，即使它本身来自一个参数替换。</p>
<p>你可能不会惊讶地听到，下标标志 <code>(r)</code> 和 <code>(R)</code> 尝试匹配关联数组的值而不是其键。这些也打印出实际匹配的部分，这里是值，除非你使用参数标志。</p>
<pre><code>  % print ${assoc[(r)*i*]}
  third man
  % print ${(k)assoc[(R)*i*]}
  fred finnbar
</code></pre>
<p>还有一对与关联数组特别相关的下标标志，<code>(k)</code> 和 <code>(K)</code>。它们的工作方式有点像一个 case 语句：下标被视为字符串，而关联数组的键被视为模式，而不是反过来。使用 <code>(k)</code>，匹配下标的第一个键的值被替换；使用 <code>(K)</code>，所有匹配键的值都被替换</p>
<pre><code>  % typeset -A assoc
  % assoc=('[0-9]' digit '[a-zA-Z]' letter '[^0-9a-zA-Z]' neither)
  % print ${assoc[(k)0]}
  digit
  % print ${assoc[(k)_]}
  neither
</code></pre>
<p>如果你仍然感到困惑，第一个下标中的 <code>0</code> 被当作一个字符串，<code>$assoc</code> 中的所有键依次被当作模式，有点像</p>
<pre><code>  case 0 in
    ([0-9]) print digit
            ;;
    ([a-zA-Z]) print letter
               ;;
    ([^0-9a-zA-Z]) print neither
                   ;;
  esac
</code></pre>
<p>这与 case 语句中的选择有一个重要的不同之处，那就是你不能依赖比较的顺序，所以你不能依赖于在更具体的模式之后匹配更通用的模式。你只需要使用足够明确的键来只匹配你想要匹配的字符串，而不匹配其他任何东西。这就是为什么我们选择模式 <code>[^0-9a-zA-Z]</code> 而不是像我们在 case 语句中可能会使用的 <code>*</code>。</p>
<p>我说过存储配置信息是关联数组的一个常见用途，但 shell 有一个更强大的方法来做到这一点：样式，这将在下一章关于可编程补全的讨论中占据重要位置。样式相对于关联数组的主要优点是它们可以被设置为上下文敏感的；你可以很容易地让同一个样式全局返回相同的值，或者让它有一个默认值但在一个特定的上下文中有一个不同的值，或者在不同的地方给它一大堆不同的值。每个 shell 应用程序都可以决定“上下文”的含义；你不必受限于补全系统使用的方案，或任何类似的东西。以补全系统的方式使用分层上下文意味着很容易为不同的模块创建不冲突的样式集。</p>
<p>最后，这里是 perl 和 zsh 中关联数组的一些用法的比较。</p>
<pre><code>      perl                          zsh
  -----------------------------------------------------------------
  %hash = qw(key value);         typeset -A hash; hash=(key value)
  $hash{key}                     ${hash[key]}
  keys %hash                     ${(k)hash}
  values %hash                   ${(v)hash}
  %hash2 = %hash;                typeset -A hash2; hash2=("${(@kv)hash}")
  unset %hash;                   unset hash
  if (exists $hash{key}) {       if (( ${+hash[key]} )); then
    ...                            ...
  }                              fi
</code></pre>
<p>最后一个提醒：如果你在函数内部创建的关联数组需要在函数结束后仍然存在，你应该用 <code>typeset -gA</code> 来创建它们，这会将它们放入周围的作用域。<code>-g</code> 标志当然对所有类型的参数都很有用，但关联数组是唯一一种在你在正确的上下文中给它赋值时不会自动产生的类型；因此，这个标志在这里特别值得注意。</p>
<p>[]{#l123}</p>
<h3 id="543-替换的替换首尾处理等"><a class="header" href="#543-替换的替换首尾处理等">5.4.3: 替换的替换、首尾处理等。</a></h3>
<p>你可以对参数替换的结果进行许多转换。最强大的涉及模式的使用。为此，你对模式了解得越多越好，所以我将保留一些最古怪的解释，直到我更详细地讲解模式之后。特别是，如果你知道如何告诉 shell 标记它已经匹配的子表达式以便将来提取，那会很有用。然而，你只需使用所有 shell 共有的基本模式就可以做一些非常有用的事情。</p>
<p><strong>标准形式：长度</strong>\</p>
<p>我将把 zsh 特有的形式分开，从所有源自 Bourne shell 的 shell 中都出现的一些形式开始。手册中一如既往地给出了一个更紧凑（读作：简洁）的列表。</p>
<p>一些简单的形式不使用模式。首先，替换 <code>${#</code><em>param</em><code>}</code> 输出 <code>$</code><em>param</em> 的长度。在 zsh 中，你在这里不需要花括号，尽管在大多数其他具有此功能的 shell 中你需要。请注意，<code>${#}</code> 本身是命令行参数数组中的参数数量，这就是为什么明确使用花括号更清晰的原因。</p>
<p><code>$#</code> 对标量值和数组值的处理方式不同；在前一种情况下，它给出字符长度，在后一种情况下，它给出元素数量。请注意，我说的是“值”，而不是“参数”——你必须弄清楚替换是给你一个标量还是一个数组：</p>
<pre><code>  % print ${#path}
  8
  % print ${#path[1]}
  13
</code></pre>
<p>第一个结果显示我的路径中有 8 个目录，后者显示第一个目录（实际上是 <code>/home/pws/bin</code>）有 13 个字符。你应该在嵌套替换时记住这一点，如下所述，它也可以返回一个数组或一个标量。</p>
<p>早期版本的 zsh 如果表达式在双引号中，或者在 shell 将表达式评估为单个单词的任何地方，总是返回一个字符计数，但这不再发生了；它只取决于值的类型。然而，你可以通过使用 <code>(c)</code> 标志强制 shell 计算字符，通过使用 <code>(w)</code> 标志计算单词（即使在标量中，它也会在必要时进行分割）：</p>
<pre><code>  % print ${#PATH}
  84
  % print ${(c)#path}
  84
  % foo="three scalar words"
  % print ${(w)#foo}
  3
</code></pre>
<p>比较前两个，你会看到数组的字符计数包括用于分隔的空格（等于 <code>$PATH</code> 中分隔元素的冒号数量）。<code>(w)</code> 的一个亲戚叫做 <code>(W)</code>，它将多个单词分隔符视为空长度的单词：</p>
<pre><code>  % foo="three  well-spaced  word"
  % print ${(w)#foo}
  3
  % print ${(W)#foo}
  5
</code></pre>
<p>比 <code>(w)</code> 多了两个单词，后者将空格组视为一个。作为参数标志，这些语法的修改是 zsh 特有的。</p>
<p>请注意，如果你在算术上下文中使用长度（在 <code>((...))</code> 或 <code>$((...))</code> 内部），你必须包含前导的 <code>$</code>，而替换参数本身时则不需要。那是因为 <code>#foo</code> 在这里意味着不同的东西——<code>$foo</code> 中第一个字符在 ASCII 字符集（或者如果你使用的是扩展字符集，则是它的任何扩展）中的编号。</p>
<p><strong>标准形式：条件替换</strong>\</p>
<p>下一组替换是一整系列，其中参数后跟一个可选的冒号，然后是 <code>-</code>、<code>=</code>、<code>+</code> 或 <code>?</code>。冒号在每种情况下的效果都相同：没有冒号，shell 在执行操作前测试参数是否已设置，而有冒号，它测试参数是否具有非零长度。</p>
<p>最简单的是 <code>${</code><em>param</em><code>:-</code><em>value</em><code>}</code>。如果 <code>$param</code> 具有非零长度（没有冒号，如果它根本被设置了），则使用它的值，否则使用提供的 <em>value</em>。假设 <code>$foo</code> 在以下开始时没有被设置（无论这看起来多么不可能）：</p>
<pre><code>  % print ${foo-bar}
  bar
  % foo=''
  % print ${foo-bar}
  
  % print ${foo:-bar}
  bar
  % foo='please no anything but bar'
  % print ${foo:-bar}
  please no anything but bar
</code></pre>
<p>更常用的是带冒号的形式。一个原因是，在函数中，你通常会在使用参数之前用 <code>typeset</code> 创建它，在这种情况下，它总是存在，初始长度为零，所以另一种形式永远不会使用默认值。我将用冒号来描述其他三种类型。</p>
<p><code>${</code><em>param</em><code>:=</code><em>value</em><code>}</code> 与前一种类型类似，但在这种情况下，shell 不仅会将 <em>value</em> 替换到行中，如果（且仅当）它这样做时，它还会将其赋给 <em>param</em>。这导致了脚本和函数中以下常见的用法：</p>
<pre><code>  : ${MYPARAM:=default}  ${OTHERPARAM:=otherdefault}
</code></pre>
<p>如果用户已经设置了 <code>$MYPARAM</code>，什么也不会发生，否则它将被设置为 <code>default</code>，<code>${OTHERPARAM}</code> 也类似。<code>:</code> 命令在命令行被处理后什么也不做，只返回 true。</p>
<p><code>${</code><em>param</em><code>:+</code><em>value</em><code>}</code> 是 <code>:-</code> 的反面，逻辑上足够：如果参数<em>不</em>具有零长度，则替换 <em>value</em>。在这种情况下，<em>value</em> 通常会是另一个参数替换：</p>
<pre><code>  print ${value:+"the value of value is $value"}
</code></pre>
<p>仅当 <code>$#value</code> 大于零时才打印该字符串。请注意，<code>+</code> 后面可以出现的几乎是 shell 可以解析的任何单个单词；所有通常的单单词替换（所以不包括通配）都将应用于它，并且引号将像往常一样工作。这也适用于 <code>:-</code> 和 <code>:=</code> 后面的值。另一个常见的技巧可能值得一提：</p>
<pre><code>  print ${1+"$@"}
</code></pre>
<p>如果第一个位置参数被设置，则替换所有传递的位置参数（这里你不需要冒号）。在一些旧的 shell 中这是必要的，因为当没有参数传递时，单独的 <code>"$@"</code> 会给你一个单个的空参数而不是没有参数。在 zsh 中，以及在大多数现代的 Bourne 派生 shell 中，这个变通方法是不必要的。然而，zsh 的处理有一个 bug；请参见第三章中关于函数参数的部分。</p>
<p>最后一种类型不常用（意思是我从未使用过）：<code>${</code><em>param</em><code>?</code><em>message</em><code>}</code> 测试 <em>param</em> 是否被设置（无冒号），如果未设置，则打印消息并退出 shell。交互式 shell 不会退出，但它会立即将你返回到提示符，跳过任何其他已存储待执行的内容。这是一个基本的安全特性，有点像 C 程序中的 <code>assert</code>；大多数 shell 程序员似乎通过更详细的测试来处理缺少参数设置的情况。在用于交互式使用的短 shell 函数中，它非常简洁：</p>
<pre><code>  mless() { mtype ${@:?missing filename} | $PAGER }
</code></pre>
<p><strong>标准形式：模式移除</strong>\</p>
<p>大多数更复杂的类 Bourne shell 定义了两对模式运算符，我称之为“首尾”运算符。一对（使用 <code>#</code> 和 <code>##</code>）从字符串的头部移除给定的模式，返回其余部分，而另一对（使用 <code>%</code> 和 <code>%%</code>）从字符串的尾部移除一个模式。在每种情况下，带一个符号的形式移除最短的匹配模式，而带两个符号的形式移除最长的匹配模式。两个典型的用法是：</p>
<pre><code>  % print $HOME
  /home/pws
  % print ${HOME##*/}
  pws
  % print ${HOME%/*}
  /home
</code></pre>
<p>在这里，它们与 <code>${HOME:t}</code> 和 <code>${HOME:h}</code> 有相同的效果，在 zsh 中你更可能使用后者。然而，如你所见，模式形式要通用得多。注意与以下的不同：</p>
<pre><code>  % print ${HOME#*/}
  home/pws
  % print ${HOME%%/*}
</code></pre>
<p>其中，头部 <code>*/</code> 的最短匹配只是第一个斜杠，因为 <code>*</code> 可以匹配空字符串，而尾部 <code>/*</code> 的最长匹配是整个字符串，一直回到第一个斜杠。虽然这些是标准形式，但请记住，zsh 模式的全部功能都是可用的。</p>
<p>你如何记住哪个运算符做什么？较长的形式做较长的匹配可能很容易记住。记住 <code>#</code> 在头部移除，<code>%</code> 在尾部移除则更难。试着想“hash”和“head”（如果你称它为“pound sign”，而它根本不是，因为英镑符号看起来像 <code>£</code>，你不会得到我的同情），以及“percent”和“posterior”。这对我从来没用过，但也许我只是没有那种精神纪律。Oliver Kiddle 指出，在标准的美国键盘上，<code>#</code> 更靠左（头部）。在我的英国键盘上，不幸的是，<code>#</code> 就在回车键旁边，尽管在这里与“pound sign”的混淆会唤醒你的记忆。</p>
<p>最重要的事情要记住是：这个表示法不是我们的错。无论如何，抱歉。顺便说一句，请注意，在模式运算符的情况下，没有关于冒号的奇怪事情。（嗯——除了下面提到的 zsh 变体。）</p>
<p><strong>Zsh 特有的参数替换</strong>\</p>
<p>现在是一些 zsh 对使用我刚刚给出的参数替换形式以及一些类似但不同的形式的增强。</p>
<p>一个简单的增强是，除了 <code>${</code><em>param</em><code>=</code><em>value</em><code>}</code> 和 <code>${</code><em>param</em><code>:=</code><em>value</em><code>}</code>，zsh 还有 <code>${</code><em>param</em><code>::=</code><em>value</em><code>}</code>，它执行一个无条件的赋值，并把值放在命令行上。它与使用普通赋值，然后是普通参数替换并没有真正的不同，只是 zsh 用户喜欢密集的代码。</p>
<p>所有赋值类型都受参数标志 <code>A</code> 和 <code>AA</code> 的影响，它们告诉 shell 执行数组和关联数组赋值（在第二种情况下，你像往常一样需要键/值对）。然而，你需要对数组元素和分词小心一点：</p>
<pre><code>  % print -l ${(A)foo::=one two three four}
  one two three four
  % print ${#foo}
  1
</code></pre>
<p>那确实使 <code>$foo</code> 成了一个数组，但将参数视为一个标量值并将其赋给第一个元素。有一个解决方法：</p>
<pre><code>  % print -l ${(A)=foo::=one two three four}
  one
  two
  three
  four
  % print ${#foo}
  4
</code></pre>
<p>在这里，参数名前的 <code>=</code> 与其他的效果完全不同：它打开了分词功能，就好像 <code>SH_WORD_SPLIT</code> 选项生效一样。你可能还记得我在<a href="zshguide03.html#syntax">第三章</a>的“函数参数”部分详细地讲过这个。</p>
<p>然而，你应该小心，因为更复杂的在参数值内放置数组的尝试很容易让你误入歧途。使用 <code>*array*</code>=<code>(*\...*)</code> 或 <code>set -A</code> <em>...</em>` 表示法通常要容易得多。</p>
<p>一个非常有用的 zsh 增强是表示法 <code>${+foo}</code>，如果 <code>$foo</code> 被设置则返回 1，否则返回 0。你可以在算术表达式中使用这个。这是一种比更标准的 <code>${foo?goodbye}</code> 表示法更灵活地处理可能未设置的参数的方法，因此 zsh 程序员更好地使用它。表示法“plus foo”表示“foo is set”也应该相当好记。一个更标准的做法（由 David Korn 指出）是 <code>0${foo+1}</code>，如果 <code>$foo</code> 未设置则给出 0，如果设置了则给出 01。</p>
<p><strong>参数标志和模式替换</strong>\</p>
<p>Zsh 通过一些参数标志增加了“首尾”运算符的用处。通常这些会显示移除某个匹配部分后剩下的内容。然而，使用 <code>(M)</code> 标志，shell 会转而显示匹配的部分。<code>(R)</code> 标志是相反的，显示其余部分：在正常情况下，这不那么有用，因为你默认得到的就是这个。只有当你将它与其他标志结合使用时，它才开始变得有用。</p>
<p>接下来，zsh 允许你匹配子字符串，而不仅仅是头部或尾部。你可以通过给 <code>#</code> 或 <code>%</code> 模式匹配形式加上 <code>(S)</code> 标志来做到这一点。这里的区别在于 shell 是从字符串的开头还是结尾开始搜索匹配的子字符串。让我们来看</p>
<pre><code>  foo='where I was huge lizards walked here and there'
</code></pre>
<p>看看我们匹配 <code>h*e</code> 会得到什么：</p>
<pre><code>  % print -l ${(S)foo#h*e} ${(S)foo##h*e} ${(S)foo%h*e} ${(S)foo%%h*e}
  wre I was huge lizards walked here and there
  w
  where I was huge lizards walked here and tre
  where I was huge lizards walked here and t
</code></pre>
<p>乍一看有一些奇怪的差异，但情况是这样的。在第一种情况下，<code>#</code> shell 向前查找，直到找到 <code>h*e</code> 的匹配，并取最短的，即第一个单词中的 <code>he</code>。对于 <code>##</code>，匹配在同一点成功，但最长匹配延伸到字符串末尾的 <code>e</code>。对于另外两种形式，shell 从末尾向后扫描，并在到达有匹配的起点时立即停止。对于 <code>%</code> 和 <code>%%</code>，这都是最后一个 <code>h</code>，但前者匹配 <code>he</code>，后者匹配 <code>here</code>。</p>
<p>你可以通过使用 <code>(I)</code> 标志来指定一个数字索引来扩展这个功能。索引需要被界定，通常，但不一定，用冒号。然后 shell 会向前或向后扫描，取决于使用的形式，直到找到第 <code>(I)</code> 个匹配。请注意，它只从每个位置计算一个匹配，要么是最长的，要么是最短的，所以第 <code>(I)</code> 个匹配从有任何匹配的第 <code>(I)</code> 个位置开始。这里是当我们使用上面的例子移除所有 <code>#</code> 的匹配时发生的情况。</p>
<pre><code>  % for (( i = 1; i &lt;= 5; i++ )); do
  for&gt; print ${(SI:$i:)foo#h*e}
  for&gt; done
  wre I was huge lizards walked here and there
  where I was  lizards walked here and there
  where I was huge lizards walked re and there
  where I was huge lizards walked here and tre
  where I was huge lizards walked here and there
</code></pre>
<p>每次我们匹配并移除一个可能的 <code>h*e</code> 集合，其中中间没有 <code>e</code>，从左到右移动。最后一次没有剩下什么可匹配的，返回了完整的字符串。请注意，我们使用的索引本身就是一个参数。</p>
<p>很明显 <code>##</code> 会发生什么：它会在所有相同的点找到匹配，但它们都会延伸到字符串末尾的 <code>e</code>。可能不太明显的是 <code>%%</code> 和 <code>%</code> 会发生什么，但如果你试试，你会发现它们产生与 <code>##</code> 和 <code>#</code> 完全相同的匹配集，只是索引顺序相反（4 对应 1，3 对应 2，等等）。</p>
<p>如果你愿意，你可以使用 <code>M</code> 标志来保留匹配的部分而不是字符串的其余部分。还有三个其他标志，可以让你得到与匹配相关的索引而不是字符串：<code>(B)</code> 表示开头，使用通常的 zsh 约定，即第一个字符是 1，<code>(E)</code> 表示结尾<em>之后</em>的字符，<code>(N)</code> 表示长度，即 <code>B-E</code>。你甚至可以有多个这样的标志；替换的值是一个字符串，其中包含给定的值，用空格分隔，总是按开头、结尾、长度的顺序。</p>
<p>有一个与 <code>(S)</code> 标志相反的东西，它不是匹配子字符串，而是只匹配整个字符串；要做到这一点，在 <code>#</code> 前面放一个冒号。因此：</p>
<pre><code>  % print ${foo:#w*g}
  where I was huge lizards walked here and there
  % print ${foo:#w*e}

  % 
</code></pre>
<p>第一个没有匹配，因为 <code>g</code> 不在末尾；第二个匹配了，因为末尾有一个 <code>e</code>。</p>
<p><strong>模式替换</strong>\</p>
<p>最强大的参数模式匹配形式是从 bash 和 ksh93 借来的；它在传统的 Bourne shell 中不存在。在这里，你用一对 <code>/</code> 来指示要替换的模式及其替换。让我们再用蜥蜴：</p>
<pre><code>  % print ${foo/h*e/urgh}
  wurgh
</code></pre>
<p>有点难以理解：那是因为像大多数模式匹配器一样，除非被告知，否则它会取最长的匹配。在这种情况下，<code>(S)</code> 标志被用来表示不是一个子字符串（那是自动的），而是最短的匹配：</p>
<pre><code>  % print ${(S)foo/h*e/urgh}
  wurghre I was huge lizards walked here and there
</code></pre>
<p>那只替换了第一个匹配。这就是 <code>//</code> 的用武之地；它替换每个匹配：</p>
<pre><code>  % print ${(S)foo//h*e/urgh}
  wurghre I was urgh lizards walked urghre and turghre
</code></pre>
<p>（毫无疑问，你已经开始感觉像一个典型的过时的好莱坞穴居人了。）注意语法：它有点像 <code>sed</code> 或 perl 中的替换，但末尾没有斜杠，并且对于 <code>//</code>，只有第一个斜杠是双写的。有点令人困惑的是，对于其他模式表达式，单个和双个形式意味着最短和最长的匹配，而在这里，是 <code>(S)</code> 标志起了作用。</p>
<p>索引标志 <code>(I)</code> 在这里也很有用。在 <code>/</code> 的情况下，它告诉 shell 要替换哪个单个匹配，在 <code>//</code> 的情况下，它告诉 shell 从哪个匹配开始：从那个开始的所有匹配都会被替换。</p>
<p>重叠的匹配永远不会被 <code>//</code> 替换；一旦它为一次匹配放入了新文本，该部分就不再被考虑，紧邻其右侧的文本被检查是否有匹配。这可能让你想起了其他替换方案。</p>
<p>你很可能在想“如果能在替换文本中使用匹配的文本或其一部分就好了？” 这就是你在 sed 中用 <code>\1</code> 或 <code>\&amp;</code>，在 perl 中用 <code>$1</code> 和 <code>$&amp;</code> 能做到的。事实证明，这在 zsh 中是<em>可能</em>的，这要归功于更复杂的模式匹配特性的一部分。当我们讲到模式时，我会谈到这个，因为它不完全是参数替换的一部分，尽管它被设计成能与那很好地配合。</p>
<p>[]{#l124}</p>
<h3 id="544-选项标志分割和连接"><a class="header" href="#544-选项标志分割和连接">5.4.4: 选项标志：分割和连接</a></h3>
<p>有三种看起来不像标志的标志，出于历史原因；你已经在<a href="zshguide03.html#syntax">第三章</a>中见过它们了。第一个是打开 <code>SH_WORD_SPLIT</code> 选项的那个，<code>${=foo}</code>。请注意，你可以将它与<em>确实</em>看起来像标志的标志混合使用，在括号中，在这种情况下，<code>=</code> 必须在右括号之后。你可以通过将符号加倍来强制为单个替换关闭该选项：<code>${==foo}</code>。然而，你不会这样做，除非该选项已经被设置，在这种情况下，你可能试图与某个其他 shell 兼容，并且不想使用那种形式。</p>
<p>通过三个更标准的标志类型，<code>(s)</code>、<code>(j)</code> 和 <code>(z)</code>，可以对分割和连接进行更多控制。它们分别在给定的字符串上进行分割，用给定的字符串进行连接，以及完全按照 shell 的方式进行分割。在前两种情况下，你需要以与为 <code>(I)</code> 标志指定索引相同的方式指定字符串。所以，例如，这里是如何将 <code>$PATH</code> 转换成一个普通数组而不使用 <code>$path</code>：</p>
<pre><code>  % print -l ${(s.:.)PATH}
  /home/pws/bin
  /usr/local/bin
  /usr/sbin
  /sbin
  /bin
  /usr/bin
  /usr/X11R6/bin
  /usr/games
</code></pre>
<p>任何字符都可以跟在 <code>(s)</code> 或 <code>(j)</code> 后面；字符串参数一直持续到匹配的字符，这里是 <code>.</code>。如果字符是像 <code>&lt;</code> 这样的括号类字符之一，那么“匹配”的字符是相应的右括号，例如 <code>${(s&lt;:&gt;)PATH}</code> 和 <code>${(s(:))PATH}</code> 都是有效的。这适用于所有需要参数的标志，包括 <code>(I)</code>。</p>
<p>虽然分割或连接字符串不是一个模式，但它不必是单个字符：</p>
<pre><code>  % foo=(array of words)
  % print ${(j.**.)foo}
  array**of**words
</code></pre>
<p><code>(z)</code> 标志不接受参数。由于它处理在 shell 的完整单词定义上的分割，它自然与带引号的表达式一起使用，我上面讨论了它与 <code>(Q)</code> 标志一起使用，用于从一行中提取单词并移除引号。</p>
<p>同一个参数表达式可能同时应用了分割和连接。这总是以相同的顺序发生，无论你如何指定标志：先连接，后分割。这在手册中关于参数替换的（相当棘手的）完整规则集里有描述。有一两种情况下，这可能有点令人惊讶。一种是当你设置了 <code>SH_WORD_SPLIT</code> 并尝试连接一个字符串时：</p>
<pre><code>  % setopt shwordsplit    
  % foo=('another array' of 'words with spaces')
  % print -l ${(j.:.)foo}
  another
  array:of:words
  with
  spaces
</code></pre>
<p>如果你不使用 <code>-l</code> 选项来打印，你可能没有注意到，但即使你要求用冒号连接数组，空格仍然导致了分词。要避免这种情况，要么不要使用 <code>SH_WORD_SPLIT</code>（我个人偏好），要么使用引号：</p>
<pre><code>  % print -l "${(j.:.)foo}"
  another array:of:words with spaces
</code></pre>
<p>在这种情况下，数组的元素通常会用空格连接，但 <code>(j)</code> 标志指定的字符优先。同样，如果 <code>SH_WORD_SPLIT</code> 生效，由 <code>(s)</code> 给出的任何分割字符串都会被使用，而不是通常的字符集，即默认情况下是空格、制表符、换行符和 NUL 的字符串 <code>$IFS</code> 中的任何字符。</p>
<p>为特定的参数替换指定一个分割不仅设置了要分割的字符串，而且还确保即使表达式被引用，分割也会发生：</p>
<pre><code>  % array=('element one' 'element two' 'element three')
  % print -l "${=array}"
  element
  one
  element
  two
  element
  three
</code></pre>
<p>为了清楚地说明这里发生了什么：引号强制元素用空格连接，形成一个单一的字符串，然后这个字符串在原始的空格以及用于连接数组元素的空格上被分割。</p>
<p>我稍后会谈到嵌套参数替换；你还应该注意，分割和连接会在必要时在嵌套替换的所有级别上发生，而不仅仅是最外层：</p>
<pre><code>  % foo="three blind words"
  % print ${#${(z)foo}}
  3
</code></pre>
<p>这打印了最内层表达式的长度；由于 zplit，那产生了一个三元素的数组。</p>
<p>[]{#l125}</p>
<h3 id="545-选项标志glob_subst-和-rc_expand_param"><a class="header" href="#545-选项标志glob_subst-和-rc_expand_param">5.4.5: 选项标志：<code>GLOB_SUBST</code> 和 <code>RC_EXPAND_PARAM</code></a></h3>
<p>另外两个不使用括号的标志也影响单个替换的选项。第二个是 <code>~</code> 标志，它打开 <code>GLOB_SUBST</code>，使得参数替换的结果有资格进行模式匹配。正如表示法所暗示的，它也使得文件名扩展成为可能，所以</p>
<pre><code>  % foo='~'
  % print ${~foo}
  /home/pws
</code></pre>
<p>是第一个 <code>~</code> 给了主目录；参数展开中的那个只是允许这种情况发生。如果你设置了 <code>GLOB_SUBST</code>，你可以使用 <code>$~foo</code> 来为一次替换关闭它。</p>
<p>还有另一个这样的选项标志：<code>^</code> 强制为当前替换打开 <code>RC_EXPAND_PARAM</code>，<code>^^</code> 强制关闭它。在<a href="zshguide03.html#syntax">第三章</a>中，我展示了用这个选项展开的参数如何与花括号展开相适应。</p>
<p>[]{#l126}</p>
<h3 id="546-更多参数标志"><a class="header" href="#546-更多参数标志">5.4.6: 更多参数标志</a></h3>
<p>这里还有一些其他的参数标志；我正在重复其中的一些。一个非常有用的标志是 <code>t</code>，用于告诉你一个参数的类型。这在<a href="zshguide03.html#syntax">第三章</a>中也出现过。它最常见的用途是在尝试使用参数之前测试其基本类型：</p>
<pre><code>  if [[ ${(t)myparam} != *assoc* ]]; then
    # $myparam 不是一个关联数组。做点什么。
  fi
</code></pre>
<p>另一个非常有用的类型是用于字符串的左或右填充，到指定的长度，并且可选地使用指定的填充字符串而不是空格；你甚至可以指定一个一次性的字符串紧挨着所讨论的字符串。</p>
<pre><code>  foo='abcdefghij'
  for (( i = 1; i &lt;= 10; i++ )); do
   goo=${foo[1,$i]}
   print ${(l:10::X::Y:)goo} ${(r:10::X::Y:)goo}
  done
</code></pre>
<p>打印出相当漂亮的：</p>
<pre><code>  XXXXXXXXYa aYXXXXXXXX
  XXXXXXXYab abYXXXXXXX
  XXXXXXYabc abcYXXXXXX
  XXXXXYabcd abcdYXXXXX
  XXXXYabcde abcdeYXXXX
  XXXYabcdef abcdefYXXX
  XXYabcdefg abcdefgYXX
  XYabcdefgh abcdefghYX
  Yabcdefghi abcdefghiY
  abcdefghij abcdefghij
</code></pre>
<p>请注意，那些冒号（可以是其他字符，正如我为 <code>(s)</code> 和 <code>(j)</code> 标志解释的那样）总是在参数前后成对出现，所以对于三个参数，中间的冒号是双写的。你可以省略 <code>:Y:</code> 部分和 <code>:X:</code> 部分，看看会发生什么。填充字符串不必是单个字符；如果它们不能精确地填充到填充空间中，最后一个重复将在离被插入的参数参数最远的一端被截断。</p>
<p>两个参数告诉 shell 你想对参数替换的值做一些特殊处理。<code>(P)</code> 标志强制将值视为一个参数名，这样你就能得到一个双重替换的效果：</p>
<pre><code>  % final=string
  % intermediate=final
  % print ${(P)intermediate}
  string
</code></pre>
<p>这有点像 <code>$intermediate</code> 是 ksh 中所谓的“nameref”，一个被标记为引用另一个参数的参数。Zsh 最终可能也会有这些；在某些地方，它们比 <code>(P)</code> 标志方便得多。</p>
<p>一个更强大的标志是 <code>(e)</code>，它强制对值重新扫描所有形式的单单词替换。例如，</p>
<pre><code>  % foo='$(print $ZSH_VERSION)'
  % print ${(e)foo}
  4.0.2
</code></pre>
<p>使得 <code>$foo</code> 的值被重新检查，此时命令替换被找到并执行。</p>
<p>剩下的标志是一些简单的特殊格式化技巧：用 <code>(o)</code> 按正常词法（字符）顺序排序数组元素，用 <code>(O)</code> 按相反顺序排序，用 <code>(oi)</code> 或 <code>(Oi)</code> 分别进行不区分大小写的排序，用 <code>(%)</code> 展开提示符的 <code>%</code>-转义（容易记住），用 <code>p</code> 像 <code>print</code> 那样展开反斜杠转义，用 <code>(U)</code> 强制所有字符为大写或用 <code>(L)</code> 为小写，用 <code>(C)</code> 将字符串或每个数组元素的第一个字符大写，用 <code>(V)</code> 将特殊字符显示为转义序列。这应该足够你用了。</p>
<p>[]{#l127}</p>
<h3 id="547-一些参数替换技巧"><a class="header" href="#547-一些参数替换技巧">5.4.7: 一些参数替换技巧</a></h3>
<p>我忍不住要描述几个额外的技巧。</p>
<p>Zsh 在参数表达式上能做的事情太多了，以至于有时即使没有参数也很有用！例如，这里是如何在不需要将其放入参数的情况下获取固定字符串的长度：</p>
<pre><code>  % print ${#:-abcdefghijklm}
  13
</code></pre>
<p>如果名称未给出的参数长度为零（确实如此，因为没有），则改用 <code>:-</code> 后面的字符串，并取其长度。请注意，你需要冒号，否则你是在要求 shell 测试一个参数是否已设置，当它意识到没有要测试的参数时，它会变得相当不高兴。其他 shell 不太可能容忍任何此类语法上的暴行；那种情况下的 <code>#</code> 很可能被视为 <code>$#</code>，即 shell 参数的数量。但 zsh 知道那不会是零长度，并假设你知道你在用额外部分做什么；这很有用，但技术上违反了规则。</p>
<p>有时你除了标志之外什么都不需要。最常见的情况是让“填充”标志生成重复的单词，效果类似于 perl 的 <code>x</code> 运算符（对于不熟悉 perl 的人，表达式 <code>"string" x 3</code> 产生字符串 <code>stringstringstring</code>。在这里，你需要记住你指定的填充宽度是总宽度，而不是重复次数，所以你需要将它乘以字符串的长度：</p>
<pre><code>  % print ${(l.18..string.)}
  stringstringstring
</code></pre>
<p>[]{#l128}</p>
<h3 id="548-嵌套参数替换"><a class="header" href="#548-嵌套参数替换">5.4.8: 嵌套参数替换</a></h3>
<p>Zsh 有一个用于多个嵌套参数替换的系统。而在大多数 shell 或其他脚本语言中，你会做类似这样的事情：</p>
<pre><code>  % p=/directory/file.ext
  % p2=${p##*/}            # 从头部移除最长的 */ 匹配
  % print $p2
  file.ext
  % print ${p%.*}          # 从尾部移除最短的 .* 匹配
  file
</code></pre>
<p>在 zsh 中，你可以在一次替换中完成这个：</p>
<pre><code>  % p=/directory/file.ext
  % print ${${p##*/}%.*}
  file
</code></pre>
<p>省去了中间的临时参数。（同样，在这种特殊情况下，你更可能使用 <code>${p:t:r}</code>。）当 <code>$p</code> 是一个数组时，这就成了一个主要优势：所有的替换都应用于数组的每个元素：</p>
<pre><code>  % p=(/dir1/file1.ext1 /dir2/file2.ext2)
  % print ${${p##*/}%.*}
  file1 file2
</code></pre>
<p>这可以大大减少处理数组的代码。这是一种绕过事实的方法，即像 zsh 这样的普通命令行界面，最初是为与用户直接交互而设计的，没有像 perl 这样的非交互式语言的所有复杂性，perl 的 <code>map</code> 函数可能是做同样事情的最简洁方法：</p>
<pre><code>   # Perl 代码。
   @p = qw(/dir1/file1.ext1 /dir2/file2.ext2);
   @q = map { m%^(?:.*/)(.*?)(?:\.[^.]*|)$%; } @p;
   print "@q\n";'
</code></pre>
<p>或无数可能的变体。在 shell 中，没有办法将那样的函数放入命令行而不使基本的“命令，参数”语法复杂化；所以我们求助于替换的技巧。然而，请注意，这种程度的简洁性即使在 Perl 中也会导致一定的可读性缺乏。此外，zsh 对常见情况进行了如此优化，以至于</p>
<pre><code>  print ${p:t:r}
</code></pre>
<p>对于数组和标量都有效：<code>:t</code> 只取文件名的尾部，去掉目录，<code>:r</code> 移除后缀。在 4.0.1 之前的 zsh 版本中，这两个运算符可能会有稍微意想不到的效果，例如移除包含目录路径的“后缀”（尽管这也是单独采用的模式形式所做的）。</p>
<p>注意嵌套替换的一个特性：你可能期望 <code>${...}</code> 在另一个内部会做一个完整的参数替换，以便外部的那个会对那个的值起作用——毕竟，如果替换是独立的，你会得到那个。然而，事实并非如此：内部的 <code>${...}</code> 只是一个语法技巧，表示“这里有更多对参数的操作”。这意味着</p>
<pre><code>  bar='这不会被替换'
  foo='bar'
  print ${${foo}}
</code></pre>
<p>只是打印 <code>bar</code>，而不是 <code>$bar</code> 的值。这是我们之前遇到的同样的情况，但没有任何额外的 <code>##</code> 和 <code>%</code> 部分。原因是历史性的：当添加非常有用的嵌套替换功能时，让前导的 <code>$</code> 向 shell 表明它应该再次调用替换函数，比找到另一种语法要简单得多。你可以使用上面描述的 <code>(P)</code> 替换标志，使该值被重新解释为另一个参数替换。只要记住 <code>${${foo}}</code> 和 <code>${(P)foo}</code> 是不同的。</p>
<p>[]{#l129}</p>
<h2 id="55-再谈那个替换"><a class="header" href="#55-再谈那个替换">5.5: 再谈那个替换</a></h2>
<p>最后，这里简要解释一下如何阅读本章开头的表达式。这只适用于高级学生（在我看来是疯子）。如果你足够努力，你可以在手册中找到所有的部分，甚至是我没有讲到的那些。举个例子，让我们假设数组包含</p>
<pre><code>  array=(long longer longest short brief)
</code></pre>
<p>看看</p>
<pre><code>  print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}
</code></pre>
<p>会给出什么。</p>
<ol>
<li>
<p>总是从内部开始。这里最里面的表达式是</p>
<pre><code>    ${(O@)array//?/X}
</code></pre>
<p>不太清楚？再从内部开始：这里有我们正在操作的参数，它的名字是 <code>array</code>。在它前面，括号里有两个标志：(<code>O</code>) 表示按降序字母顺序对结果进行排序，(<code>@</code>) 将结果视为一个数组，这是必要的，因为这个内部替换发生在一个通常是标量值（实际上是一个算术表达式）的地方，我们需要取一个数组元素。在数组名之后，<code>//?/X</code> 是一个全局替换：取模式 <code>?</code>（任何字符）出现的地方，并用字符串 <code>X</code> 替换它。这个的结果是一个像 <code>$array</code> 的数组，但所有元素都变成了由 <code>X</code> 组成的字符串，代替了原始字符，并且最长的排在最前面，因为对于具有相同字符的字符串，反向字母顺序就是这样工作的。所以</p>
<pre><code>    long longer longest short brief
</code></pre>
<p>会变成</p>
<pre><code>    XXXXXXX XXXXXX XXXXX XXXXX XXXX
</code></pre>
</li>
<li>
<p>接下来，我们有 <code>${#</code><em>result</em><code>[1]}</code> 包围着那个。那意味着我们取上面得到的数组的第一个元素（<code>[1]</code>：这就是为什么我们必须确保它被当作一个数组），然后取它的长度（<code>#</code>）。在这种情况下，我们最终会得到 7，即第一个（也是最长的）元素的长度。我们终于有所进展了。</p>
</li>
<li>
<p>下一步是 <code>${</code>(<code>l.</code><em>result</em><code>..?.</code>)<code>}</code>。我们之前的 <em>result</em> 作为 <code>(l)</code> 标志的参数出现。这是一个相当特殊的嵌套替换情况：在这一点上，shell 期望一个算术表达式，给出要向左填充的字符串的最小长度。之前的替换被评估了，因为算术表达式会进行参数替换。所以是那个的结果，7，出现在这里，给出了更易于管理的</p>
<pre><code>    ${(l.7..?.)}
</code></pre>
<p><code>(l)</code> 标志的完整表达式表示“将此参数替换的结果填充到最小宽度为 7，使用填充字符 <code>?</code>”。我们正在填充什么替换？它是空的：zsh 足够聪明，当你没有给出参数名时，它会假设你知道你在做什么，并只放入一个空字符串。所以空字符串被填充到长度 7，用问号填充，得到 <code>???????</code>。</p>
</li>
<li>
<p>现在我们有 <code>${array[(r)???????]}</code>。可能不明显（如果其余的都明显，恭喜你），但问号作为模式是活动的。下标在这方面是特殊的。下标标志 <code>(r)</code> 意味着“反向匹配”，不是向后的反向，而是相反的方式：在数组本身中搜索匹配的值，而不是将此作为索引。唯一能匹配这个的是一个长度为 7 的字符串。宾果！在这种情况下，那必须是元素“longest”。如果还有其他相同长度的元素，你只会得到那个长度的第一个；我还没有想出一种方法可以用单个表达式替换所有那个长度的元素，而不将 <code>$array</code> 变成一个关联数组，所以如果你有，你应该感到得意。</p>
</li>
</ol>
<p>我写完这个之后，Sven Wischnowsky（他负责补全函数中大部分类似的象形文字）指出，实现这个的一个类似方法是：</p>
<pre><code>  print ${(M)array:#${~${(O@)array//?/?}[1]}}
</code></pre>
<p>这确实显示了最大长度的所有元素。简要总结一下它的工作原理是，最里面的表达式产生一个对应于元素的 <code>?</code> 数组，最长的排在最前面，就像我们上面做的那样，将 <code>?</code> 变成模式匹配字符。下一个展开选择最长的。最后，最外层的展开遍历 <code>$array</code> 以查找与完整的 <code>?</code> 字符串匹配的元素，并选出那些匹配的。</p>
<p>如果你想知道如何在 perl 中用单个表达式做到这一点，可能按长度排序是最简单的：</p>
<pre><code>  # Perl 代码
  @array = qw(long longer longest short brief);
  @array = sort { length $b &lt;=&gt; length $a } @array;
</code></pre>
<p>然后取出 <code>@array</code> 的第一个或前几个元素。然而，在一个高度优化的脚本语言中，你几乎肯定会用其他方式来做：例如，避免排序，只记住最长的元素：</p>
<pre><code>  # Perl 代码
  $elt = '';
  $l = 0;
  foreach (@array) {
    $newl = length $_;
    $elt = $_, $l = $newl  if $l &gt; $newl;
  }
  print $elt, "\n";
</code></pre>
<p>在这种情况下，你可以在 zsh 中很容易地做同样的事情；</p>
<pre><code>  local val elt
  integer l newl
  for val in $array; do
    newl=${#val}
    if (( newl &gt; l )); then
      elt=$val
      (( l = newl ))
    fi
  done
  print $elt
</code></pre>
<p>所以这可能不是嵌套替换的一个特别好的用途，即使它说明了它的强大。</p>
<p>如果你喜欢那个表达式，补全函数套件中还有很多类似的供你惊叹。</p>
<p>[]{#l130}</p>
<h2 id="56-算术展开-1"><a class="header" href="#56-算术展开-1">5.6: 算术展开</a></h2>
<p>在 shell 内部进行数学运算最初是在<a href="zshguide03.html#syntax">第三章</a>中描述的，在那里我展示了如何用 <code>typeset</code> 的变体创建数值参数，并对算术替换说了一点。</p>
<p>除了可以用 <code>zmodload zsh/mathfunc</code> 加载的数学库，zsh 基本上拥有你期望从 C 和其他源自它的语言中得到的所有运算符。换句话说，像</p>
<pre><code>  (( foo = bar ? 3 : 1, ++brr ))
</code></pre>
<p>这样的东西是被接受的。逗号运算符的工作方式与 C 中完全相同；所有参数都被求值，在这种情况下，<code>foo = bar ? 3 : 1</code> 根据 <code>bar</code> 是否非零将 3 或 1 赋给 <code>$foo</code>，然后 <code>$brr</code> 增加 1。返回状态由最后的表达式决定，所以如果 <code>$brr</code> 在增加后为零，返回状态为一，否则为零（整数可以是负数）。</p>
<p>一个额外的运算符是从 FORTRAN 或许是 Perl 借来的，即求幂运算符 <code>**</code>。它可以接受整数或浮点数，尽管负指数会导致返回一个浮点数，所以 <code>$(( 2 ** -1 ))</code> 给你 0.5，而不是向下取整到零。这就是为什么标准库函数 <code>pow</code> 在 <code>zsh/mathfunc</code> 中缺失的原因——它已经以那种其他形式存在了。然而，纯整数求幂是通过重复乘法完成的——直到任意大小，所以 вместо <code>2 ** 100</code>，你应该使用 <code>1 &lt;&lt; 100</code>，对于任何其他整数的幂，如果你不需要精确结果，你应该使用浮点数。为此，<code>zsh/mathfunc</code> 库提供了“类型转换”；<code>float</code>(<em>num</em>)<code>强制表达式 *num* 被解释为一个浮点数，无论它本来会给出什么，尽管给一个数加上</code>0.0<code> 的技巧也有效。请注意，虽然这像 C 中的类型转换一样工作，但语法是普通函数调用的语法。同样，</code>int<code>(*num*)</code> 使该数被解释为一个整数——向零取整；你可以使用 <code>floor</code> 和 <code>ceil</code> 来向下或向上取整，<code>rint</code> 来四舍五入到最近的整数，尽管这三个实际上产生浮点数。它们是标准的 C 库函数。</p>
<p>为了完整起见，求幂的赋值形式 <code>**=</code> 也有效。我不记得用过它。</p>
<p>整数的范围取决于你的机器上 zsh 是如何配置的。主要目标是确保整数足够大以表示文件中的索引；在一些硬件通常处理 32 位整数的系统上，文件大小可能由 64 位整数给出，zsh 也会尝试使用 64 位整数。然而，即使没有大文件支持，zsh 也会测试大整数；通常它只要求你的编译器有一些易于识别的定义 64 位整数的方式，比如 <code>long long</code>，即使本地编译器不支持，gcc 也可能处理。你可以很容易地测试；如果你的 zsh 支持 64 位整数，可用的最大整数是：</p>
<pre><code>  % print $(( 0x7FFFFFFFFFFFFFFF ))
  9223372036854775807
</code></pre>
<p>如果你尝试给那个数加上一个正数，你会因为二进制补码算术而得到一个负数结果。这应该足够大来计算大多数东西了。</p>
<p>浮点数的范围总是 C 语言 <code>double</code> 的范围，通常也是 64 位，内部数字很可能采用 IEEE 标准形式，这也影响了你能得到的精度和范围，尽管那也是系统特定的。在大多数系统上，数学库函数处理 <code>double</code> 而不是单精度 <code>float</code>，所以这是自然的选择。类型转换函数被称为 <code>float</code>，因为与 C 不同，浮点数的表示是为你选择的，所以使用了通用名称。</p>
<p>[]{#l131}</p>
<h3 id="561-输入和输出基数"><a class="header" href="#561-输入和输出基数">5.6.1: 输入和输出基数</a></h3>
<p>我将说一两句关于基数的话。我已经说过你可以用像 <code>2#101010</code> 或 <code>16#ffff</code> 这样的形式输入任何小基数的数字，并且后者也可以是 <code>0xffff</code>，就像在 C 中一样。然而，你不能仅仅通过使用前导的 <code>0</code> 来输入八进制数，这可能是你从 C 中所期望的。这里有一个例子说明为什么不行。让我们设置：</p>
<pre><code>  % foo=${(%):-%D}
  % print $foo
  01-08-06
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide05.html">上一章</a></li>
<li><a href="zshguide07.html">下一章</a></li>
</ul>
<hr />
<p>[]{#comp}[]{#l144}</p>
<h1 id="第六章补全旧与新-1"><a class="header" href="#第六章补全旧与新-1">第六章：补全，旧与新</a></h1>
<p>命令参数的补全是 zsh 特别擅长的一件事。最简单的情况是，你按 <code>&lt;TAB&gt;</code>，shell 会猜测那里应该是什么并为你填充：</p>
<pre><code>  % ls
  myfile  theirfile  yourfile
  % cat t&lt;TAB&gt;
</code></pre>
<p>将命令行展开为</p>
<pre><code>  % cat theirfile
</code></pre>
<p>你只需要输入首字母，然后按 <code>TAB</code>。</p>
<p>在 C shell 中这个功能刚出现的时候，只能补全文件名；如果名称有歧义，没有任何聪明的技巧可以帮助你，它只是打印出无歧义的部分然后发出哔哔声，让你自己决定下一步该做什么。你也可以列出可能的补全；出于某种原因，这在 csh 中被附加到了 <code>^D</code> 键上，在后来的具有类 Emacs 绑定的 shell 中，这个键也删除下一个字符，所以历史赋予了 zsh，像其他 shell 一样，有点奇怪的组合行为：</p>
<pre><code>  % cat yx 
</code></pre>
<p>现在将光标移回一个字符到 x 上，然后按两次 ^D，你会看到：<code>yourfile</code>。如果你使用类 vi 的绑定，或者，显然，如果你重新绑定了 <code>^D</code>，这就行不通了。</p>
<p>接下来，补全其他项目如用户名、命令或主机名成为可能。然后 zsh 介入了菜单补全，所以你可以一直盲目地按 <code>&lt;TAB&gt;</code> 直到正确的答案出现，而永远不需要自己输入一个额外的字符。</p>
<p>下一个发展是 tcsh 的，然后是 zsh 的，可编程补全系统；你可以给 shell 指令，在某些上下文，只应该补全某些项目；例如，在 <code>cd</code> 之后，你只会想要目录。在 tcsh 中，有一个名为 <code>complete</code> 的命令；每个 <code>complete ...</code> 语句定义了特定命令（如 <code>cd</code>）参数的补全；在 zsh 中等价的是 <code>compctl</code>，它受到 <code>complete</code> 的启发，但在几乎所有重要细节上都不同。在 shell 发行版的 <code>Misc</code> 目录中有一个 perl 脚本 <code>lete2ctl</code> 可以帮助你从 tcsh 格式转换为 zsh 格式。你把一整套 <code>compctl</code> 命令放到 <code>.zshrc</code> 中，其他一切都由 shell 完成。</p>
<p>Zsh 的系统变得越来越复杂，在 3.1.6 版本中出现了一个新的补全系统，它应该为你做所有事情：你只需从一个初始化文件中调用一个函数 <code>compinit</code>，之后 zsh 就知道，例如，<code>gunzip</code> 后面应该跟着以 <code>.gz</code> 结尾的文件。新系统基于 shell 函数，这是一个额外的奖励，因为它们非常灵活，而且你已经知道语法了。然而，考虑到其复杂性，现在开始编写自己的补全相当困难，而且要弄清楚如何按照你喜欢的方式更改设置也足够难了。本章的其余部分应该会有所帮助。</p>
<p>我将专注于新的补全系统，它似乎最终将完全取代旧的系统，现在 3.1 发布系列已经成为 4.0 产品发布。旧的 <strong>compctl</strong> 命令仍然可用，旧的补全定义在未来的 zsh 版本中将继续工作——事实上，在大多数支持动态链接库的操作系统上，旧的补全系统在一个不同的文件中，shell 在必要时会加载它，所以这几乎没有开销。</p>
<p>新系统的一大区别是，不是在 shell 启动时一次性设置好所有东西，而是在你按 <code>&lt;TAB&gt;</code> 之后调用各种 shell 代码片段，以便当场生成补全。shell 中有足够多的新东西，所有那些 <code>compctl</code> 的难记选项（<code>-f</code> 用于文件，<code>-v</code> 用于变量等等）都可以被直接产生补全列表的命令所取代；在这种情况下，关键命令叫做 <code>compadd</code>，它被传递这个列表并决定用什么来补全命令行上的单词。所以最简单形式的新补全看起来大致是这样的：</p>
<pre><code>  # 告诉 shell 函数 mycompletion 可以在被小部件名称 my-completion-widget 调用时进行补全，
  # 并且它的行为像现有的小部件 complete-word
  zle -C my-completion-widget .complete-word mycompletion
  
  # 定义一个调用补全小部件的键
  bindkey '^x^i' my-completion-widget
  
  # 定义将被调用的函数
  mycompletion() {
    # 添加一个补全列表
    compadd alpha bravo charlie delta
  }
</code></pre>
<p>这大致就是补全系统正在做的事情，除了函数被称为 <code>_main_complete</code> 并且它会根据调用补全的上下文（所有 <code>compctl</code> 过去做的事情）调用许多其他函数来做它的脏活，而小部件只是旧的补全小部件（<code>expand-or-complete</code> 等）被重新定义并仍然绑定到所有原始键。但是，如果你还没猜到，事情远不止于此。</p>
<p>这是本章各节的计划。</p>
<ol>
<li>对补全和展开的广泛描述，同样适用于新旧补全。</li>
<li>如何使用 shell 选项配置补全。本节的大部分内容也适用于旧补全，尽管我不会明确标记任何差异。在此之后，我将把 <code>compctl</code> 的世界抛在脑后。</li>
<li>如何启动新的补全。</li>
<li>新补全系统如何工作的基本原理。</li>
<li>如何使用新的 <code>zstyle</code> 内建命令来配置它。</li>
<li>除了通常的补全系统之外，还有一些做其他事情的独立命令，以及一些与补全有关的其他编辑小部件。</li>
<li>匹配控制，一种强大的方式来决定诸如是否不区分大小写地补全，是否允许在标点符号前插入单词的额外部分，或者是否忽略命令行上单词中的某些字符。</li>
<li>如何编写自己的补全函数；你不需要对所有前面的内容有太扎实的理解就能做简单的补全，但我会逐渐介绍如何让标签和样式在你自己的函数中工作的全部巴洛克式的辉煌，以及如何让补全完成处理命令参数和选项的工作。</li>
<li>按照旧的“开头、中间、结尾”原则，优雅地结束本章。</li>
</ol>
<p>[]{#l145}</p>
<h2 id="61-补全和展开-1"><a class="header" href="#61-补全和展开-1">6.1: 补全和展开</a></h2>
<p>当你按 tab 键时，发生的事情不止是补全。zsh 尝试做的第一件事是展开行。展开在上一章已经讲过：基本上那里描述的所有东西都是编辑器内联展开的可能候选项。换句话说，带感叹号的历史替换、使用 <code>$</code> 或反引号的各种展开，以及文件名生成（通配）都可以发生，结果会替换命令行上的内容：</p>
<pre><code>  % echo $PWD&lt;TAB&gt;
    -&gt;    echo /home/pws/zsh/projects/zshguide
  % echo `print $ZSH_VERSION`&lt;TAB&gt;
    -&gt;    echo 3.1.7
  % echo !!&lt;TAB&gt;
    -&gt;    echo echo 3.1.7
  % echo ~/.z*&lt;TAB&gt;
    -&gt;    echo /home/pws/.zcompdump /home/pws/.zlogout
          /home/pws/.zshenv /home/pws/.zshrc                   
</code></pre>
<p>请注意，在这种情况下，<code>~</code> 也会被展开。</p>
<p>这通常是记住“撤销”键 <code>^_</code> 或 <code>^Xu</code> 的好时机；如果你不喜欢结果，输入这个将恢复展开前的内容。许多键盘有一个怪癖，被描述为 <code>^_</code> 的东西应该通过按住 control 和斜杠来输入，你会写成 <code>^/</code>，但不幸的是那会做别的事情；这不是 zsh 的错。还有一个半例外，即文件名生成：像 <code>~/file</code> 这样的路径不会被展开，因为你通常知道它们指的是什么，而且为了补全而保留它们通常很方便。然而，<code>=cmdname</code> 形式确实会被展开，除非你设置了 <code>NO_EQUALS</code>。</p>
<p>实际上，决定是进行展开还是补全有时可能很棘手，因为如果它们是完整的，会被展开的东西，可能需要先被补全；例如 <code>$PAT</code> 可能应该被补全为 <code>$PATH</code>，但很可能也有一个参数 <code>$PAT</code>。如果你愿意，你可以决定是哪个。首先，命令 <code>expand-word</code>，绑定到 <code>^X*</code>，以及相应的用于列出将被展开的内容的命令 <code>list-expand</code>，绑定到 <code>^Xg</code>，只做展开——所有可能的形式，除了别名展开，包括将 <code>~/file</code> 变成一个完整路径。</p>
<p>从另一个角度看，你可以使用除了 <code>expand-or-complete</code>（默认绑定到 <code>&lt;TAB&gt;</code> 的那个）之外的命令来只执行补全。这样做的基本命令是 <code>complete-word</code>，默认没有绑定。如果你乐于使用单独的命令进行展开，将它绑定到 <code>^I</code>（即 <code>&lt;TAB&gt;</code>）是相当明智的，即</p>
<pre><code>  # 现在 tab 只做补全，不做展开
  bindkey '^i' complete-word
</code></pre>
<p>此外，如果你这样做并使用新的补全系统，那么正如我们将看到的，有一种方法可以让补全系统执行展开——请参阅下面对 <code>_expand</code> 补全器的描述。在这种情况下，你对尝试哪些展开形式以及在哪个点尝试有更多的控制，但你必须确保你使用 <code>complete-word</code>，而不是 <code>expand-or-complete</code>，否则标准的展开系统将接管。</p>
<p><code>expand-or-complete</code> 有一个近亲，<code>expand-or-complete-prefix</code>，默认没有绑定。唯一的区别是，它在补全时会忽略光标下和右边的所有内容。就好像光标所在的位置有一个空格，所有要忽略的东西都向右移动了（猜猜它是如何实现的）。如果你习惯于在其他单词之前在行中输入新单词，并期望它们在输入空格之前就能自己补全或展开，就使用这个。其他一些 shell 一直都是这样工作的。更明确地说：</p>
<pre><code>  % ls
  filename1
  % ls filex
</code></pre>
<p>将光标移动到 <code>x</code> 上并按 tab。使用 <code>expand-or-complete</code> 什么也不会发生；它试图补全一个名为 <code>filex</code> 的文件——或者，设置了 <code>COMPLETE_IN_WORD</code> 选项后，它试图找到一个以 <code>file</code> 开头并以 <code>x</code> 结尾的文件。如果你这样做</p>
<pre><code>  bindkey '^i' expand-or-complete-prefix
</code></pre>
<p>并尝试同样的实验，你会发现整个东西被补全为 <code>filename1x</code>，所以 <code>x</code> 被忽略了，但没有被移除。</p>
<p>一个可能的陷阱是，列表命令，包括 <code>delete-char-or-list</code>（在 emacs 模式下默认绑定到 <code>^D</code>）和 <code>list-options</code>（在 vi 插入模式下默认绑定到 <code>^D</code>，并且是列出补全的基本命令，因为它没有删除字符的行为），不显示可能的展开，所以使用默认绑定，你可以用 <code>^D</code> 来列出，然后按 <code>&lt;TAB&gt;</code>，发现该行已被某个展开完全重写。使用 <code>complete-word</code> 而不是 <code>expand-or-complete</code> 当然可以解决这个问题。如果你知道如何编写新的编辑器小部件（<a href="zshguide04.html#zle">第四章</a>），你可以编写一个函数，先尝试 <code>list-expand</code>，如果失败再尝试 <code>list-options</code>。</p>
<p>还有四个我还没提到的补全命令：三个是 <code>menu-complete</code>、<code>menu-expand-or-complete</code> 和 <code>reverse-menu-complete</code>，它们执行菜单补全，你可以通过按同一个键来循环浏览所有可能的补全。前两个分别对应于 <code>complete-word</code> 和 <code>expand-or-complete</code>，而第三个没有真正的等价物，因为它带你向后浏览一个补全列表。第三个的效果不能仅仅通过为菜单补全设置选项来达到，所以将它单独绑定是很有用的。我把它绑定到 <code>\M-\C-i</code>，即按住 Meta 键的 tab，但它默认没有绑定。</p>
<p>第四个是 <code>menu-select</code>，它执行一种增强形式的菜单补全，称为“菜单选择”，我将在下面谈论选项时描述。你需要确保加载了 <code>zsh/complist</code> 模块才能使用这个 zle 命令。如果你使用样式，zsh 应该能够在需要时自动加载这个，只要你有动态加载，你现在可能有了。 []{#l146}</p>
<h2 id="62-使用-shell-选项配置补全-1"><a class="header" href="#62-使用-shell-选项配置补全-1">6.2: 使用 shell 选项配置补全</a></h2>
<p>在不编写或重写 shell 函数的情况下，改变补全行为主要有两种方法：shell 选项，如<a href="zshguide02.html#init">第二章</a>中介绍的，和样式，如上所述。我将首先讨论 shell 选项，尽管如你所见，其中一些会引用样式机制。设置 shell 选项会影响每一个补全，除非采取了特殊措施（使用相应上下文的样式，或局部设置选项）来避免这种情况。</p>
<p>除了直接影响补全系统的选项外，补全还对描述 shell 行为的各种其他选项敏感。例如，如果设置了 <code>MAGIC_EQUAL_SUBST</code> 选项，那么所有看起来像 <code>foo=~/file</code> 的命令参数都会像在参数开头一样展开 <code>~</code>，那么对于未特殊处理的命令参数的默认补全将尝试在 <code>=</code> 之后补全文件名。</p>
<p>不用说，如果你编写补全函数，你需要担心很多其他可能影响 shell 语法的选项。由上下文选择的补全（除了绑定到按键的特定补全命令之外的所有内容）的主要起点是函数 <code>_main_complete</code>，它包含了以下行的效果，以确保至少在补全函数中设置了基本选项：</p>
<pre><code>  setopt glob bareglobqual nullglob rcexpandparam extendedglob unset
  unsetopt markdirs globsubst shwordsplit shglob ksharrays cshnullglob
  unsetopt allexport aliases errexit octalzeroes
</code></pre>
<p>但这绝不是全部的可能性。实际上，它不包含那些行：要设置的选项存储在数组 <code>$_comp_options</code> 中，如果它们要被关闭，则前面有 <code>NO_</code>。如果你发现你需要修改这个，你可以修改它（也许也告诉维护者）。</p>
<p>顺便说一句，如果你想知道是否可以重用函数 <code>_main_complete</code>，通过将其绑定到具有稍微不同补全定义的不同键，请查看下面对 <code>_generic</code> 命令小部件的描述。它只是 <code>_main_complete</code> 的一个前端，允许你有一套不同的有效样式。</p>
<p>[]{#l147}</p>
<h3 id="621-模糊补全"><a class="header" href="#621-模糊补全">6.2.1: 模糊补全</a></h3>
<p>最大的一组选项处理当补全是模糊的，换句话说，有多个可能的补全时会发生什么。七个相关的选项如下，从 FAQ 中复制而来；许多不同的组合是可能的：</p>
<ul>
<li>设置 <code>NO_BEEP</code> 后，那烦人的哔哔声就消失了，</li>
<li>设置 <code>NO_LIST_BEEP</code> 后，哔哔声只对模糊补全关闭，</li>
<li>设置 <code>AUTO_LIST</code> 后，当补全模糊时，你会得到一个列表，而无需输入 <code>^D</code>，</li>
<li>设置 <code>BASH_AUTO_LIST</code> 后，列表只在你第二次对一个模糊补全按 tab 时发生，</li>
<li>设置 <code>LIST_AMBIGUOUS</code> 后，这被修改为如果有一个无歧义的前缀或后缀要插入，则不列出任何内容——这可以与 <code>BASH_AUTO_LIST</code> 结合使用，所以在两者都适用的情况下，你需要按三次 tab 才能列出，</li>
<li>设置 <code>REC_EXACT</code> 后，如果命令行上的字符串与可能的补全之一完全匹配，它就会被接受，即使还有另一个补全（即该字符串加上其他东西）也匹配，</li>
<li>设置 <code>MENU_COMPLETE</code> 后，一个补全总是被完全插入，然后当你按 TAB 时，它会变成下一个，依此类推，直到你回到你开始的地方，</li>
<li>设置 <code>AUTO_MENU</code> 后，你只有在对模糊补全再次按 TAB 时才会得到菜单行为。</li>
</ul>
<p>[]{#l148}</p>
<h3 id="622-always_last_prompt"><a class="header" href="#622-always_last_prompt">6.2.2: <code>ALWAYS_LAST_PROMPT</code></a></h3>
<p><code>ALWAYS_LAST_PROMPT</code> 选项默认是打开的，并且自 zsh 的一个早期 3.1 版本以来就是如此；在列出补全后，光标会回到它之前的行上，而不是在下面重新打印它。这样做的缺点是，当你执行命令或产生一个不同的列表时，列表会被遮挡，所以你可能想取消设置该选项。<code>ALWAYS_LAST_PROMPT</code> 行为是菜单选择工作所必需的，这就是为什么我现在提到它而不是在下面的杂项中。</p>
<p>当你编写自己的调用补全的编辑器函数时，你实际上可以用小部件 <code>end-of-list</code> 来取消这个效果，你会调用它为 <code>zle end-of-list</code>（它是一个普通的编辑函数，不是一个补全函数）。你也可以将它绑定到一个键上，用来保留现有的补全列表。另一方面，如果你想在补全函数内部控制行为，即决定补全是否会尝试返回到列表上方的提示符，你可以用 <code>$compstate</code> 关联数组的 <code>last_prompt</code> 元素来操作它，所以例如：</p>
<pre><code>  compstate[last_prompt]=''
</code></pre>
<p>将为正在进行的补全关闭该行为。如果你发现自己想要如此详细地控制补全行为，<code>$compstate</code> 是你应该求助的地方；请参阅 <code>zshcompwid</code> 手册页。</p>
<p>[]{#l149}</p>
<h3 id="623-菜单补全和菜单选择"><a class="header" href="#623-菜单补全和菜单选择">6.2.3: 菜单补全和菜单选择</a></h3>
<p>由上述选项决定的最重要的事情是你是否正在使用菜单补全。如果你不是，当补全有歧义时，你需要明确地输入下一个字符；如果你是，你只需要一直按 tab 直到你想要的补全出现。在第二种情况下，当然，如果可能性不多，这效果最好。使用 <code>AUTO_MENU</code> 或将 <code>menu-complete</code> 小部件绑定到一个单独的按键，可以让你两全其美。</p>
<p>在 3.1.6 中出现了一种新的菜单补全变体；事实上，它比原始形式更配得上菜单补全这个名字，但由于那个名字已经被占用了，它被称为“菜单选择”。这允许你在补全列表中移动光标来选择一个。它由一个单独的模块 <code>zsh/complist</code> 实现；你可以通过在 <code>.zshrc</code> 中放入 <code>zmodload -i zsh/complist</code> 来确保这个模块被加载，尽管如果你使用下面设置的 <code>menu</code> 样式，它应该会自动加载。为了让它有用，你需要另外两样东西。第一是 <code>ALWAYS_LAST_PROMPT</code> 行为；如果整个补全列表无法在屏幕上显示，这个行为会被抑制，因为屏幕上没有可以返回的行。然而，菜单选择仍然有效，它允许你上下滚动列表。第二件事是，你需要以任何通常的方式启动菜单补全；菜单选择是菜单补全的补充，而不是替代。</p>
<p>现在你应该设置以下样式：</p>
<pre><code>  zstyle ':completion:*' menu select=&lt;NUM&gt;
</code></pre>
<p>如果一个模糊的补全产生了至少 <code>&lt;NUM&gt;</code> 个可能性，菜单选择就会启动。你最好通过尝试来理解这个。列表中的一个补全，最初是左上角的那个，被高亮显示并插入到行中。通过在明显的方向上移动光标（在边缘处有环绕），你可以改变高亮显示的值和插入到行中的值。当你得到你想要的值时，按回车，这会移除列表并留下插入的值。按 <code>^G</code>（编辑器函数 <code>send-break</code>）会中止菜单选择，移除列表并恢复命令行。</p>
<p>在内部，zsh 实际上使用参数 <code>$MENUSELECT</code> 来提供数字，从而启动菜单选择。然而，这总是从上面定义的样式中初始化的，所以你不应该直接设置 <code>$MENUSELECT</code>（除非你正在使用 <code>compctl</code>，它会愉快地使用菜单选择）。与其他样式一样，你可以为不同的上下文指定不同的值；如果当前上下文没有为当前标签的样式产生一个值，则会检查 <code>default</code> 标签。请注意，<code>menu</code> 样式也允许你控制是否启动菜单补全，无论是否带选择；换句话说，它是一个对应于 <code>MENU_COMPLETE</code> 选项的样式。</p>
<p>使用菜单选择时还有一个额外的功能。zle 命令 <code>accept-and-infer-next-history</code> 在这里有不同的含义；它接受一个补全，然后尝试再次使用菜单选择进行补全。这对于目录层次结构非常有用，并且与 <code>undo</code> 结合使用，可以给你一个简单的文件浏览器。你需要在特殊的键映射 <code>menuselect</code> 中绑定它；例如，我使用</p>
<pre><code>  bindkey -M menuselect '^o' accept-and-infer-next-history
</code></pre>
<p>因为这种行为让我想起了在 emacs 模式下通常绑定到 <code>^O</code> 的东西，即 <code>accept-line-and-down-history</code>。这样绑定对普通键映射中的 <code>^O</code> 没有影响。通过在一个包含目录的文件集上进入菜单选择，并在其中一个目录上输入 <code>^O</code> 来尝试它。你应该会立即看到该目录的内容被呈现出来以供下一次选择，而 <code>undo</code> 足够聪明，不仅能移除那个选择，还能返回到对父目录的补全。</p>
<p>你可以选择补全列表中当前选定值的突出显示方式，使用的机制与为特定类型的匹配指定颜色的机制完全相同；请参阅下面对 <code>list-colors</code> 样式的描述。</p>
<p>[]{#l149}</p>
<h3 id="624-改变补全行为的其他方式"><a class="header" href="#624-改变补全行为的其他方式">6.2.4: 改变补全行为的其他方式</a></h3>
<p><strong><code>COMPLETE_ALIASES</code></strong></p>
<p>如果你设置了一个别名，比如</p>
<pre><code>  alias pu=pushd
</code></pre>
<p>那么当补全系统寻找命令名称时，别名 <code>pu</code> 将被展开，所以它会找到命令名称 <code>pushd</code>。这对于避免为所有别名定义额外的补全非常有用。然而，你可能想为别名定义一些与它展开的命令不同的东西。在这种情况下，你需要设置 <code>COMPLETE_ALIASES</code>，并为每个不匹配命令名称的别名安排补全。因此，<code>alias zcat="myzcat -dc"</code> 在设置了该选项的情况下会起作用，即使你没有告诉系统关于 <code>myzcat</code> 的信息，而 <code>alias myzcat="gzip -dc"</code> 除非你为 myzcat 定义一个补全，否则不会起作用：这里 <code>compdef _gzip myzcat</code> 可能就足够了。没有设置该选项时，情况会相反：第一个别名没有额外的 <code>compdef</code> 就不会起作用，但第二个会。</p>
<p><strong><code>AUTO_REMOVE_SLASH</code></strong></p>
<p>这个选项默认是打开的。如果你补全一个目录名并且添加了一个斜杠——通常是这样，既告诉你你补全了一个目录，也允许你在不手动添加 <code>/</code> 的情况下补全其中的文件——而你输入的下一个东西<em>不是</em>会插入或补全该目录中文件的一部分的东西，那么斜杠就会被移除。因此：</p>
<pre><code> % rmdir my&lt;TAB&gt;
   -&gt;  rmdir mydir/
 % rmdir mydir/&lt;RETURN&gt;
   -&gt;  `rmdir mydir' executed
</code></pre>
<p>这个例子显示了为什么添加这个行为：一些版本的 <code>rmdir</code> 会对目录名后的斜杠感到不满。另一方面，如果你在斜杠后继续输入，或者再次按 tab 在 <code>mydir</code> 内部补全，那么斜杠会保留。</p>
<p>在大多数情况下，这最多是无害的。然而，如果你不喜欢这种行为，你可以取消设置 <code>AUTO_REMOVE_SLASH</code> 选项。一个可能引起轻微混淆的事情是，虽然它与其他后缀（即自动添加但不是被补全的值的一部分的东西）相同，但如果值是通过菜单补全插入的，斜杠会立即被添加。这可能会让你错误地认为补全已经完成，因此是唯一的，而实际上并非如此。</p>
<p>请注意，某些形式的补全内置了这种行为，不一定带斜杠，当补全参数列表时。例如，输入 <code>typeset ZSH_V&lt;TAB&gt;</code>，你会看到 <code>ZSH_VERSION=</code> 出现，以防你想给该参数赋一些值；按空格，这不是一个可能的值，会使 <code>=</code> 消失。这不受 <code>AUTO_REMOVE_SLASH</code> 选项的控制，该选项只适用于由标准文件名补全系统插入的目录。</p>
<p><strong><code>AUTO_PARAM_SLASH</code>, <code>AUTO_PARAM_KEYS</code></strong></p>
<p>这些选项在补全带参数替换的表达式时生效。如果设置了 <code>AUTO_PARAM_SLASH</code>，那么任何其值为目录名的参数表达式在补全时都会附加一个斜杠，就像值本身被补全系统插入一样。</p>
<p><code>AUTO_PARAM_KEYS</code> 的行为有点复杂。试试这个：</p>
<pre><code>  print ${ZSH_V&lt;TAB&gt;
</code></pre>
<p>你会发现你得到了完整的单词 <code>${ZSH_VERSION}</code>，带有右花括号，并且（假设没有其他匹配的参数）后面有一个空格。然而，通常在你以这种方式补全一个参数后，你想在它后面立即输入一些东西，比如一个下标。使用 <code>AUTO_PARAM_KEYS</code>，如果你此时输入一些很可能需要放在参数名后面的东西，它会立即被放在那里，而无需你删除中间的字符——例如，用 <code>[</code> 试试。请注意，这只有在参数名和任何额外部分是由补全添加时才会发生；如果你手动输入所有内容，输入 <code>[</code> 不会有这种神奇的效果。</p>
<p><strong><code>COMPLETE_IN_WORD</code></strong></p>
<p>如果设置了这个，补全总是在单词中的光标位置进行。例如，如果你输入了 <code>Mafile</code>，回到 <code>f</code> 上，然后按 tab，shell 会补全 <code>Makefile</code>，而不是它通常的行为，即转到单词的末尾并尝试在那里找到一个补全，即匹配 <code>Mafile*</code> 的东西。某些类型的新补全（例如文件名补全）似乎无论选项设置如何都实现了这种行为；其他一些特性（例如下面描述的 <code>_prefix</code> 补全器）需要它，所以设置并习惯它是一件好事，除非你真的只需要在单词的末尾补全。</p>
<p><strong><code>ALWAYS_TO_END</code></strong></p>
<p>如果设置了这个，光标在单词被补全后总是移动到单词的末尾，即使补全是在中间进行的。这也发生在菜单补全中。</p>
<p>[]{#l151}</p>
<h3 id="625-改变补全的显示方式"><a class="header" href="#625-改变补全的显示方式">6.2.5: 改变补全的显示方式</a></h3>
<p><strong><code>LIST_TYPES</code></strong></p>
<p>这就像 <code>ls</code> 的 <code>-F</code> 选项；出现在补全列表中的文件会有一个尾随的 <code>/</code> 表示目录，<code>*</code> 表示当前进程可执行的常规文件，<code>@</code> 表示链接，<code>|</code> 表示命名管道，<code>%</code> 表示字符设备，<code>#</code> 表示块设备。这个选项默认是打开的。</p>
<p>请注意，标识符只有在补全系统知道该项应该是文件时才会出现。如果使用通常的文件名补全命令，这是自动的。如果你编写自己的补全函数并想告诉 shell 这些值可能是现有文件以应用 <code>LIST_TYPES</code>，<code>compadd</code> 内建命令也有一个 <code>-f</code> 选项（但如果不存在这样的文件也不会造成伤害）。</p>
<p><strong><code>LIST_PACKED</code>, <code>LIST_ROWS_FIRST</code></strong></p>
<p>这些影响补全列表的排列。使用 <code>LIST_PACKED</code>，补全列表通过改变列宽来尽可能紧凑，而不是将它们格式化成一个完全规则的网格。使用 <code>LIST_ROWS_FIRST</code>，列表顺序被改变，使得相邻的项目沿行出现而不是下行，有点像 <code>ls</code> 的 <code>-x</code> 选项。</p>
<p>可以使用 <code>list-packed</code> 和 <code>list-rows-first</code> 样式为特定上下文改变这两者。在这种情况下，样式总是覆盖选项；如果没有找到相应的样式，则使用选项设置。</p>
<p>还要注意后面关于补全组的讨论：可以让不同类型的补全出现在单独的列表中，然后可以使用这些对标签敏感的样式以不同方式格式化它们。</p>
<p>[]{#l152}</p>
<h2 id="63-新补全入门-1"><a class="header" href="#63-新补全入门-1">6.3: 新补全入门</a></h2>
<p>在我详细介绍新补全之前，这里是如何设置它以便你可以尝试一下。如上所述，进行补全的基本对象是 shell 函数。这些都是自动加载的，所以 shell 需要通过 <code>$fpath</code> 数组知道在哪里找到它们。如果 shell 安装正确，并且初始化文件中没有任何东西从 <code>$fpath</code> 中移除了所需的部分，这应该会自动发生。甚至可能你的系统为你设置了补全（Mandrake Linux 6.1 是第一个开箱即用这样做的系统），在这种情况下，输入 <code>which compdef</code>，你应该会看到一个完整的 shell 函数——实际上是那个允许你定义额外补全函数的函数。然后你可以跳过下一段。</p>
<p>如果你想加载补全，在命令行试试这个：</p>
<pre><code>  autoload -U compinit
  compinit
</code></pre>
<p>这应该会静默地工作。如果不行，你需要问你的系统管理员补全函数发生了什么，或者自己找到它们，然后将所有需要的目录添加到你的 <code>$fpath</code> 中。它们要么都在一个大目录里，要么在一组子目录里，名字是 <code>AIX</code>、<code>BSD</code>、<code>Base</code>、<code>Debian</code>、<code>Redhat</code>、<code>Unix</code>、<code>X</code> 和 <code>Zsh</code>；在第二种情况下，所有目录都需要在 <code>$fpath</code> 中。当这工作时，你可以将相同的行，包括你需要的任何对 <code>$fpath</code> 的修改，添加到你的 <code>.zshrc</code> 中。</p>
<p>你现在可以看看它是否真的在工作。输入 <code>cd </code>，然后 <code>^D</code>，你应该会看到一个只有目录的列表，没有常规文件。如果你设置了 <code>$cdpath</code>，你可能会看到 <code>ls</code> 看不到的目录。正如这所暗示的，补全系统为许多常见（以及一些相当深奥的）命令提供了补全。的确，其想法是，对于大多数用户来说，补全在大多数时候都能正常工作，无需干预。如果你认为它应该工作但没有，那可能是个 bug 或疏忽，你应该报告它。</p>
<p>另一个关于“它就是能工作”主题的例子：</p>
<pre><code>  tar xzf archive.tar.gz ^D
</code></pre>
<p>将查看 gzipped tar 归档文件内部——假设是 GNU 版本的 <code>tar</code>，其中第一组参数中的 <code>z</code> 报告归档文件已用 gzip 压缩——并给你一个可以提取的文件或目录列表。这与普通文件补全的方式非常相似；尽管有差异，你可以在归档文件内补全到任何目录深度。（在这一点上，你应该印象深刻了。）</p>
<p>补全系统知道的不仅仅是命令及其参数，它还理解一些 shell 语法。例如，有一个名为 <code>$_comps</code> 的关联数组，它将命令名称存储为键，将补全函数的名称存储为相应的值。试试输入：</p>
<pre><code>  print ${_comps[
</code></pre>
<p>然后 <code>^D</code>。你可能会收到一条消息，问你是否真的想看所有可能的补全，即 <code>$_comps</code> 的键；如果你说 <code>y</code>，你会看到一个列表。如果你插入任何那些键，然后关闭花括号，这样你就有了例如 <code>${_comps[mozilla]}</code>，然后按回车，你会看到处理该命令的补全函数；在这种情况下（在撰写本文时）是 <code>_webbrowser</code>。这是找出哪个函数正在处理特定命令的一种方法。如果没有条目——即 <code>print ${_comps[mycmd]}</code> 给你一个空行——那么该命令没有被特殊处理，将只使用为 <code>-default-</code> 上下文定义的任何函数，通常是 <code>_default</code>。通常这只会尝试补全文件名。如果你愿意，你可以自定义 <code>_default</code>。</p>
<p>除了 <code>-default-</code>，<code>_comps</code> 的一些其他键也看起来像 <code>-this-</code>：它们是特殊上下文，是命令参数之外的地方。我们正在使用名为 <code>-subscript-</code> 的上下文；你会发现这种情况下的函数叫做 <code>_subscript</code>。许多补全函数的名称只是一个下划线后跟命令或上下文名称，减去任何连字符。如果你想尝尝补全函数的样子，试试 <code>which _subscript</code>；你很可能会发现里面有很多你还不知道的其他命令。</p>
<p>重要的是要记住，以这种方式找到的函数是执行补全的根源。无论你如何摆弄选项或样式——我将在接下来的几节中谈论的东西——都无法改变这一点；如果你想改变基本的补全，你只需要编写自己的函数。</p>
<p>顺便说一句，你可能有想要混合使用的旧式补全——或者你可能特别不想混合它们，以便你可以确保一切都以新格式工作。默认情况下，新的补全系统会首先尝试找到一个特定的新式补全，如果找不到，它会尝试为所讨论的命令找到一个 <code>compctl</code> 定义的补全。如果所有这些都失败了，它会尝试通常的新式默认补全，可能只是文件名补全。请注意，特定的新式补全优先，这是公平的，因为如果你添加了它们，你几乎肯定不想回到旧的形式。然而，如果你永远不想尝试旧式补全，你可以在你的 <code>.zshrc</code> 中放入以下咒语：</p>
<pre><code>  zstyle ':completion:*' use-compctl false
</code></pre>
<p>目前，这只是黑魔法，但稍后我将更详细地解释“样式”机制，你会看到这与新式补全中关闭东西的正常方式相符。</p>
<p>[]{#l153}</p>
<h2 id="64-shell-如何找到正确的补全-1"><a class="header" href="#64-shell-如何找到正确的补全-1">6.4: shell 如何找到正确的补全</a></h2>
<p>[]{#l154}</p>
<h3 id="641-上下文"><a class="header" href="#641-上下文">6.4.1: 上下文</a></h3>
<p>上面的例子表明，补全系统是高度上下文敏感的，所以了解这些上下文是如何描述的很重要。这个系统是逐渐演变的，但我所说的一切都适用于所有主版本为 4 的 zsh。</p>
<p>我们处于补全的哪个状态，是以一种冒号分隔的路径给出的，从最不具体的部分开始。有一个简单的方法可以找出你所在的上下文：在你想要补全的地方，输入 <code>^Xh</code>，它会告诉你。在 <code>$_comps</code> 的例子中，你会发现，</p>
<pre><code>  :completion::complete:-subscript-::
</code></pre>
<p>加上一个所谓的“标签”和补全函数的列表，我稍后会讲到。完整的形式是：</p>
<pre><code>  :completion:&lt;func&gt;:&lt;completer&gt;:&lt;command&gt;:&lt;argument&gt;:&lt;tag&gt;
</code></pre>
<p>其中元素如果未设置可能会丢失，但冒号总是在那里，以便于模式匹配。在 <code>:completion:</code> 部分之后，上下文的各个部分的含义如下，这对于整个补全系统是通用的。</p>
<p><em><strong><func></strong></em>
:   是调用补全的函数的名称——如果它是从标准补全系统启动的，则为空白，并且只在一些特殊情况下出现，本章第六节会列出。</p>
<p><em><strong><completer></strong></em>
:   在这种情况下被称为 <code>complete</code>：这指的是补全系统能做的不仅仅是简单的补全；例如，它可以做一种更受控制的展开（如我提到的），拼写纠正，以及补全带拼写错误的单词。我稍后会介绍其他的补全器；<code>complete</code> 是最简单的，只做基本的补全。</p>
<p><em><strong><command></strong></em>
:   是命令的名称或如上所述的其他类似上下文，这里是 <code>-subscript-</code>。</p>
<p><em><strong><argument></strong></em>
:   当 <code>&lt;command&gt;</code> 是一个真实命令的名称时最有用；它描述了我们在该命令的参数中的位置。你稍后会看到它是如何工作的。许多更简单的补全不使用这个；只有那些具有复杂选项和参数组合的才使用。如果你需要知道，你只需要用 <code>^Xh</code> 找出。</p>
<p><em><strong><tag></strong></em>
:   描述补全的类型，本质上是一种区分在命令行同一点可以补全的不同事物的方式。</p>
<p>现在看看一个更正常的命令-参数补全的上下文，例如在 <code>cd</code> 之后；在这里你会看到上下文 <code>:completion::complete:cd::</code>。这里上下文的命令名部分是一个真实的命令。</p>
<p>对于更复杂的东西，试试在 <code>cvs add</code> 之后（如果你没有 <code>cvs</code> 命令，这没关系）。你会看到一个长而重复的标签列表，用于两种可能的上下文，</p>
<pre><code>  :completion::complete:cvs:argument-rest:
  :completion::complete:cvs-add:argument-rest:
</code></pre>
<p>你两者都有的原因是，<code>add</code> 不仅是 <code>cvs</code> 的一个参数，如第一个上下文所示，它本身也是一个子命令，有自己的参数，这就是第二个上下文的用途。第一个上下文意味着在 <code>add</code> 及其参数之后可能还有更多与它们完全独立的子命令——尽管实际上 CVS 不是那样工作的，所以那种形式在这里不会给你任何补全。</p>
<p>在这两者中，<code>argument-rest</code> 表明补全正在寻找另一个参数，<code>rest</code> 表示它是行尾的参数列表；如果位置很重要（请看 <code>cvs import</code> 的例子），上下文会包含 <code>argument-1</code>，或者别的什么。<code>cvs-add</code> 显示了子命令是如何处理的，通过用连字符而不是冒号分隔，以免混淆上下文的不同部分。</p>
<p>除了命令和子命令的参数，选项的参数是另一个常见的可能性；举个例子，在 <code>dvips -o</code> 之后输入 <code>^Xh</code>，你会看到上下文 <code>:completion::complete:dvips:option-o-1:</code>；这表明你正在补全 <code>dvips</code> 的 <code>-o</code> 选项的第一个参数（它只接受一个参数），恰好是输出文件的名称。</p>
<p>[]{#l155}</p>
<h3 id="642-标签"><a class="header" href="#642-标签">6.4.2: 标签</a></h3>
<p>现在讲到与上下文有关的另一件事，标签。让我们回到 <code>cd</code> 命令后的 <code>^Xh</code> 帮助测试的完整输出：</p>
<pre><code>  tags in context :completion::complete:cd::
    local-directories path-directories  (_alternative _cd)
</code></pre>
<p>与到目前为止考虑的上下文不同，它们告诉你补全是<em>如何</em>到达它所在的位置的，标签描述了它<em>可以</em>在这里补全的东西。在这种情况下，有三个：<code>directory-stack</code> 指的是像 <code>+1</code> 这样的条目；目录栈是使用 <code>pushd</code> 命令定义的目录集，你可以用 <code>dirs</code> 命令看到。接下来，<code>local-directories</code> 指的是当前工作目录的子目录，而 <code>path-directories</code> 指的是通过搜索 <code>$cdpath</code> 数组找到的任何目录。系统提供的每个可能的补全都属于这些类别之一。</p>
<p>在括号里，你看到了被调用来生成补全的函数的名称；如果你想改变基本的补全行为，你需要改变或替换这些。调用函数出现在右边，被调用函数出现在左边，所以在这种情况下，函数 <code>_cd</code> 是第一个被调用来处理 <code>cd</code> 命令参数的函数，符合通常的惯例。一些标准的补全函数已经从这个列表中被过滤掉了——知道它经过了 <code>_main_complete</code> 和 <code>_complete</code> 对你没有帮助，例如。</p>
<p>也许已经很明显，让系统以不同方式对待不同类型的补全是有用的，但这里有一个例子，它让你预览了“样式”机制，稍后会讨论。样式是一种美化的 shell 参数；它们用 <code>zstyle</code> 命令定义，使用一个样式名和可能的值，这些值可以是一个数组；你总是可以把一个样式定义为一个数组，但一些样式可能只是把它当作一个字符串，用空格连接你给它的参数。你也可以用 <code>zstyle</code> 命令，用不同的参数，来检索它们的值，这正是补全系统自己做的；与参数及其值没有实际的重叠，所以它们不会妨碍正常的 shell 编程。</p>
<p>样式与参数的不同之处在于，它们可以在不同的上下文中取不同的值。<code>zstyle</code> 命令的第一个参数给出一个上下文；当你定义一个样式时，这个参数实际上是一个模式，将与当前上下文匹配以查看样式是否适用。找出适用规则的规则是：精确的字符串匹配优先于模式，较长的模式优先于较短的模式。这里是那个例子：</p>
<pre><code>  zstyle ':completion:*:cd:*' tag-order local-directories   path-directories
</code></pre>
<p>从上面对上下文的讨论中，当 <code>cd</code> 命令的参数被补全时，该模式将匹配。正在设置的样式叫做 <code>tag-order</code>，值是 <code>cd</code> 中对目录有效的两个标签。</p>
<p><code>tag-order</code> 样式决定了标签被尝试的顺序。上面给出的值意味着首先会补全 <code>local-directories</code>；只有当没有可以补全的时候，才会尝试 <code>path-directories</code>。你可以输入命令并尝试这个；如果你没有设置 <code>$cdpath</code>，你可以赋 <code>cdpath=(~)</code>，这将允许 <code>cd foo</code> 切换到目录 <code>~/foo</code> 并相应地补全目录。转到一个不是 <code>~</code> 的目录；<code>cd</code> 的补全将只显示你所在位置的子目录，而不是 <code>~</code> 的子目录，除非你输入一个字符串，它是 <code>~</code> 下目录的前缀，但不是你当前目录的前缀。例如，</p>
<pre><code>  % cdpath=(~)
  % ls -F ~
  foo/    bar/
  % ls -F
  rod/    stick/
  # 没有那个 tag-order zstyle 命令，你会得到...
  % cd ^D
  bar/    foo/    rod/    stick/
  % zstyle ':completion:*:cd:*' tag-order local-directories   path-directories
  # 现在你只得到本地目录，如果有的话...
  % cd ^D
  rod/    stick/
</code></pre>
<p>你可以用 <code>tag-order</code> 样式做更多的事情：如果你把标签放在同一个词里，通过引用，例如 <code>"local-directories path-directories"</code>，那么它们会同时被尝试，在这种情况下，你得到的是默认的效果。事实上，由于要知道每个可能的补全有哪些标签可用工作量太大，当没有合适的 <code>tag-order</code> 时，默认是简单地一次性尝试上下文中所有可用的标签；这当然是最初 <code>cd</code> 之后补全发生的情况。</p>
<p>即使有 <code>tag-order</code> 规范，任何未指定的标签通常也会在最后一起被尝试，所以你实际上可以从原始例子的末尾省略 <code>path-directories</code>，效果会是一样的。如果你不希望那样发生，你可以在标签列表中指定一个 <code>-</code>，它不被用作标签，而是告诉补全只应该尝试列表中的标签，而不是任何其他可能可用的。此外，如果你不希望显示某个特定的标签，你可以在值中包含 <code>!tagname</code>，除了这个之外的所有其他标签都会被包含。例如，你可能已经注意到，在命令位置补全时，你会看到要设置的参数以及命令等：</p>
<pre><code>  Completing external command
  tex             texhash         texi2pdf        text2sf
  texconfig       texi2dvi        texindex        textmode
  texdoc          texi2dvi4a2ps   texlinks        texutil
  texexec         texi2html       texshow         texview
  Completing parameter
  TEXINPUTS                               texinputs
</code></pre>
<p>（我还没告诉你如何产生那些描述，或者如何让不同标签的补全分开出现，但我会的——请参阅下面对“format”和“group-name”样式的描述。）如果你设置</p>
<pre><code>  zstyle ':completion:*:-command-:*' tag-order '!parameters'
</code></pre>
<p>那么最后两行将从补全中消失。当然，你的补全列表可能看起来与我的完全不同。顺便说一句，关于样式的一个好处是，它们是在补全加载之前还是之后定义都无所谓，因为样式是由 shell 的另一部分存储和检索的。</p>
<p>要排除多个标签名，你需要将名称包含在同一个词中。例如，要同时排除参数和保留字，值将是 <code>'!parameters reserved-words'</code>，而<em>不是</em> <code>'!parameters' '!reserved-words'</code>，后者会尝试一次排除参数的补全，然后再一次排除保留字的补全。此外，标签实际上可以是模式，或者更准确地说，<code>tag-order</code> 的参数中的任何单词都可能包含一个模式，然后将尝试与所有有效标签进行匹配，看是否匹配。有时甚至使用 <code>*</code> 来匹配所有标签也很有用，如果你正在指定一个标签的特殊形式——也许使用一个标签，如下所述——在同一个词中。请参阅手册，了解所提供函数理解的所有标签名称。</p>
<p><code>tag-order</code> 样式允许你给标签“标签”，这是一种别名，指示补全系统使用一个不同名称的标签。你通过给出标签后跟一个冒号，再跟上标签来安排这个。标签前面也可以有一个连字符，这意味着在查找标签时，原始标签名应该放在前面；这真的只是一个让名称看起来更整洁的方式。结果是，通过使用带有标签名的上下文，而不是标签名，你可以安排特殊的行为。此外，你可以为带标签的标签给出一个替代的描述；这些会与我下面将描述的 <code>format</code> 样式一起显示（我个人觉得非常有用）。你把描述放在另一个冒号后面，任何空格都要引用。它看起来会是这样：</p>
<pre><code>  zstyle ':completion:*:aliens:*' tag-order   'frooble:-funny:funny frooble' frooble
</code></pre>
<p>这在你为 <code>aliens</code> 命令补全时使用，该命令大概有标记为 <code>frooble</code> 的补全（如果没有，你很奇怪）。然后补全会首先查找该标签的样式，名称为 <code>frooble-funny</code>，如果它使用那些样式找到了补全，它会用 <code>funny frooble</code> 的描述列出它们（如果你正在使用 <code>format</code>）。否则，它会查找该标签的样式，名称为其通常的名称，并再次尝试补全。大概很明显，如果你对标签的两个标签没有不同的样式，你每次都会得到相同的补全。</p>
<p>与其现在通过给出如何使用标签标签的例子来让你对标签信息过载，我将把这个保留到下面对 <code>ignored-patterns</code> 样式的描述中，那是标签的一个简洁用法。事实上，它就是为此发明的；可能还有很多我们还没想到的其他用法。</p>
<p>关于 <code>tag-order</code> 的一个重要说明，我可能没有像我应该的那样明确：<em>它不改变在该补全中实际有效的标签</em>。仅仅将一个标签名放入列表并不意味着该标签名将被使用；那完全由特定上下文的补全函数决定。<code>tag-order</code> 样式只是改变了<em>有效</em>的标签被检查的顺序。当你搞不清楚为什么 <code>tag-order</code> 不做你想要的事情时，再回来读一遍这段。</p>
<p>请注意，测试模式的规则意味着你总是可以通过 <code>zstyle "*" style ...</code> 来指定一个万能的最坏情况，它总是最后被尝试——不仅仅是在补全中，实际上，因为 shell 的其他部分也使用样式机制，并且没有 <code>:completion:</code> 在上下文的开头，这个样式定义也会在那里被拾取。</p>
<p>像 <code>tag-order</code> 这样的样式是标签单独使用的最重要的情况。在其他情况下，它们可以被添加到上下文的末尾；这对于可以为不同的补全集给出不同结果的样式很有用，特别是决定补全列表如何显示，或者一个补全如何插入到命令行中的样式。标签是最后一个元素，所以后面没有冒号。一个完整的上下文然后看起来像 <code>:completion::complete:cd::path-directories</code>。稍后，你会看到一些可以为不同的标签上下文有用地不同的样式。然而，请记住，上下文的标签部分，像其他部分一样，如果补全系统还没有弄清楚它应该是什么，可能会是空的。</p>
<p>[]{#l156}</p>
<h2 id="65-使用样式配置补全-1"><a class="header" href="#65-使用样式配置补全-1">6.5: 使用样式配置补全</a></h2>
<p>你现在知道如何为特定的上下文定义一个样式，使用</p>
<pre><code>  zstyle &lt;context&gt; &lt;style&gt; &lt;value...&gt;
</code></pre>
<p>以及一些它有用的情况。在介绍其他样式之前，这里有一些更详细的信息。我已经说过样式可以接受一个数组值，即 <code>zstyle</code> 命令末尾的一组值，对应于数组元素，你已经看到了一个例子（<code>tag-order</code>），其中这是有用的。然而，许多样式只使用一个值。有一个特别常见的情况，你只是想打开或关闭一个值，即一个布尔值。在这种情况下，你可以使用 <code>true</code>、<code>yes</code>、<code>on</code> 或 <code>1</code> 表示开，<code>false</code>、<code>no</code>、<code>off</code> 或 <code>0</code> 表示关。你以同样的方式定义所有样式；只有当它们被使用时，才决定它们应该是标量、数组还是布尔值，样式名称也不会被检查是否有效，因为 shell 不知道以后可能会查找哪些样式。同样明显地，这也适用于上下文。</p>
<p>你可以使用 <code>zstyle</code> 或 <code>zstyle -L</code> 来列出现有的样式（不是单独的，只能是完整的列表）。在第二种情况下，它们以 <code>zstyle</code> 命令集的形式输出，这些命令可以重新生成当前定义的样式。这对于 <code>grep</code> 也很有用，因为你可以很容易地检查特定样式的所有可能上下文。</p>
<p>使用 <code>zstyle</code> 最强大的方式是使用 <code>-e</code> 选项。这表示你提供的单词将被评估，就像作为 <code>eval</code> 的参数一样。这应该将数组 <code>$reply</code> 设置为要使用的单词。所以</p>
<pre><code>  zstyle '*' days 'Monday Tuesday'
</code></pre>
<p>和</p>
<pre><code>  zstyle -e '*' days 'reply=(Monday Tuesday)'
</code></pre>
<p>是等效的——但意图当然是，在第二种情况下，参数每次都可以返回一个不同的值，以便样式可以变化。它通常会在补全的热潮中被评估，因此会获取所有的编辑参数；所以例如</p>
<pre><code>  zstyle -e ':completion:*' mystyles 'reply=(${NUMERIC:-0})'
</code></pre>
<p>如果你为命令输入了一个非零的前缀参数，如<a href="zshguide04.html#zle">第四章</a>中所述，将使样式返回一个非零整数（可能表示 <code>true</code>）。然而，参数可以包含任何 zsh 代码，而不仅仅是一个简单的赋值。记住要引用它，以防止它在 <code>zstyle</code> 命令行运行时变成别的东西。</p>
<p>最后，你可以通过</p>
<pre><code>  zstyle -d [ &lt;context-pattern&gt; [ &lt;style&gt; ] ] ...
</code></pre>
<p>来删除一个样式或一个样式列表的上下文——注意，虽然第一个参数是一个模式，但在这种情况下，它被精确地处理，所以如果你给出模式 <code>:completion:*:cd:*</code>，只有用<em>完全</em>那个模式给出的值才会被删除，而不是上下文以 <code>:completion:</code> 开头并包含 <code>:cd:</code> 的其他值。在删除时，模式和样式是可选的；如果省略，上下文的所有样式，或任何类型的所有样式，都会被删除。补全系统有自己的默认值，但这些是内置的，所以你指定的任何东西都有优先权。</p>
<p>顺便说一句，我在<a href="zshguide04.html#zle">第四章</a>中顺便提到了，你可以在普通的 zle 小部件（用 <code>zle -N</code> 创建的那些）中以完全相同的方式使用样式，但你可能马上就忘了。本章关于定义样式和在你自己的函数中使用它们的所有说明都适用于 zle 函数。唯一的区别是，在这种情况下，上下文的约定是，对于执行小部件 <em>widget-name</em>，上下文被设置为 <code>:zle:*widget-name*</code>。</p>
<p>本节的其余部分描述了一些有用的样式。如果你想让样式的值在不同的地方不同，就由你来试验上下文，或者如果你不在乎，就用 <code>*</code>。</p>
<p>[]{#l157}</p>
<h3 id="651-指定补全器及其选项"><a class="header" href="#651-指定补全器及其选项">6.5.1: 指定补全器及其选项</a></h3>
<p>“补全器”是决定正在进行何种补全的幕后函数。你用 <code>completer</code> 样式来设置使用哪些补全器，它接受一个按顺序尝试的补全器数组。例如，</p>
<pre><code>  zstyle ':completion:*' completer _complete _correct _approximate
</code></pre>
<p>指定首先尝试正常补全（<code>_complete</code>），然后是拼写纠正（<code>_correct</code>），最后是近似补全（<code>_approximate</code>），这本质上是前两者的组合效果，即补全输入的单词但允许拼写错误。所有补全器都设置上下文，所以在 <code>_complete</code> 内部你通常会找到 <code>:completion::complete:...</code>，在纠正内部是 <code>:completion::correct:..</code>，依此类推。</p>
<p>补全器有一个标签功能，有点像上面描述但没有详细说明的标签功能。你可以像这样在列表中放入一个补全器：</p>
<pre><code>  zstyle ':completion:*' completer ... _complete:comp-label ...
</code></pre>
<p>它调用补全器 <code>_complete</code>，但在样式中查找东西时假装它的名字是 <code>comp-label</code>，所以你可以多次尝试带有不同功能的补全器。就像标签一样，你可以像 <code>_complete:-label</code> 这样写，普通的名字会被前置以得到名字 <code>complete-label</code>——只是一个快捷方式，它没有引入任何新东西。我将推迟一个例子，直到你知道补全器做什么。</p>
<p>这里是现有补全器的更详细描述；它们都是函数，所以你可以简单地复制和修改一个来制作你自己的补全器。</p>
<p><strong><code>_complete</code></strong></p>
<p>这是基本的补全行为，我们到目前为止一直假设是这样。它的主要用途只是检查上下文——这里的意思是我们是在补全一个普通的命令参数还是一个特殊的 <code>-context-</code> 地方——并调用适当的补全函数。通过设置参数 <code>compcontext</code> 来欺骗它是可能的，它将被用来代替自动生成的那个；如果你为特殊情况编写自己的补全命令，这可能很有用。如果你这样做，你应该使该参数对你的函数是局部的。</p>
<p><strong><code>_approximate</code></strong></p>
<p>这做近似补全：它实际上是作为 <code>_complete</code> 补全器的包装器编写的，所以它做所有 <code>_complete</code> 做的事情，但它也设置系统以允许带拼写错误的补全。通常，你会想先尝试没有拼写错误的补全，所以这个补全器通常出现在 <code>completers</code> 样式的 <code>_complete</code> 之后。</p>
<p>主要的控制手段是通过 <code>max-errors</code> 样式。你可以将它设置为允许的最大错误数。一个错误被定义为如近似模式匹配手册中所述：一个缺失的字符，如 <code>rhythm</code> / <code>rhytm</code>，一个额外的字符，如 <code>rhythm</code> / <code>rhythms</code>，一个不正确的字符，如 <code>rhythm</code> / <code>rhxthm</code>，或一对转置的字符，如 <code>rhythm</code> <code>rhyhtm</code>，每个都算作一个错误。近似将首先尝试找到一个带有一个错误的匹配，然后是两个错误，依此类推，直到并包括 <code>max-errors</code> 的值；选择错误数最少的匹配集，所以即使你将 <code>max-errors</code> 设置得很大，错误数较少的匹配总是会被优先选择。设置一个大的 <code>max-errors</code> 的真正问题是它会更慢，并且更有可能产生与你想要的完全不同的匹配——对于打字错误，两三个可能就是你需要的最多。否则，总有 Mavis Beacon。因此：</p>
<pre><code>  % zstyle ':completion:*' max-errors 2
  # 只是为了举例...
  % zstyle ':completion:*' completer _approximate
  % ls
  ashes    sackcloth
  % echo siccl&lt;TAB&gt;
    -&gt; echo sackcloth
  % echo zicc&lt;TAB&gt;
    &lt;Beep.&gt;
</code></pre>
<p>因为 <code>s[i/a]c[k]cloth</code> 只有两个错误，而 <code>[z/s][i/a]c[k]cloth</code> 会是三个，所以不补全。</p>
<p>还有另一种给出最大错误数的方法，使用在 Emacs 模式下用 <code>ESC-&lt;digit&gt;</code> 指定的数字前缀，在 vi 命令模式下直接用数字键，或者用 <code>universal-argument</code>。要启用这个，你必须在 <code>max-errors</code> 的值中包含字符串 <code>numeric</code>——因此这实际上可以是一个数组，例如</p>
<pre><code>  zstyle ':completion:*:approximate:*' max-errors 2 numeric
</code></pre>
<p>自动允许最多两个错误，但你可以通过给补全命令一个前缀来指定一个更高的最大值。所以继续上面的例子，输入新的 <code>zstyle</code> 和：</p>
<pre><code>  % echo zicc&lt;ESC-3&gt;&lt;TAB&gt;
    -&gt; echo sackcloth
</code></pre>
<p>因为我们允许了三个错误。你可以开始看到允许太多错误的问题：如果你有文件 <code>zucchini</code>，那只有一个错误，它会被找到并插入，而 <code>sackcloth</code> 甚至都不会被考虑。</p>
<p>请注意，上下文在补全器中立即被检查，所以在这个阶段它只是 <code>:completion::approximate:::</code>；没有更详细的上下文信息可用，所以不可能为不同的命令或标签指定不同的 <code>max-errors</code>。</p>
<p>作为样式值的最后一种可能性是 <code>not-numeric</code>：那意味着如果给出了任何数字前缀，近似将根本不被执行。在最后一个例子中，补全将不得不找到一个以 <code>zicc</code> 开头的文件。</p>
<p>其他次要的样式也控制近似。样式 <code>original</code>，如果为 true，意味着原始值总是被视为一个可能的补全，即使它不匹配任何东西，即使没有其他东西匹配。补全原始值和更正使用不同的标签，不具想象力地称为 <code>original</code> 和 <code>corrections</code>，所以你可以用 <code>tag-order</code> 样式来组织这个。</p>
<p>因为在这种情况下，补全通常与命令行上已有的内容不匹配，并且很可能彼此不匹配，所以会立即进入菜单补全，供你选择一个补全。你可以通过设置布尔样式 <code>insert-unambiguous</code> 来安排如果有一个无歧义的部分可以先插入，则不发生这种情况。</p>
<p>最后两个样式（<code>original</code> 和 <code>insert-unambiguous</code>）在很早的时候就被查找，当生成更正的上下文被设置时，所以只有到补全器名称的上下文是可用的。补全器名称后面会跟着一个连字符和当前接受的错误数。所以对于尝试一个错误的近似，上下文是 <code>:completion::approximate-1:::</code>；如果那失败了，系统需要寻找带两个错误的补全，上下文将是 <code>:completion::approximate-2:::</code>，依此类推；对于下一个描述的补全器，纠正和 <code>correct-1</code> 等也是如此。</p>
<p><strong><code>_correct</code></strong></p>
<p>这与 <code>_approximate</code> 非常相似，只是上下文是 <code>:completion::correct:*</code>（或者在生成更正时是 <code>:completion::correct-&lt;num&gt;:*</code>，如上所述），并且它不会执行补全，只执行拼写纠正，所以补全器必须在行上单词的末尾添加的额外字符现在算作额外的错误，而不是以普通方式补全：<code>zicc</code> 离 <code>sackcloth</code> 差得很远，七个错误，但 <code>ziccloth</code> 只算三个。<code>_correct</code> 补全器的控制方式与 <code>_approximate</code> 完全相同。</p>
<p>有一个单独的命令只做纠正而不做其他任何事情，通常绑定到 <code>^Xc</code>，所以如果你乐于使用那个，你不需要在补全器列表中包含 <code>_correct</code>。如果你确实包含了它，并且你也有 <code>_approximate</code>，<code>_correct</code> 应该排在前面；<code>_approximate</code> 肯定会生成 <code>_correct</code> 生成的所有匹配，并且可能更多。像其他单独的补全命令一样，它有自己的上下文，这里以 <code>:completion:correct-word:</code> 开头，所以很容易让这个命令的行为与正常的补全器不同。</p>
<p>老用户会记得 shell 中内置了另一种形式的拼写纠正，用 <code>ESC-$</code> 或 <code>ESC-s</code> 调用。这只纠正文件名，并且不理解任何关于新补全机制的东西；使用它的唯一原因是它可能更快。然而，如果你使用 <code>CORRECT</code> 或 <code>CORRECT_ALL</code> shell 选项，你将使用旧的文件名纠正机制；目前还无法改变这个。</p>
<p><strong><code>_expand</code></strong></p>
<p>这实际上执行展开，而不是补全；区别在本章开头已经解释过了。如果你使用它，你应该将 tab 绑定到 <code>complete-word</code>，而不是 <code>expand-or-complete</code>，因为否则在补全机制启动之前就会执行展开。由于展开通常仍然应该在补全之前尝试，这个补全器应该出现在 <code>completers</code> 样式的值列表中的 <code>_complete</code> 及其亲属之前。</p>
<p>使用这个补全器而不是正常展开的原因是，你可以使用 <code>:completion:*:expand:*</code> 上下文中的样式来控制执行哪些展开。这里是相关的样式：</p>
<p><strong><code>glob</code></strong>
:   展开 glob 表达式，换句话说，使用通配符进行文件名生成。</p>
<p><strong><code>substitute</code></strong>
:   展开包含活动 <code>$</code> 或反引号的表达式。</p>
<p>但请记住，在使用此补全器时，你需要</p>
<pre><code>  bindkey '^i' complete-word
</code></pre>
<p>因为否则由正常绑定 <code>expand-or-complete</code> 运行的内置展开机制将接管。</p>
<p>你也可以控制展开是如何插入的。用于添加展开的标签是 <code>original</code>（大概不言自明），<code>all-expansions</code>，它指的是添加一个包含所有可能展开的单个字符串（默认值，就像编辑器函数 <code>expand-word</code> 一样），和 <code>expansions</code>，它指的是逐个添加的结果。通过改变标签被尝试的顺序，如上面对 <code>tag-order</code> 样式的描述，你可以决定这如何发生。例如，</p>
<pre><code>  zstyle ':completion:*' completer _expand _complete
  zstyle ':completion::expand:*' tag-order expansions
</code></pre>
<p>设置为通过补全执行 glob 展开，展开结果逐个呈现（通常通过菜单补全，因为没有共同的前缀）。将 <code>expansions</code> 改为 <code>all-expansions</code> 会插入列表，就像正常的展开机制所做的那样，而将其改为 <code>expansions original</code> 会保留逐个条目，但也会将原始字符串作为一个可能性呈现。你甚至可以三者都有，即整个列表作为一个单一的字符串成为可能性集合中的一个。</p>
<p>还有一个 <code>sort</code> 样式，它决定了生成的展开是否会像补全通常那样被排序，还是保持 shell 从展开中产生的原样（例如，展开一个数组参数会按顺序产生元素）。如果它是 <code>true</code>，它们将总是被排序，如果 <code>false</code> 或未设置则永远不会，如果它是 <code>menu</code>，它们将为 <code>expansions</code> 标签排序，但对于 <code>all-expansions</code> 标签则不会，后者将是原始顺序的值的单个字符串。</p>
<p>当你只尝试生成 <code>glob</code> 展开，而不使用 <code>substitute</code> 时，有一个轻微的问题。事实上，不难看出，像 <code>$PWD/*.c</code> 这样的表达式如果 <code>substitute</code> 不活动，就没有任何意义；它必须活动才能理解这样的表达式。然而，如果没有匹配，这很烦人：你最终会得到一个带有展开的 <code>$PWD</code> 的补全，但 <code>*.c</code> 仍然附加在末尾，这不是你想要的。如果你主要使用 <code>_expand</code> 进行通配，你可能因此想将样式 <code>subst-globs-only</code> 设置为 true：如果一个补全只是展开了参数，而通配什么也没做，那么展开被拒绝，行保持不变。</p>
<p><code>_expand</code> 补全器也会使用样式</p>
<p><strong><code>accept-exact</code></strong>
:   适用于以 <code>$</code> 或 <code>~</code> 开头的单词。假设有一个参数 <code>$foo</code> 和一个参数 <code>$foobar</code>，并且你在行上有 <code>$foo</code>。通常补全系统会在此时执行补全。然而，设置了 <code>accept-exact</code> 后，<code>$foo</code> 将被展开，因为它匹配一个参数。</p>
<p><strong><code>add-space</code></strong>
:   意味着在展开后添加一个空格，就像成功的补全一样——尽管目录会得到一个 <code>/</code>。为了更精细的控制，它可以被设置为单词 <code>file</code>，这意味着只有当展开的单词匹配一个已经存在的文件时才会添加空格（想法是，如果它不存在，你可能想进一步补全）。<code>true</code> 和 <code>file</code> 都可以与 <code>subst</code> 结合使用，这可以防止在展开 <code>${...}</code> 或 <code>$(...)</code> 形式的替换后添加空格。</p>
<p><strong><code>keep_prefix</code></strong>
:   也解决了 <code>~</code> 或 <code>$</code> 是否应该被展开的问题。如果设置了，前缀将被保留，所以将 <code>~/f*</code> 展开为 <code>~/foo</code> 不会将 <code>~</code> 变成 <code>/home/pws</code>。默认值是 <code>changed</code>，这是 <code>false</code> 和 <code>true</code> 之间的折中方案：它的意思是，如果单词没有其他变化，即没有找到其他可能的展开，<code>~</code> 或 <code>$</code> 将被展开。如果这个样式的效果是展开与未展开的单词相同，那么在 <code>_expand</code> 之后的列表中的下一个补全器将被尝试。</p>
<p><strong><code>suffix</code></strong>
:   与 <code>keep_prefix</code> 类似。所指的“后缀”是在以 <code>~</code> 或 <code>$</code> 开头的表达式之后，不属于该展开的一部分的东西。如果设置了这个样式，并且存在这样的后缀，则不执行展开。所以，例如，<code>~pw&lt;TAB&gt;</code> 可以被展开为 <code>~pws</code>，但 <code>~pw/</code> 不符合展开的条件；同样 <code>$fo</code> 和 <code>$fo/</code> 也是。这个样式默认为 <code>true</code>——所以如果你想让 <code>_expand</code> 总是展开这样的表达式，你需要自己将它设置为 <code>false</code>。</p>
<p>获得 <code>_expand</code> 补全器提供的那种对展开的控制的一种更简单的方法是使用 <code>_expand_word</code> 函数，通常绑定到 <code>\C-xe</code>，它做所有上面描述的事情，而不会与其他补全器混淆。在这种情况下，上下文字符串以 <code>:completion:expand-word:</code> 开头，所以你可以为这个设置与 <code>_expand</code> 补全器不同的样式。</p>
<p>为展开设置不同的优先级是补全器标签的一个好用途，例如</p>
<pre><code>  zstyle ':completion:*' completer _expand:-glob _expand:-subst
  zstyle ':completion:*:expand-glob:*' glob yes
  zstyle ':completion:*:expand-subst:*' substitute yes
</code></pre>
<p>是使 <code>_expand</code> 尝试 glob 补全，如果失败则进行替换，并将结果作为展开呈现的基本设置。你几乎肯定会想添加细节来帮助这个。</p>
<p><strong><code>_history</code></strong></p>
<p>这会从 shell 的历史中补全单词，换句话说，就是你在前几行输入或补全或展开的所有内容。有三个样式会影响它，<code>sort</code> 和 <code>remove-all-dups</code>；它们在下面为命令小部件 <code>_history_complete_word</code> 描述。那个小部件本质上是作为特殊按键执行这个补全器的工作。</p>
<p><strong><code>_prefix</code></strong></p>
<p>严格来说，这个补全器本身不做补全，因此应该在下面以 <code>_match</code> 开头的组中。然而，它<em>似乎</em>做补全……让我解释一下。</p>
<p>许多 shell，包括 zsh，都有只补全光标前单词的功能，zsh 补全行话称之为“前缀”。我上面在谈论 <code>expand-or-complete-prefix</code> 时解释过这个；当你使用那个而不是正常的补全函数时，最终补全的单词看起来像 <code>&lt;prefix&gt;&lt;completion&gt;&lt;suffix&gt;</code>，其中补全将 <code>&lt;prefix&gt;</code> 变成了 <code>&lt;prefix&gt;&lt;completion&gt;</code>，全程忽略了 <code>&lt;suffix&gt;</code>。</p>
<p><code>_prefix</code> 补全器让你可以在正常补全中做到这一点。发生的情况是，补全器按正常顺序从左到右评估，直到找到一个补全。如果到达 <code>_prefix</code>，则只对前缀尝试补全。所以如果你的补全器是 <code>_complete _prefix</code>，shell 会首先尝试对整个单词，前缀和后缀，进行补全，然后只对前缀进行补全。只使用第一个“真实”的补全器（<code>_complete</code>、<code>_approximate</code>、<code>_correct</code>、<code>_expand</code>、<code>_history</code>）。</p>
<p>你可以通过在补全器列表中多次包含 <code>_prefix</code> 来多次尝试前缀补全；第二次，它会尝试列表中的第二个“真实”补全器；所以如果它们是 <code>_complete _prefix _correct _prefix</code>，你会得到先是普通补全，然后是只对前缀的相同操作，然后是普通纠正，然后是只对前缀的相同操作。你可以将任一 <code>_prefix</code> 补全器移动到序列中你希望尝试仅前缀版本的位置。</p>
<p><code>_prefix</code> 补全器会重新查找 <code>completer</code> 样式。这意味着你可以使用一个非默认的补全器集，只用于 <code>_prefix</code>。这里，如手册中所述，是如何强制 <code>_prefix</code> 只作为最后手段使用，并且只与正常补全一起使用：</p>
<pre><code>  zstyle ':completion:::::' completer _complete   &lt;other-completers&gt; _prefix
  zstyle ':completion::prefix:::' completer _complete
</code></pre>
<p>显示了完整的上下文，只是为了强调形式；像往常一样，如果你不在乎，你可以使用通配符。在这种情况下，你可以<em>只</em>使用 <code>_prefix</code> 作为补全器，而包含后缀的补全将永远不会被尝试；然而，你必须确保你有 <code>prefix</code> 上下文的 <code>completer</code> 样式，否则根本不会进行任何补全。</p>
<p>补全器标签技巧在这里再次有用：你可以多次调用 <code>_prefix</code>，无论你选择在你的补全器列表中的哪个位置，并强制它每次都在不同的上下文中查找。</p>
<pre><code>  zstyle ':completion:*' completer _complete _prefix:-complete   _approximate _prefix:-approximate
  zstyle ':completion:*:prefix-complete:*' completer _complete
  zstyle ':completion:*:prefix-approximate:*' completer _approximate
</code></pre>
<p>这会尝试普通补全，然后是只对前缀的相同操作，然后是近似补全，然后是只对前缀的相同操作。如上一段所述，完全可以省略原始的 <code>_complete</code> 和 <code>_approximate</code> 补全器，只使用带 <code>_prefix</code> 前缀的形式。</p>
<p>关于 <code>_prefix</code> 补全器的一个陷阱：你必须确保设置了 <code>COMPLETE_IN_WORD</code> 选项。这可能听起来违反直觉：毕竟，<code>_prefix</code> 强制补全<em>不</em>在单词内部进行。关键是，没有那个选项，补全只在单词的末尾尝试，所以当你在 <code>&lt;prefix&gt;&lt;suffix&gt;</code> 的中间按 <code>&lt;TAB&gt;</code> 时，光标会移动到后缀的末尾，然后补全系统才有机会看到那里有什么，因此整个东西被视为一个前缀，没有后缀。</p>
<p><code>_prefix</code> 还有一个样式：<code>add-space</code>。这使得 <code>_prefix</code> 在补全前缀时添加一个真实的、活生生的空格，而不是仅仅假装那里有一个，从而将补全的单词与原始后缀分开；否则它只会将结果的单词全部连接在一起，就像 <code>expand-or-complete-prefix</code> 通常做的那样。</p>
<p><strong><code>_ignored</code></strong></p>
<p>像 <code>_prefix</code> 一样，这是一个混合体，收拾已经被生成的补全的烂摊子。它允许你拥有已经被 <code>ignored-patterns</code> 样式拒绝的补全。我将在下面描述那个，但它的效果非常简单：对于给定的上下文，你指定的模式列表会与可能的补全进行匹配，任何匹配的都会从列表中移除。<code>_ignored</code> 补全器允许你在你的补全器列表的后面检索那些被移除的补全，以防没有其他东西匹配。</p>
<p>这被 <code>$fignore</code> 机制使用——一个通常不被补全的文件的后缀列表——它实际上是建立在 <code>ignored-patterns</code> 之上的，所以如果你以 zsh 用户熟悉的方式使用它，即如果没有未被忽略的匹配，则显示被忽略的匹配，你需要在你的补全器列表中有 <code>_ignored</code> 补全器。</p>
<p><code>_ignored</code> 的一个稍微烦人的特性是，如果只有一个可能的补全，它会被无条件地插入。这几乎不令人惊讶，但如果你真的不想要那个选择，可能会很烦人。有一个样式 <code>single-ignored</code>，你可以设置为 <code>show</code>——只显示单个被忽略的匹配，不插入——或者 <code>menu</code>——进入菜单补全，这样 TAB 键就会在你由 <code>_ignored</code> 产生的补全和你最初输入的内容之间循环。后者提供了一种非常自然的处理被忽略文件的方式；它有点像在说“嗯，我找到了这个，但你可能不喜欢，所以如果你想回到你之前的内容，再按一次 tab”。</p>
<p>我说这像 <code>_prefix</code>，的确，你可以用完全相同的方式指定为 <code>_ignored</code> 补全器调用的补全器，方法是在上下文 <code>:completion:*:ignored:*</code> 中给出 <code>completer</code> 样式。这意味着我的描述有点过于简化了：<code>_ignored</code> 并不真正使用之前被忽略的补全；相反，当它被调用时，它会生成一个可能性列表，其中由 <code>ignore-patterns</code> 匹配的选择——或者内部使用 <code>$fignore</code>——没有被忽略。所以它真的应该被称为 <code>_not_ignored</code>，但它不是。</p>
<p><strong><code>_match</code></strong></p>
<p>这个和剩下的补全器都是实用工具，当放入补全列表时会影响上面给出的主要补全器，而不是它们自己进行补全。</p>
<p><code>_match</code> 补全器应该出现在 <code>_complete</code> <em>之后</em>；它是 <code>GLOB_COMPLETE</code> 选项的一个更灵活的形式。换句话说，如果 <code>_complete</code> 没有成功，它会尝试将行上的单词作为模式，而不仅仅是固定字符串，与可能的补全进行匹配。为了让它像正常补全一样工作，它通常表现得好像在光标位置插入了一个 <code>*</code>，即使单词已经包含通配符。</p>
<p>你可以用 <code>match-original</code> 样式来控制 <code>*</code> 的添加；如果这个未设置，则发生正常行为。如果它被设置为 <code>only</code>，<code>*</code> 不会被插入，如果它是 <code>true</code>，或者实际上是任何其他字符串，它会先尝试不带 <code>*</code>，然后再带。例如，考虑在使用 <code>_match</code> 补全器的情况下输入 <code>setopt c*ect&lt;TAB&gt;</code>。通常这会产生两个可能性，<code>correct</code> 和 <code>correctall</code>。设置样式后，</p>
<pre><code>  zstyle ':completion::match:*' original only
</code></pre>
<p>在按 <code>TAB</code> 的地方不会插入 <code>*</code>，所以 <code>correct</code> 是唯一可能的匹配。</p>
<p><code>_match</code> 补全器以与 <code>_approximate</code> 完全相同的方式使用 <code>insert-unambiguous</code> 样式。</p>
<p><strong><code>_all_matches</code></strong></p>
<p>这与执行展开而不是补全有类似的效果：所有可能的补全都被插入到命令行上。然而，它使用普通上下文补全的结果来实现这一点。补全系统实现这一点的正常方式是通过影响任何随后被调用的补全器的行为——因此你需要将 <code>_all_matches</code> 放在你希望具有此行为的任何补全器之前的补全器列表中。</p>
<p>你不太可能想对每种类型的补全都这样做，所以有两种方法可以限制其效果。首先，有 <code>avoid-completer</code> 样式：你可以将其设置为一个<em>不</em>插入所有匹配的补全器列表，它们将被正常处理。</p>
<p>然后是 <code>old-matches</code> 样式。这强制 <code>_all_matches</code> 使用一个现有的匹配列表，如果存在的话，而不是这次会生成的。你可以将样式设置为 <code>only</code> 而不是 true；在这种情况下，<code>_all_matches</code> 将永远不会应用于这次会生成的补全，它只会使用任何已经存在的补全列表。</p>
<p>如果应用于正常的补全生成，这可能会很麻烦——通常的列表永远不会被生成，因为 <code>_all_matches</code> 只会插入上次不存在的列表——所以手册推荐了另外两种使用这个补全器和这个样式的方法。首先，你可以给样式的使用添加一个条件：</p>
<pre><code>  zstyle -e ':completion:*' old-matches 'reply=(${NUMERIC:-false})'
</code></pre>
<p>除非有非零的数字参数，否则这返回 false；如果你在补全前在 emacs 模式下输入 <code>&lt;ESC&gt;1</code>，或者在 vi 模式下只输入 <code>1</code>，它将插入由紧接的前一个补全生成的所有值。</p>
<p>否则，你可以单独绑定 <code>_all_matches</code>。这可能更有用；复制手册条目：</p>
<pre><code>  zle -C all-matches complete-word _generic
  bindkey '^Xa' all-matches
  zstyle ':completion:all-matches:*' completer _all_matches
  zstyle ':completion:all-matches:*' old-matches only
</code></pre>
<p>在这里，我们基于 <code>complete-word</code> 小部件生成了一个新的补全，叫做 <code>all-matches</code>——这个名字是任意的，但很方便。我们把它绑定到按键 <code>^Xa</code>，并给它两个普通补全看不到的特殊样式。对于 <code>completer</code>，我们只设置了 <code>_all_matches</code>，对于 <code>old-matches</code>，我们设置了 <code>only</code>；效果是 <code>^Xa</code> 只会插入由上一个补全生成的所有补全，无论那是什么——它不必是普通的上下文补全，它可能是任何补全小部件的结果。</p>
<p><strong><code>_list</code></strong></p>
<p>如果你在补全器列表中有这个（放在开头和任何地方一样好），那么你第一次尝试补全时，你只会得到一个列表；什么也不改变，甚至连一个共同的前缀也不会插入。第二次，补全会像往常一样继续。这就像输入 <code>^D</code>，然后是 tab，但只用一个键。这与通常的 <code>AUTO_LIST</code> 行为不同，因为它完全不考虑补全是否模糊；你总是在第一次得到列表，并且它总是在第二次以通常的方式进行补全。</p>
<p><code>_list</code> 补全器也使用 <code>condition</code> 样式，它的工作方式有点像 <code>_expand</code> 补全器的样式：它必须被设置为对应于“true”的值之一，<code>_list</code> 的延迟行为才会生效。你可以通过在定义样式时使用 <code>zstyle</code> 的 <code>-e</code> 选项来测试 <code>$NUMERIC</code> 的特定值或任何其他条件。</p>
<p>最后，布尔样式 <code>word</code> 也是相关的。如果为 false 或未设置，<code>_list</code> 在决定是否已更改并因此应延迟补全直到下一次按键时，会检查整行。如果为 true，它只检查当前单词。请注意，<code>_list</code> 对那些补全调用之间发生的事情一无所知；查看命令行是它唯一的资源。</p>
<p><strong><code>_menu</code></strong></p>
<p>这只是在 shell 代码中实现菜单补全；它应该在 <code>completers</code> 样式中的“真实”补全生成器之前。它忽略 <code>MENU_COMPLETION</code> 选项和其他相关选项，并且正常的菜单补全小部件与它工作得不好。然而，你可以复制它并编写自己的补全器。</p>
<p><strong><code>_oldlist</code></strong></p>
<p>这个补全器在你习惯于使用特殊的补全函数，即标准补全系统之外的命令时最有用。它能够保留一个旧的补全列表，否则这个列表会被新生成的列表替换。这有两个方面。</p>
<p>首先，列表。假设你尝试从 shell 历史中补全一些东西，使用绑定到 <code>ESC-/</code> 的命令。例如，我输入了 <code>echo ma&lt;ESC-/&gt;</code> 并得到了 <code>max-errors</code>。在这一点上，你可能想列出可能的补全。不幸的是，如果你输入 <code>^D</code>，它只会列出所有通常的上下文补全——对于 <code>echo</code> 命令，它没有被特殊处理，这些只是文件。所以它不起作用。通过将 <code>_oldlist</code> 补全器放入 <code>completers</code> 样式中，<em>在</em> <code>_complete</code> 之前，它就起作用了，因为旧的匹配列表被保留下来供 <code>^D</code> 使用。</p>
<p>在这种情况下，你可以通过将 <code>old-list</code> 样式设置为 <code>always</code> 或 <code>never</code> 来强制打开或关闭旧列表；通常它会显示当前补全集的列表，如果那个还没有显示的话，否则它会生成标准的列表。你甚至可以将 <code>old-list</code> 的值设置为一个补全器列表，这些补全器将总是以这种方式保留它们的列表。</p>
<p><code>_oldlist</code> 有用的另一个地方是在菜单补全中，那里会发生完全相同的问题：如果你从一个特殊的命令生成一个菜单，然后尝试通过按 tab 来循环，补全会寻找正常的上下文匹配。这次有一个解决方法——重复使用特殊的命令键而不是 tab。对于多个键序列，这相当繁琐。同样，<code>_oldlist</code> 解决了这个问题，你同样可以用一个样式 <code>old-menu</code> 来控制行为，它接受一个布尔值（默认是打开的）。正如奥威尔所说，oldlisters unbellyfeel menucomp。</p>
<p><strong>排序补全器</strong></p>
<p>我给出了关于补全器应该按什么顺序出现的各种建议，这可能会令人困惑。因此，这里是一个建议的顺序；只需省略你不想使用的任何补全器：</p>
<pre><code>  _all_matches _list _oldlist _menu _expand _complete _match
    _ignored _correct _approximate _prefix 
</code></pre>
<p>其他顺序当然是可能的，甚至可能有用：例如，<code>_all_matches</code> 补全器适用于所有不在 <code>avoid-completer</code> 样式中列出的后续补全器，所以你可能有充分的理由将它移到列表的更后面。</p>
<p>这是我上面提到的补全器标签的例子，即补全器可以用不同的名称来查找。</p>
<pre><code>  zstyle ':completion:*' completer _approximate:-one   _complete:-extended _approximate:-four
  zstyle ':completion:*:approximate-one:*' max-errors 1
  zstyle ':completion:*:complete-extended:*'   matcher 'r:|[.,_-]=* r:|=*'
  zstyle ':completion:*:approximate-four:*' max-errors 4
</code></pre>
<p>这按顺序尝试以下内容。</p>
<ol>
<li>
<p>普通的、无修饰的补全。</p>
</li>
<li>
<p>带一个错误的近似，由第二个样式给出。</p>
</li>
<li>
<p>带扩展补全的普通补全，由第三个样式给出。抱歉，在我谈论 <code>matcher</code> 样式之前，这将是一个黑匣子；现在，你只能相信我的话，这个样式允许方括号中的字符前面有一个通配符，所以 <code>a-b</code> 可以补全为 <code>able-baker</code>，等等。</p>
</li>
<li>
<p>最多带四个错误的近似，由最后一个样式给出。</p>
</li>
</ol>
<p>这里有一个相当虚假的例子。你有一个包含以下内容的目录：</p>
<pre><code>  foobar  fortified-badger  frightfully-barbaric
</code></pre>
<p>实际上，它一点也不虚假，因为我刚刚创建了一个。首先试试 <code>echo foo&lt;TAB&gt;</code>；不出所料，你得到 <code>foobar</code>。现在在 <code>echo</code> 之后尝试用 <code>fo-b&lt;TAB&gt;</code> 补全：基本补全失败，它到达 <code>_approximate:-one</code> 并发现它允许一个错误，所以再次接受补全 <code>foobar</code>。现在试试 <code>fort-ba&lt;TAB&gt;</code>。这次直到第三个补全才起作用，它有效地允许它匹配 <code>fort*-ba*&lt;TAB&gt;</code>，所以你看到 <code>fortified-badger</code>（不，我自己也没见过，但你知道，它们是夜行动物）。最后，试试 <code>fortfully-ba&lt;TAB&gt;</code>；最后一个条目，允许最多四个错误，体贴地将 <code>or</code> 纠正为 <code>righ</code>，你得到 <code>frightfully-barbaric</code>。好吧，这个例子有点精神错乱，但我想你可以看到这些功能是有用的。如果这让你感觉好一点，我花了四五次尝试才把这些样式搞对。</p>
<p>[]{#l158}</p>
<h3 id="652-改变列表的格式分组等"><a class="header" href="#652-改变列表的格式分组等">6.5.2: 改变列表的格式：分组等。</a></h3>
<p><strong><code>format</code></strong></p>
<p>如果你想知道补全列表中的补全来自哪里，你可以使用这个样式。最基本的用法是为任何补全上下文中的 <code>descriptions</code> 标签设置它。它接受一个字符串值，其中应出现 <code>%d</code>；这将被替换为正在补全的内容的描述。例如，我使用：</p>
<pre><code>  zstyle ':completion:*:descriptions' format 'Completing %d'
</code></pre>
<p>如果我输入 <code>cd^D</code>，我会看到一个像这样的列表（直到我定义了 <code>group-name</code> 样式）：</p>
<pre><code>  Completing external command
  Completing builtin command
  Completing shell function
  cd                cddbsubmit        cdp               cdrecord
  cdctrl            cdecl             cdparanoia        cdswap
  cdda2wav          cdmatch           cdparanoia-yaf
  cddaslave         cdmatch.newer     cdplay
  cddbslave         cdot              cdplayer_applet
</code></pre>
<p>顶部的描述与标签名称相关——通常有一一对应的关系——但形式更易读；要获取标签名称，你需要使用 <code>^Xh</code>。毫无疑问，你会看到一些不同的东西，但重点是列出的补全是外部命令（例如 <code>cdplay</code>）、内建命令（<code>cd</code>）和 shell 函数（<code>cdmatch</code>，恰好是旧式补全的遗留物，显示了我多久清理一次我的函数目录）的混合体，知道你拥有什么通常很方便。</p>
<p>你可以在描述中使用一些提示符转义，特别是那些打开或关闭突出显示模式（<code>%S</code>、<code>%s</code>）、粗体文本（<code>%B</code>、<code>%b</code>）和下划线文本（<code>%U</code>、<code>%u</code>）的，以使描述从补全列表中脱颖而出。</p>
<p>你可以为除 <code>descriptions</code> 之外的某个标签设置这个，这样定义的格式将只用于该标签的补全。</p>
<p><strong><code>group-name</code>, <code>group-order</code></strong></p>
<p>在上面的 <code>format</code> 例子中，你可能想知道是否可以让不同类型的补全分开显示，并附上描述。你可以使用<em>分组</em>来做到这一点。它们也与标签相关，尽管你可以通过 <code>group-name</code> 样式定义组名，所以可以为任何上下文中的补全给出不同的名称。然而，最开始最简单的是将样式的值给一个空字符串，这意味着组名就是标签的名称。换句话说，</p>
<pre><code>  zstyle ':completion:*' group-name ''
</code></pre>
<p>为每个标签分配一个不同的组名。稍后，如果你决定希望各种标签具有相同的组名，你可以用更具体的模式来微调这个。如果没有定义组名，使用的组被称为 <code>-default-</code>，所以这就是在你发出上面的 <code>zstyle</code> 命令之前发生的情况；所有匹配都在那个组里。</p>
<p>分组的原因是：同一组中的匹配项一起显示，不同组中的匹配项分开显示。所以上一个例子中的补全列表，在设置了 <code>format</code> 和 <code>group-name</code> 样式后，变成：</p>
<pre><code>  Completing external command
  cdctrl            cddbsubmit        cdparanoia        cdrecord
  cdda2wav          cdecl             cdparanoia-yaf
  cddaslave         cdot              cdplay
  cddbslave         cdp               cdplayer_applet
  Completing builtin command
  cd
  Completing shell function
  cdmatch                 cdmatch.newer           cdswap
</code></pre>
<p>你可能会觉得这更有帮助，或者更乱，这取决于我无法控制的深层心理因素。</p>
<p>如果（且仅当）你正在使用 <code>group-name</code>，你也可以使用 <code>group-order</code>。顾名思义，它决定了不同补全组的显示顺序。它有点像 <code>tag-order</code>，我在第一次介绍标签时描述过：值只是一组组的名称，按你希望看到的顺序排列。手册中的例子与我刚刚展示的列表相关：</p>
<pre><code>  zstyle ':completion:*:-command-' group-order   builtins functions commands
</code></pre>
<p>——记住，当补全命令的名称而不是它们的参数时，会使用 <code>-command-</code> 上下文。毫不奇怪，那个列表现在变成：</p>
<pre><code>  Completing builtin command
  cd
  Completing shell function
  cdmatch                 cdmatch.newer           cdswap
  Completing external command
  cdctrl            cddbsubmit        cdparanoia        cdrecord
  cdda2wav          cdecl             cdparanoia-yaf
  cddaslave         cdot              cdplay
  cddbslave         cdp               cdplayer_applet
</code></pre>
<p>如果你用 <code>^Xh</code> 调查可用的标签，你会看到还有其他的，比如别名，我们没有定义它们的顺序。这些会出现在你定义了顺序的那些之后，并以生成匹配的函数决定的某种顺序出现。</p>
<p><strong><code>tag-order</code></strong></p>
<p>正如我已经说过的，我已经描述过这个了，但为了完整起见，这里再次提及。</p>
<p><strong><code>verbose</code>, <code>auto-description</code></strong></p>
<p>这些是 <code>format</code> 的亲戚，因为它们向列表中添加有用的消息。如果 <code>verbose</code> 为 true，生成匹配的函数可以自行决定显示更多关于它们的信息。最常见的情况是描述选项时；处理大量选项描述的标准函数 <code>_describe</code> 会测试 <code>verbose</code> 样式，并将打印有关它正在补全的选项的信息。</p>
<p>你也可以设置字符串样式 <code>auto-description</code>；它对于选项也很有用，在它们没有特殊描述，但确实有一个紧随其后的单个参数，补全已经知道的情况下。然后，用于详细打印的参数的描述将作为 <code>%d</code> 在 <code>auto-describe</code> 中可用，所以像手册推荐的 <code>specify: %d</code> 这样的东西将记录选项本身。所以如果一个命令接受 <code>-o &lt;output-file&gt;</code> 并且参数有描述 <code>output file</code>，那么 <code>-o</code>，当它作为可能的补全出现时，如果没有自己的描述，将有描述 <code>specify: output file</code>。事实上，大多数被标准补全函数识别的选项已经提供了自己的描述，这比大多数人可能需要的要微妙得多。</p>
<p><strong><code>list-colors</code></strong></p>
<p>这用于根据文件类型以不同颜色显示文件匹配列表。它基于 GNU 版本 <code>ls</code> 使用的 <code>$LS_COLORS</code> 环境变量的语法。你需要一个能够显示颜色的终端，比如彩色 xterm，并且应该确保加载了 <code>zsh/complist</code> 库（如果你使用 <code>menu</code> 样式设置的菜单选择，或者如果你使用这个样式，它应该会自动加载）。但你可以明确地确保：</p>
<pre><code>  zmodload -i zsh/complist
</code></pre>
<p><code>-i</code> 会在模块已经加载时保持安静。要安装一套标准的默认颜色，你可以使用：</p>
<pre><code>  zstyle ':completion:*' list-colors ''
</code></pre>
<p>——注意使用了 <code>default</code> 标签——因为空字符串将值设置为默认值。</p>
<p>如果那对你还不够好，这里有一些更详细的说明。参数 <code>$ZLS_COLORS</code> 是 <code>zsh/complist</code> 使用的系统的最低层部分。有一个简单的内置默认值，而将样式设置为空字符串等同于：</p>
<pre><code>  ZLS_COLORS="no=00:fi=00:di=01;34:ln=01;36:  pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:  ex=01;32:lc=\e[:rm=m:tc=00:sp=00:ma=07:hi=00:du=00
</code></pre>
<p>它的格式与 <code>$LS_COLORS</code> 基本相同，实际上你可以通过使用 <code>ls</code> 附带的 <code>dircolors</code> 命令来获得更有用的值集：</p>
<pre><code>  ZLS_COLORS="no=00:fi=00:di=01;34:ln=01;36:  pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:  or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:  *.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:  *.z=01;31:*.Z=01;31:*.gz=01;31:*.deb=01;31:  *.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:  *.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:  *.mpg=01;37:*.avi=01;37:*.gl=01;37:*.dl=01;37:"
</code></pre>
<p>你应该查看 <code>zsh/complist</code> 模块的手册以获取详细信息，但请特别注意添加了 <code>ma</code> 类型，它指定了菜单选择中当前匹配的显示方式。其默认值是使用突出显示模式——与提示中的序列 <code>%S</code> 效果相同，你可以用 <code>print -P %Sfoo</code> 显示。</p>
<p>然而，你需要直接定义样式，因为补全总是使用它来设置 <code>$ZLS_COLORS</code>；否则它不知道它找到的值是来自用户还是来自某个样式的先前值。那采用这种格式：</p>
<pre><code>  zstyle ':completion:*' list-colors "no=00" "fi=00" ...
</code></pre>
<p>你可以使用一个已经定义的 <code>$LS_COLORS</code>：</p>
<pre><code>  zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
</code></pre>
<p>（它将参数按冒号分割成一个数组）因为 <code>$LS_COLORS</code> 对于 <code>ls</code> 仍然有用，即使直接设置 <code>$ZLS_COLORS</code> 没有价值。这应该意味着 GNU ls 和 zsh 产生看起来相似的列表。</p>
<p>允许一些特殊效果。你可以使用模式来告诉文件名如何匹配：实际上，这是默认行为的一部分，例如 '<code>*.tar=01;31</code>' 强制 tar 文件为红色。在这种情况下，你仅限于 <code>*</code> 后跟一个字符串。然而，有一种方法可以为任何匹配指定颜色，而不仅仅是文件，以及任何模式：使用 <code>=&lt;pat&gt;=&lt;col&gt;</code>。这里有两种让 <code>kill</code> 的进程列表中的作业变红的方法。</p>
<pre><code>  zstyle ':completion:*:*:kill:*' list-colors '=%*=01;31'
</code></pre>
<p>这使用了刚刚描述的方法；作业以 <code>%</code> 开头。</p>
<pre><code>  zstyle ':completion:*:*:kill:*:jobs' list-colors 'no=01;31'
</code></pre>
<p>这使用标签，而不是模式，来匹配作业行。它有各种优点。因为你正在使用标签，所以为所有使用作业的命令改变这个要容易得多，而不仅仅是 kill——只需从字符串中去掉 <code>kill</code>。用另一种方法那是不切实际的，因为它会匹配太多你不想匹配的其他东西。你也不依赖于使用特定的模式。最后，如果你用 <code>format</code> 描述来尝试它，你会看到那也得到了颜色，因为它匹配了正确的标签。注意使用 <code>no</code> 来指定这适用于正常匹配；其他用于文件类型的两个字母代码在这里没有用。</p>
<p>然而，对于通用模式形式，你还可以使用一个更特殊的效果。通过在模式内部用 <code>(#b)</code> 打开“反向引用”，括号就变得活跃，它们匹配的部分可以被单独着色。你通过扩展颜色列表来做到这一点，每个代码前面都有一个 <code>=</code> 符号，额外的元素将用于为括号匹配的内容着色。这里是 <code>kill</code> 的另一个例子，它将进程号变成红色，但其余部分保持不变。</p>
<pre><code>  zstyle ':completion:*:*:kill:*:processes' list-colors   '=(#b) #([0-9]#)*=0=01;31'
</code></pre>
<p>这些象形文字是扩展的 glob 模式。你应该注意，<code>EXTENDED_GLOB</code> 选项在样式内部总是打开的——这是 <code>#b</code> 生效所必需的。特别是，<code>#</code> 意味着“前一个模式部分重复零次或多次”，带有扩展的 glob 模式；有关完整细节，请参阅 globbing 手册页。</p>
<p><strong><code>ignored-patterns</code></strong></p>
<p>许多 shell，包括 zsh，都有一个参数 <code>$fignore</code>，它给出一个后缀列表；以这些后缀结尾的文件名通常不用于补全。一个典型的值是：</p>
<pre><code>  fignore=(.o ~ .dvi)
</code></pre>
<p>所以正常的文件补全不会产生对象文件、EMACS 备份文件或 TeX DVI 文件。</p>
<p><code>ignored-patterns</code> 样式是这个的扩展。它接受一个数组值，像 <code>fignore</code> 一样，但有各种不同之处。首先，这些值是应该匹配<em>整个</em>要补全的值的模式，包括前缀（例如文件名的目录部分）和后缀。其次，它们适用于<em>所有</em>补全，而不仅仅是文件，因为你可以使用样式机制来调整它以适用于你想要的任何地方，直到特定的标签。</p>
<p>因此，你可以用以下内容替换上面 <code>$fignore</code> 的用法：</p>
<pre><code>  zstyle ':completion:*:files' ignored-patterns '*?.o' '*?~' '*?.dvi'
</code></pre>
<p>用于标签 <code>files</code> 正在使用的补全上下文。额外的 <code>?</code> 是因为 <code>$fignore</code> 小心地只应用于真正的后缀，即前面有东西的字符串，而 <code>?</code> 强制至少有一个字符存在。</p>
<p>实际上，这与 <code>$fignore</code> 不完全相同，因为除了 <code>files</code> 之外还有其他文件标签；除了你已经见过的目录标签，还有 <code>globbed-files</code> 和 <code>all-files</code>。前者用于补全函数指定了模式的情况，例如 <code>*.dvi</code> 用于 <code>dvips</code> 命令名之后的文件。这些不使用这个样式，因为模式已经被充分指定了。这遵循了旧补全系统中 <code>$fignore</code> 的行为。另一个轻微的区别是，正如我上面在讨论 <code>_ignored</code> 补全器时所说，你可以选择是否希望在正常补全失败时看到那些被忽略的文件，方法是在补全器列表中有 <code>_ignored</code>。</p>
<p>另一个标签，<code>all-files</code>，在 <code>globbed-files</code> 标签失败时应用，并表示在这种情况下任何旧文件都足够好；你可以用 <code>tag-order</code> 样式来安排这如何发生。在这个例子中，</p>
<pre><code>  zstyle ':completion:*:*:dvips:argument*'   tag-order globbed-files all-files
</code></pre>
<p>足以说明，如果模式没有产生任何文件，即目录中没有 <code>*.dvi</code> 文件，你希望看到所有文件。最后这个漫谈的要点是：由于 <code>all-files</code> 标签与 <code>files</code> 标签是分开的，在这种情况下，你真的会看到所有文件（除了像往常一样以 <code>.</code> 开头的文件）。你可能会发现这很有用，但你可以很容易地让 <code>all-files</code> 标签的行为与 <code>files</code> 相同：</p>
<pre><code>  zstyle ':completion:*:(all-|)files' ignored-patterns ...</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide06.html">上一章</a></li>
<li><a href="zshguide08.html">下一章</a></li>
</ul>
<hr />
<p>[]{#ragbag}[]{#l192}</p>
<h1 id="第七章模块及其他零碎-未编写"><a class="header" href="#第七章模块及其他零碎-未编写">第七章：模块及其他零碎 <em>未编写</em></a></h1>
<p>[]{#l193}</p>
<h2 id="71-模块控制zmodload-1"><a class="header" href="#71-模块控制zmodload-1">7.1: 模块控制：<code>zmodload</code></a></h2>
<p>[]{#l194}</p>
<h3 id="711-定义参数的模块"><a class="header" href="#711-定义参数的模块">7.1.1: 定义参数的模块</a></h3>
<p>[]{#l195}</p>
<h3 id="712-底层系统交互"><a class="header" href="#712-底层系统交互">7.1.2: 底层系统交互</a></h3>
<p>[]{#l196}</p>
<h3 id="713-zftp"><a class="header" href="#713-zftp">7.1.3: ZFTP</a></h3>
<p>[]{#l197}</p>
<h2 id="72-贡献部分-1"><a class="header" href="#72-贡献部分-1">7.2: 贡献部分</a></h2>
<p>[]{#l198}</p>
<h3 id="721-提示符主题"><a class="header" href="#721-提示符主题">7.2.1: 提示符主题</a></h3>
<p>[]{#l199}</p>
<h2 id="73-41-版本的新功能-1"><a class="header" href="#73-41-版本的新功能-1">7.3: 4.1 版本的新功能</a></h2>
<hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide06.html">上一章</a></li>
<li><a href="zshguide08.html">下一章</a></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide07.html">上一章</a></li>
</ul>
<hr />
<p>[]{#l200}</p>
<h1 id="附录-1获取-zsh-和更多信息-未编写"><a class="header" href="#附录-1获取-zsh-和更多信息-未编写">附录 1：获取 zsh 和更多信息 <em>未编写</em></a></h1>
<p>[]{#appa}</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
