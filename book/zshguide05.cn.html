<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter5</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<ul>
<li><a href="zshguide.html">目录</a></li>
<li><a href="zshguide04.html">上一章</a></li>
<li><a href="zshguide06.html">下一章</a></li>
</ul>
<hr />
<p>[]{#subst}[]{#l111}</p>
<h1 id="第五章替换"><a class="header" href="#第五章替换">第五章：替换</a></h1>
<p>本章首先会吸引那些对以下事实感到兴奋的人：</p>
<pre><code>  print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}
</code></pre>
<p>打印出数组 <code>$array</code> 中最长的元素。然而，对于构成其余人口的绝大多数人来说，在我们达到那个阶段之前，应该有很多有用的东西。无论如何，应该立即明白为什么没有混淆 zsh 代码竞赛。</p>
<p>对于那些不经常编写函数，大部分时间都在 shell 提示符下度过的人来说，本章最有用的部分可能是在本章末尾关于文件名生成（即通配）的部分。这将教你如何在为命令选择文件时避免浪费时间在 <code>find</code> 之类的事情上。</p>
<p>[]{#l112}</p>
<h2 id="51-引用"><a class="header" href="#51-引用">5.1: 引用</a></h2>
<p>我在本指南中一直使用某种形式的引用，但我从未深入细节。现在是时候了，因为使用引用是控制 shell 各种替换效果的重要部分。以下是基本的引用类型。</p>
<p>[]{#l113}</p>
<h3 id="511-反斜杠"><a class="header" href="#511-反斜杠">5.1.1: 反斜杠</a></h3>
<p>关于反斜杠，主要要说明的是它们其实很简单。你可以用反斜杠引用任何字符，即使它在未被引用时没有任何意义；所以如果情况最糟，你可以取任何旧字符串，无论它里面有什么——随机的引号、反斜杠、不可打印的字符——用反斜杠引用每个字符，shell 就会把它当作一个普通字符串：</p>
<pre><code>  print \T\h\i\s\ \i\s\ \*\p\o\i\n\t\l\e\s\s\*\ \ 
      \-\ \b\u\t\ \v\a\l\i\d\!
</code></pre>
<p>还要记住，这意味着你需要额外的一层引用来向 <code>print</code> 传递一个 <code>\n</code> 或其他什么。</p>
<p>然而，zsh 有一个更简单的方法来确保在需要时所有东西都用反斜杠引用。这是一种特殊的参数替换形式，只是你可以通过在括号中提供标志来做的众多技巧之一：</p>
<pre><code>  % read string
  This is a *string* with various `special' characters
  % print -r -- ${(q)string}
  This\ is\ a\ \*string\*\ with\ various\ \`special\'\ characters
</code></pre>
<p><code>read</code> 内建命令对你输入的内容没有做任何处理，所以 <code>$string</code> 只包含那些字符。<code>print</code> 的 <code>-r</code> 标志告诉它以原始方式打印后面的内容，这里是特殊部分：<code>${(q)string}</code> 告诉 shell 在需要时用反斜杠输出参数，以防止特殊字符被解释。所有参数标志都是 zsh 特有的；没有其他 shell 有它们。</p>
<p>这个标志在那里不是很有用，因为 zsh 通常（还记得 <code>GLOB_SUBST</code> 选项吗？）无论如何都不会对来自替换的字符做任何特殊处理。它<em>极其</em>有用的地方是，如果你要重新评估替换中的文本，但仍然希望它被当作一个普通字符串。所以在上面之后，</p>
<pre><code>  % eval print -r -- ${(q)string}
  This is a *string* with various `special' characters
</code></pre>
<p>你会得到你开始时的内容，因为在命令行的 <code>eval</code> 时，由 <code>(q)</code> 标志放入的反斜杠意味着该值被当作一个普通字符串。</p>
<p>你也可以去掉参数中的引号；标志 <code>(Q)</code> 可以做到这一点。它不关心是使用反斜杠还是单引号或双引号，它都以 shell 解析器的方式处理它们。只有当参数的值中不知何故包含了引号时，你才需要这个。这种情况发生的一种方式是，如果你尝试读取一个包含 shell 命令的文件，为此还有另一个技巧：<code>(z)</code> 标志将一行分割成一个数组，就像该行被读入并（比如说）被赋给一个数组一样。这里有一个例子：</p>
<pre><code>  % cat file
  print 'a quoted string' and\ another\ argument
  % read -r line &lt;file
  % for word in ${(z)line}; do
  for&gt; print -r "quoted:    $word"
  for&gt; print -r "unquoted:  ${(Q)word}"
  for&gt; done
  quoted:    print
  unquoted:  print
  quoted:    'a quoted string'
  unquoted:  a quoted string
  quoted:    and\ another\ argument
  unquoted:  and another argument
</code></pre>
<p>You会注意到 <code>(z)</code> 没有从读入的单词中移除任何引号，但 <code>(Q)</code> 标志做到了。注意 <code>read</code> 和 <code>print</code> 的 <code>-r</code> 标志：第一个防止反斜杠被 <code>read</code> 吸收，第二个防止它们被 <code>print</code> 吸收。恐怕反斜杠有点麻烦。</p>
<p>[]{#l114}</p>
<h3 id="512-单引号"><a class="header" href="#512-单引号">5.1.2: 单引号</a></h3>
<p>你唯一不能用单引号引用的东西是另一个单引号。然而，有一个选项 <code>RC_QUOTES</code>，在单引号字符串中的两个单引号会变成一个。显然 <code>RC</code> 指的是 plan9 中出现的 shell <code>rc</code>；它似乎是那种有些人会狂热地投入其中，而我们其他人却搞不懂为什么的程序之一。Zsh 用户可能会同情。（在我错误地猜测 <code>RC</code> 代表递归之后，Oliver Kiddle 和 Bart Schaefer 纠正了这一点，尽管你仍然可以那样想。然而，对于 <code>RC_EXPAND_PARAM</code> 来说，这确实行不通，它肯定来自 <code>rc</code> shell，如果你看源代码，你会发现一个名为 <code>plan9</code> 的变量，用于测试该选项是否生效。）</p>
<p>You可能还记得 BASIC 中的类似东西，尽管在那种情况下是双引号——在 zsh 中，出于某种原因，它只适用于单引号。所以，</p>
<pre><code>  print -r 'A ''quoted'' string'
</code></pre>
<p>通常会给你输出 <code>A quoted string</code>，但设置了该选项后，它会打印 <code>A 'quoted' string</code>。<code>print</code> 的 <code>-r</code> 选项在这里什么也没做，只是为了表明我没有隐藏任何东西。这通常是一个有用且无害的选项，因为在引号内有两个引号在一起没有其他好理由。</p>
<p>引用单引号的标准方法是结束引用，插入一个反斜杠转义的单引号，然后重新开始引用：</p>
<pre><code>  print -r 'A '\''quoted'\'' string'
</code></pre>
<p>这不受选项设置的影响，因为反斜杠紧随其后的引号总是被视为一个普通的、可打印的字符。你<em>永远不能</em>做的是用反斜杠作为在单引号内引用字符的方式；它们在那里只被当作普通字符。</p>
<p>你可以通过将 <code>q</code> 加倍来强制参数标志生成用单引号引用的字符串，而不是反斜杠：<code>${(qq)param}</code> 而不是 <code>${(q)param}</code>。这主要用于如果你知道字符串中有很多特殊字符，结果会更短，而且对于人类来说也比机器更容易阅读，但通常它比其他形式没有任何优势。它可以判断你是否设置了 <code>RC_QUOTES</code> 并使用它来使字符串更短，所以如果你可能在没有设置该选项的地方使用结果字符串，要小心。</p>
<p>[]{#l115}</p>
<h3 id="513-posix-引号"><a class="header" href="#513-posix-引号">5.1.3: POSIX 引号</a></h3>
<p>有一种单引号的亲戚，它使用语法 <code>$'</code> 来引入一个带引号的字符串，并用 <code>'</code> 来结束它；我称之为“POSIX 引号”，因为它们出现在 POSIX 标准中，我不知道还能叫它们什么；“字符串引号”是一种可能性，但听起来有点模糊（你还会引用什么呢？）。与单引号的区别在于，它们理解与 print 内建命令相同的反斜杠序列。因此，你可以方便地使用 <code>\n</code> 表示换行，<code>\e</code> 表示转义，<code>\xFF</code> 表示十六进制的任意字符，等等，对于任何命令：</p>
<pre><code>  % cat &lt;&lt;&lt;$'Line\tone\nLine\ttwo'
  Line    one
  Line    two
</code></pre>
<p>记住“here string”表示法 <code>&lt;&lt;&lt;</code>，它为命令提供标准输入。因此，输出准确地显示了带引号的字符串是如何被解释的。它与</p>
<pre><code>  % print 'Line\tone\n\Line\ttwo'
  Line    one
  Line    two
</code></pre>
<p>相同，但在那里解释是在 <code>print</code> 内部完成的，这并不总是方便。POSIX 引号目前使用得相当少。</p>
<p>这是提及 shell 完全是“八位干净”的最好时机，这意味着你可以在你的字符串中的任何地方拥有 256 个可能的字符中的任何一个。例如，<code>$'foo\000bar'</code> 中有一个嵌入的 ASCII NUL（那不是印刷错误——官方地，ASCII 非打印字符有两或三个字母的缩写）。通常这会终止一个字符串，但当你在内部使用它时，shell 会绕过这个问题；然而，当你尝试将其作为参数传递给外部程序时，一切都无法保证了。几乎可以肯定，在那种情况下，第一个 NUL 会导致程序认为字符串已经结束，因为没有关于参数长度的信息被传递下去，shell 也无能为力。因此，例如：</p>
<pre><code>  % echo $'foo\000bar'
  foobar
  % /bin/echo $'foo\000bar'
  foo
</code></pre>
<p>shell 的 <code>echo</code> 知道 shell 的 8 位约定，并打印出 NUL，终端不显示，然后是字符串的其余部分。外部版本的 <code>echo</code> 在到达 NUL 时除了停止之外别无他法。</p>
<p>嵌入的 NUL 实际上有用途：例如，某些版本的 <code>find</code> 和 <code>xargs</code> 会在其输入和输出的各个部分之间放置或接受 NUL 而不是换行符（与命令行参数不同），如果输入或输出有可能包含一个活动的换行符，这会安全得多。使用 <code>$'\000'</code> 允许 shell 非常舒适地与这些配合。如果你想尝试这个，相应的选项是 <code>find</code> 的 <code>-print0</code>（用 NUL 终止符而不是换行符打印）和 <code>xargs</code> 的 <code>-0</code>（假设 NUL 终止符读取输入）。</p>
<p>在旧版本的 shell 中，最高位被设置的字符，例如在 ISO 8859 字体中找到的非英语字符集中的字符，可能会导致问题，因为 shell 内部也使用这些字符来表示自己的特殊字符，但最近版本的 shell（从大约 3.0 开始）以与 NUL 相同的方式回避了这个问题。任何遗留的问题——要完全一致地处理这个问题相当棘手——都是 bug，应该被报告。</p>
<p>你可以通过一种相当荒谬的方式，即让引号标志中的 <code>q</code> 总共出现四次，来强制参数用 POSIX 引号引用。我想不出你为什么会想这样做，除非它会将换行符变成 <code>\n</code>，因此结果将适合单行（可能相当长）。另外，你还可以用转义序列替换特殊字符。</p>
<p>[]{#l116}</p>
<h3 id="514-双引号"><a class="header" href="#514-双引号">5.1.4: 双引号</a></h3>
<p>双引号允许内部进行某些，但不是所有形式的替换。更具体地说，它们允许参数展开、命令替换和算术替换，但不允许任何其他形式：进程替换不会发生，花括号和初始的波浪号和等号不会被展开，模式也不是特殊的。这里有一个表格；左边的每个表达式都是某个命令行参数，结果显示了如果它出现在引号外或双引号内被替换的内容。</p>
<pre><code>  表达式      引号外          双引号内
  ------------------------------------------------
  =(echo hi mum)  /tmp/zshTiqpL     =(echo hi mum)
  $ZSH_VERSION    4.0.1             4.0.1
  $(echo hi mum)  hi mum            hi mum
  $((6**2 + 6))   42                42
  {a,b}cd         acd bcd           {a,b}cd
  ~/foo           /home/pws/foo     ~/foo
  .zl*            .zlogin .zlogout  .zl*
</code></pre>
<p>那个 <code>/tmp/zshTiqpL</code> 可以是任何临时文件名，而且确实，其他一些替换在你的情况下也会有所不同。</p>
<p>You可能已经猜到 <code>${(qqq)string}</code> 会强制 <code>$string</code> 使用双引号来引用其特殊字符。与其他形式一样，这一切都得到了妥善处理——shell 知道哪些字符在双引号内需要引用，哪些不需要。</p>
<p><strong>双引号中的分词</strong>\</p>
<p>在允许替换的地方，双引号的（几乎）不变的副作用是分词被抑制了。你可以使用 <code>print -l</code> 来看到这一点，它每行打印一个参数：</p>
<pre><code>  % array=(one two)
  % print -l $(echo foo bar) $array
  foo
  bar
  one
  two
  % print -l "$(echo foo bar) $array"
  foo bar one two
</code></pre>
<p>这之所以是“几乎”不变，是因为参数替换允许你指定将进行正常的分词。有两种方法可以做到这一点；都使用符号 <code>@</code>。你可能从参数 <code>$@</code> 中记得这个，当它出现在双引号中时就有这种效果：脚本或函数的参数被分割成单词，就像一个普通的数组一样，只是空参数不会被移除。我在<a href="zshguide03.html#syntax">第三章</a>中详细地讲过这个。</p>
<p>这对于其他参数也以以下方式扩展：</p>
<pre><code>  % array=(one two three)
  % print -l "${array[@]}"
  one
  two
  three
</code></pre>
<p>更普遍地，对于所有形式的替换，使用另一个标志 <code>(@)</code>：</p>
<pre><code>  % print -l "${(@)array}"
  one
  two
  three
</code></pre>
<p><strong>关于下标的题外话</strong>\</p>
<p>带标志的版本可能不如另一个清晰，但它可以出现在很多不同的地方。例如，这里是如何在 zsh 中选取一个数组的切片：</p>
<pre><code>  % print -l ${array[2,-1]}
  two
  three
</code></pre>
<p>其中负数从数组的末尾开始计数。方括号中的数字被称为下标。这也可以得到 <code>(@)</code> 的处理：</p>
<pre><code>  % print -l "${(@)array[2,-1]}"
  two
  three
</code></pre>
<p>虽然可能不明显，但在这种情况下你可以使用另一种表示法：</p>
<pre><code>  % print -l "${array[@][2,-1]}"
  two
  three
</code></pre>
<p>shell 实际上可以处理参数替换中任意数量的下标，而不仅仅是一个；每个都应用于前一个的结果：</p>
<pre><code>  % print -l "${array[@][2,-1][1]}"
  two
</code></pre>
<p>你必须注意的是，最后一个下标选择了一个单词。你可以继续应用下标，但它们将只应用于该单词中的<em>字符</em>，而不是数组元素：</p>
<pre><code>  % print -l "${array[@][2,1][1][2,-1]}"
  wo
</code></pre>
<p>我们现在严重偏离了主题：下标当然会完全独立于单词是否被分割或出现在双引号中而工作。尽管在双引号中会发生单词的连接，但数组的下标仍然选择数组元素。这是参数展开规则应用顺序的结果。在 <code>zshexpn</code> 手册条目中有一个关于这个的冗长、复杂的部分（在那里查找标题“Rules”或在相应的 Info 或 HTML 文件的“Parameter Expansion”节点中查找）。</p>
<p><strong>带引号的命令替换的分词</strong>\</p>
<p>Zsh 有一个有用的特性，你可以强制 shell 将参数展开的规则应用于命令替换的结果。要看这在哪里可能有用，考虑特殊“命令替换”（尽管它完全在 shell 中处理，而不是通过运行外部命令）的情况，它将文件的内容放在命令行上：</p>
<pre><code>  % args() { print $#; }    # 报告参数数量
  % cat file
  Words on line one
  Words on line two
  % args $(&lt;file)
  8
  % args "$(&lt;file)"
  1
</code></pre>
<p>未引用的替换将文件分割成单个单词；引用的替换根本没有分割它。这些是标准的 shell 规则。</p>
<p>然而，很常见的情况是，你想要每行一个参数，而不是在行内按空格分割。这就是参数展开可以派上用场的地方。有一个标志 <code>(f)</code>，它表示“分割展开的结果，每行一个单词”。这里是如何在这种情况下使用它：</p>
<pre><code>  % args "${(f)$(&lt;file)}"
  2
</code></pre>
<p>在你通常会放参数名的地方，你放了命令替换，shell 会对那个的结果进行操作（注意它不会将结果视为参数名，而是视为一个值——这在下面会更详细地讨论）。双引号是必需的，因为否则文件在参数替换看到结果之前就已经被分割成单个单词了。你可以很容易地验证这两个参数是文件的各个行。我不记得 <code>f</code> 代表什么，但当它出现时，我们已经很快地用完了标志代码；Bart Schaefer 认为它代表“fold”，这至少可能帮助你记住它。</p>
<p>[]{#l117}</p>
<h3 id="515-反引号"><a class="header" href="#515-反引号">5.1.5: 反引号</a></h3>
<p>关于反引号，主要要说的是你应该使用另一种形式的命令替换。有两个好理由。</p>
<p>首先，另一种形式可以嵌套：</p>
<pre><code>  % print $(print $(print a word))
  a word
</code></pre>
<p>显然那是一个愚蠢的例子，但主要的一点是，在 shell 中，唯一应该出现未被引用的括号的地方是成对的（case 语句中的模式是一个例外，但模式周围的成对括号也是有效的，我在本指南中已经使用过那种形式）。因此你可以确信，任何格式良好的 shell 代码块都可以出现在命令替换内部。</p>
<p>这显然不适用于 <code>`...`</code>，即使基本效果相同。任何碰巧出现在反引号内代码块中的未被引用的 <code>`</code> 都会被视为引用的结束。</p>
<p>第二个原因，与此密切相关，是可能很难决定在反引号表达式内部需要多少层引用。考虑：</p>
<pre><code>  % print "`echo \"hello\"`"
  hello
  % print "$(echo \"hello\")"
  "hello"
</code></pre>
<p>很难解释这里的区别是什么，而不挥舞我的手，这会妨碍我打字，但本质上的一点其实与嵌套相同：你不能用反引号来做，因为开始和结束符号是相同的，但你可以用括号来做。所以在第二种情况下，毫无疑问，嵌入的命令行，<code>echo \"hello\"</code>，将被完全视为好像它出现在命令替换之外；而在第一种情况下，引号内的引号必须被，嗯，引用。</p>
<p>因此，在</p>
<pre><code>  % print "$(echo "hello")"
  hello
</code></pre>
<p>你需要小心：乍一看，成对的双引号包围着 <code>$(echo </code> 和 <code>)</code>，但它们没有，它们是通过替换嵌套的。你在参数替换中也看到了同样的事情：</p>
<pre><code>  % unset foo
  % print "${foo:-"a string"}"
  a string
</code></pre>
<p>第三个，不太好的，使用带括号形式的理由是，否则你更老练的朋友会嘲笑你。在这个复杂的世界里，同伴压力是如此重要。</p>
<p>关于命令替换，我就说这么多，因为我在<a href="zshguide03.html#syntax">第三章</a>讨论基本语法时已经说了很多了。</p>
<p>[]{#l118}</p>
<h2 id="52-修饰符及其修饰对象"><a class="header" href="#52-修饰符及其修饰对象">5.2: 修饰符及其修饰对象</a></h2>
<p>修饰符是在<a href="zshguide02.html#init">第二章</a>中我谈论“bang history”时引入的，因为它们来自那里。然而，在 zsh 中，它们可以在其他几个地方使用。它们在每种情况下的形式都相同：一个冒号，后面跟着一个字母，该字母是修饰符所做事情的代码，可能（在替换的情况下）后面跟着一些其他字符串。所以，为了唤醒你的记忆，除非你设置了 <code>NO_BANG_HIST</code>：</p>
<pre><code>  % print ~/file
  /home/pws/file
  % print !-1:t
  file
</code></pre>
<p>其中 <code>:t</code> 取文件名的尾部（非目录部分）。</p>
<p>第二个用途是在参数中。这很自然地延续了下去。请注意，这和任何后来使用修饰符的情况都不依赖于 <code>NO_BANG_HIST</code> 选项；那纯粹是为历史准备的。</p>
<pre><code>  % param=~/file
  % print ${param:t}
  file
</code></pre>
<p>通常你可以省略参数替换中的花括号，但为了清晰起见，我倾向于在有修饰符时使用它们。无论修饰符来自哪里，都使用 shell 的相同部分，这一事实有一定的后果：</p>
<pre><code>  % print foo
  foo
  % ^foo^bar
  bar
  % param='this sentence contains a foo.'
  % print ${param:&amp;}
  this sentence contains a bar.
</code></pre>
<p>与号重复上一次的替换，这对于参数修饰符和历史修饰符是相同的。我发现参数修饰符比历史修饰符更有用；提取路径的头部或尾部是对参数非常常见的操作。</p>
<p>修饰符也足够聪明，可以以一种有用的方式处理数组。请注意，这对于历史展开中的参数集是不成立的；<code>:t</code> 在那种情况下只会提取一个尾部，这可能不完全是你所期望的：</p>
<pre><code>  % print a sentence with a /real/live/bogus/path in it.
  % print !!:t
  path in it.
</code></pre>
<p>然而，数组<em>是</em>以你可能希望的方式处理的：</p>
<pre><code>  % array=(~/.zshenv ~/.zshrc ~/.zlogout)
  % print ${array:t}
  .zshenv .zshrc .zlogout
</code></pre>
<p>同样的逻辑也适用于替换。这意味着数组中每个元素的第一个匹配项都会被替换：</p>
<pre><code>  % array=('a bar of chocolate' 'a bar of barflies' 
  array&gt; 'a barrier of barns')
  % print ${array:s/bar/car/}
  a car of chocolate a car of barflies a carrier of barns
</code></pre>
<p>除非，当然，你做一个全局替换：</p>
<pre><code>  % print ${array:gs/bar/car/}
  a car of chocolate a car of carflies a carrier of carns
</code></pre>
<p>然而，请注意，参数替换有其自己<em>更</em>强大的等价物，它做模式匹配、部分替换原始字符串的修改部分等等。我们会在适当的时候讲到这个。</p>
<p>修饰符的最后一种用法是在文件名生成中，即通配。由于这通常通过在命令行上有特殊字符来工作，而修饰符只包含普通字符，所以语法有点不同：</p>
<pre><code>  % print *.c
  parser.c lexer.c input.c output.c
  % print *.c(:r)
  parser lexer input output
</code></pre>
<p>所以你需要用括号把它们括起来。这是“通配限定符”的一个特例，你将在下面遇到；你可以混合使用它们，但修饰符必须出现在末尾。例如，</p>
<pre><code>  % print -l ~/stuff/*
  /home/pws/stuff/onefile.c
  /home/pws/stuff/twofile.c
  /home/pws/stuff/subdir
  % print ~/stuff/*(.:r:t)
  onefile twofile
</code></pre>
<p>通配限定符 <code>.</code> 指定文件必须是常规文件，即不是目录也不是某种特殊文件。<code>:r</code> 从结果中移除后缀，<code>:t</code> 去掉目录部分。因此，如果你设置了 <code>NO_BARE_GLOB_QUAL</code> 选项，文件名修饰符将被关闭。</p>
<p>关于带文件名的修饰符，最后有两点需要注意。首先，它是唯一一种结果不再是文件名的通配形式；它总是在最后执行，在所有正常的文件名生成之后。大概，在上面的例子中，插入到命令行中的单词实际上不再对应于一个真实的文件了。</p>
<p>其次，虽然如果命令行上的单词不是一个模式，而是一个带修饰符的普通单词，它<em>确实</em>有效，但如果那个模式，在修改之前，不对应于一个真实的文件，它就<em>不</em>起作用。所以 <code>foo.c(:r)</code> 只有在当前目录中有 <code>foo.c</code> 时才会去掉后缀。鉴于匹配文件的尝试会启动通配系统，包括修饰符，这是完全合乎逻辑的。如果这对你是个问题，有办法绕过；例如，在像这样的简单情况下手动插入正确的值，或者更现实的，将值存储在一个参数中并对其应用修饰符。</p>
<p>[]{#l119}</p>
<h2 id="53-进程替换"><a class="header" href="#53-进程替换">5.3: 进程替换</a></h2>
<p>关于进程替换，我没有太多新的要说，但我有一个我发现它很有用的例子。如果你使用分页器 <code>less</code>，你可能知道它有预处理你查看的文件的功能，例如通过环境变量 <code>$LESSOPEN</code>（可能还有 <code>$LESSCLOSE</code>）临时解压文件。Zsh 可以非常容易地，而且在我完全不偏不倚的看来，更方便地做同样的事情。这里是我的 zsh 函数前端到 less 的一个子集——或者实际上是任何分页器，这里由标准环境变量 <code>$PAGER</code> 给出，默认为 <code>less</code>。如果你愿意，你可以在那个点硬编码任何文件显示命令。</p>
<pre><code>  integer i=1
  local args arg
  args=($*)

  for arg in $*; do
    case $arg in
      (*.bz2) args[$i]="=(bunzip2 -c ${(q)arg})"
              ;;
      # 这假设你的 zcat 是与 gzip 一起安装的那个：
      (*.(gz|Z)) args[$i]="=(zcat ${(q)arg})"
                 ;;
      (*) args=${(q)arg}
          ;;
    esac
    (( i++ ))
  done

  eval command ${PAGER:-less} $args
</code></pre>
<p>主要有趣的部分是数组 <code>$args</code> 的元素是如何被替换的。每个参数都被赋予了额外的一层引号，通过 <code>(q)</code>，原因在于最后的 <code>eval</code>；<code>$args</code> 首先被转换成一个文字字符数组，因此需要引用以保护特殊字符。没有那个，带有空格或星号等的文件名将无法正确显示。</p>
<p><code>eval</code> 在那里的原因是为了让进程替换在运行分页器时在命令行上被评估，而不是之前。它们被赋回给 <code>$args</code> 的元素时是带引号的，所以在那一点上不会被评估。效果是将：</p>
<pre><code>  less file.gz file.txt
</code></pre>
<p>变成</p>
<pre><code>  less =(zcat file.gz) file.txt
</code></pre>
<p>函数末尾的 <code>command</code> 在那里只是为了以防函数与分页器同名（即在这个例子中是 <code>less</code>）；它强制调用外部命令而不是函数。进程替换在这种情况下是理想的；它为 <code>less</code> 提供了一个文件名，解压后的 <code>file.gz</code> 的内容被发送到该文件，并且在命令退出后它会删除该文件。此外，替换的发生方式使得你仍然可以像通常使用 less 那样在命令行上指定多个文件。唯一的问题是出现在 <code>less</code> 提示符中的文件名是无意义的。</p>
<p>如果你没见过，<code>bzip2</code> 是一个与 <code>gzip</code> 非常相似的程序，它的使用方式几乎相同，但它提供更好的压缩。</p>
<p>输出进程替换有一个不便之处，就像 multios 一样。</p>
<pre><code>  echo hello &gt; &gt;(sed s/hello/goodbye)
</code></pre>
<p>shell 派生 <code>sed</code> 进程来处理来自命令行的输出——然后就忘了它。它不等待它（至少，直到它退出后，它才会使用 <code>wait</code> 系统调用来清理）。所以依赖于进程的结果在下一个命令中可用是危险的。如果你交互式地尝试它，事实上，你很可能会发现在 <code>sed</code> 的输出显示在终端之前，下一个提示符就已经打印出来了。这可能被认为是一个 bug，但修复起来相当困难。</p>
<p>[]{#l120}</p>
<h2 id="54-参数替换"><a class="header" href="#54-参数替换">5.4: 参数替换</a></h2>
<p>你可能从上面可以看出，参数替换是 zsh 命令行转换能力的许多核心所在。更重要的是，我们甚至还没有覆盖到所提供的功能的很大一部分。</p>
<p>[]{#l121}</p>
<h3 id="541-使用数组"><a class="header" href="#541-使用数组">5.4.1: 使用数组</a></h3>
<p>zsh 中的数组语法相当强大（惊讶吗？）；只是不要期望它像，比如说，perl 那样高效。像 zsh 的其他特性一样，它的存在是为了让用户的生活更轻松，而不是让你的电脑运行得飞快。</p>
<p>我已经零星地讲了如何设置数组，以及如何提取它们的部分——以下说明了这一点：</p>
<pre><code>  % array=(one two three four)
  % print ${array}
  one two three four
  % print ${array[3]}
  three
  % print ${array[2,-1]}
  two three four
</code></pre>
<p>记住，如果你想让数组成为函数局部的，你需要 <code>typeset</code> 或等价物。简洁的方法是 <code>typeset -a</code>，它创建一个空数组，但只要你在尝试使用数组之前给它赋值，任何旧的 <code>typeset</code> 都可以。</p>
<p>你可以使用数组索引和数组切片表示法来给数组赋值，换句话说，在 <code>=</code> 的左边：</p>
<pre><code>  % array=(what kind of fool am i)
  % array[2]=species
  % print $array
  what species of fool am i
  % array[2]=(a piece)
  % print $array
  what a piece of fool am i
  % array[-3,-1]=(work is a man)
  % print $array
  what a piece of work is a man
</code></pre>
<p>所以你可以用单个元素替换数组的单个元素，或者用一个数组切片；同样，你可以一次性用一个不同长度的切片替换一个切片——只有你明确告诉它要替换的部分会被改变，其余的保持不变，可能会被移动以为新内容腾出空间。这类似于 perl 的 <code>splice</code> 命令，只是这一次可能更容易记住。注意，你不应该在左边提供任何花括号。表达式出现在赋值中就足以触发下标的特殊行为，即使 <code>KSH_ARRAYS</code> 生效——尽管在这种情况下你需要从你的下标中减一。</p>
<p>你也可以移除中间的部分，但注意你应该使用一个空数组：</p>
<pre><code>  % array=(one two three four)
  % print $#array
  4
  % array[2]=
  % print $#array
  4
  % array[2]=()
  % print $#array
  3
</code></pre>
<p>第一个赋值将元素 2 设置为空字符串，它没有移除它。第二个用一个长度为零的数组替换了该数组元素，这确实移除了它。</p>
<p>就像参数替换有用于特殊目的的标志一样，下标也有。你可以强制它们搜索数组，匹配值。你可以返回匹配的值（(r)everse 下标）：</p>
<pre><code>  % array=(se vuol ballare signor contino)
  % print ${array[(r)s*]}
  se
  % print ${array[(R)s*]}
  signor
</code></pre>
<p><code>(r)</code> 标志接受一个模式并替换匹配的数组的第一个元素，而 <code>(R)</code> 标志做同样的事情，但从数组的末尾开始。如果没有匹配，你会得到空字符串；像往常一样，对于参数，如果它是未引用参数中唯一的东西，它将被省略。再次使用我们的 <code>args</code> 函数来计算传递给命令的参数数量：</p>
<pre><code>  % array=(some words)
  % args() { print $#; }
  % args ${array[(r)s*]}
  1
  % args ${array[(r)X*]}
  0
  % args "${array[(r)X*]}"
  1
</code></pre>
<p>在最后一种情况下，空字符串被引用，并作为单个空参数传递下去。</p>
<p>你也可以返回匹配的索引；<code>(i)</code> 从头开始匹配，<code>(I)</code> 从尾开始。</p>
<pre><code>  % array=(se vuol venire nella mia scuola)
  % print ${array[(i)v*]}
  2
  % print ${array[(I)v*]}
  3  
</code></pre>
<p>第一次匹配“vuol”，第二次匹配“venire”。如果它们不匹配会发生什么可能有点出乎意料，但相当合乎逻辑：你会得到下一个索引。换句话说，在末尾匹配失败会给你数组的长度加一，在开头匹配失败会给你零，所以：</p>
<pre><code>  array=(three egregious words)
  for pat in '*e*e*' '*a*a*'; do
    if [[ ${array[(i)$pat]} -le ${#array} ]]; then
      print "Pattern $pat matched in array: ${array[(r)$pat]}."
    else
      print "Pattern $pat failed to match in array"
    fi
  done
</code></pre>
<p>打印：</p>
<pre><code>  Pattern *e*e* matched in array: three.
  Pattern *a*a* failed to match in array
</code></pre>
<p>如果你调整那段代码，你会看到你得到的索引是 1 和 4。注意 <code>$pat</code> 中的字符被当作一个模式，即使把 <code>$pat</code> 放在命令行上通常只会产生字符本身。下标在这方面是特殊的；试图在这一点上控制语法有点棘手。在手册的 <code>zshparam</code> 手册页的“Subscript Parsing”部分或“Array Parameters”信息节点中有更详细的描述；要引用 <code>pat</code> 中的字符，你实际上需要提供命令行字符串 <code>'\*e\*e\*'</code> 和 <code>'\*a\*a\*'</code>。只要到处咕哝“额外的模式扩展层”，大家就会认为你知道你在说什么（这对我来说，断断续续地有效）。</p>
<p>目前没有办法用下标标志从普通数组中提取一个完整的匹配集。然而，我们将在下面看到其他方法。</p>
<p>[]{#l122}</p>
<h3 id="542-使用关联数组"><a class="header" href="#542-使用关联数组">5.4.2: 使用关联数组</a></h3>
<p>如果你忘了关联数组，请回顾<a href="zshguide03.html#syntax">第三章</a>。它们像普通数组一样接受下标，但这里的下标是与存储在数组元素中的值相关联的任意字符串（或键）。记住，你需要使用 <code>typeset -A</code> 来创建一个，或者 <code>typeset</code> 的亲戚们使用相同的选项。这意味着如果你在函数内部创建它，它将被限制在局部作用域，所以如果你想创建一个全局关联数组，你还需要给出 <code>-g</code> 标志。这对于关联数组尤其常见，它们经常用于存储全局信息，如配置细节。</p>
<p>从关联数组中检索信息可能会让你陷入一些已经在使用数组的下标标志时暗示过的问题。然而，由于正常的下标不会激活模式，这里有一个解决方法：将下标变成另一个参数：</p>
<pre><code>  % typeset -A assoc
  % assoc=(key value Shlüssel Wert clavis valor)
  % subscript='key'
  % print ${assoc[$subscript]}
  value  
</code></pre>
<p>我在这里用了相当无聊的键，但它们可以是任何字符串：</p>
<pre><code>  % assoc=(']' right\ square\ bracket '*' asterisk '@' at\ sign)
  % subscript=']'
  % print ${assoc[$subscript]}
  right square bracket
</code></pre>
<p>而<em>那个</em>更难用另一种方式得到。尽管如此，如果你定义自己的键，你通常会使用简单的单词，在这种情况下，它们可以愉快地直接出现在方括号中。</p>
<p>我在<a href="zshguide03.html#syntax">第三章</a>中介绍了两个参数标志，<code>(k)</code> 和 <code>(v)</code>：</p>
<pre><code>  % print ${(k)assoc}
  * ] @
</code></pre>
<p>打印出键，而</p>
<pre><code>  % print ${(kv)assoc}
  * asterisk ] right square bracket @ at sign
</code></pre>
<p>剩下的两种可能性做同样的事情：</p>
<pre><code>  % print ${(v)assoc}
  asterisk right square bracket at sign
  % print ${assoc}
  asterisk right square bracket at sign
</code></pre>
<p>你现在知道这些是应用于替换的更大技巧家族的一部分。没有什么能阻止你组合标志：</p>
<pre><code>  % print -r ${(qkv)assoc}
  \* asterisk \ ] right\ square\ bracket @ at\ sign
</code></pre>
<p>这有助于看清分词。不要忘记 <code>print -l</code> 技巧，用于分离不同的单词，从而分离数组和关联数组的元素：</p>
<pre><code>  % print -l ${(kv)assoc}
  *
  asterisk
  ]
  right square bracket
  @
  at sign
</code></pre>
<p>这清晰多了。像往常一样，如果你用 <code>SH_WORD_SPLIT</code> 进行非 zsh 的活动，这会失败，但明智地使用 <code>@</code>，无论是作为标志还是下标，以及双引号，总是有效的：</p>
<pre><code>  % print -l "${(@kv)assoc}"
  *
  asterisk
  ]
  right square bracket
  @
  at sign
</code></pre>
<p>无论选项设置如何。</p>
<p>除了下标，关联数组和普通数组之间的第二个主要区别是前者没有定义的顺序。如果你使用过 Perl，这将完全熟悉；这里的原则是相同的。然而，zsh 根本没有关联数组切片的概念，即使是作为一种便利。你可以赋单个元素或整个关联数组——记住在第二种情况下，右侧必须由键/值对组成——但你不能赋子组。任何使用带逗号的切片表示法的尝试都会遇到严厉的错误消息。</p>
<p>然而，zsh 确实有额外的下标标志，供你匹配和检索一个或多个元素。如果你使用一个以 <code>(i)</code> 标志为前缀的下标，而不是一个普通的下标，shell 将搜索一个匹配的键（而不是值），并返回它。这被故意设计成与搜索普通数组以获取其键（在这种情况下只是一个数字，即索引）相同，但请注意，这次它不匹配值，它确实匹配并返回键：</p>
<pre><code>  % typeset -A assoc
  % assoc=(fred third\ man finnbar slip roger gully trevor long\ off)
  % print ${assoc[(i)f*]}
  fred
</code></pre>
<p>你仍然可以使用参数标志 <code>(k)</code> 和 <code>(v)</code> 来告诉 shell 你想返回键和/或值的哪一部分：</p>
<pre><code>  % print ${(kv)assoc[(i)f*]}
  fred third man
</code></pre>
<p>注意分工。下标标志告诉 shell 要匹配什么，而参数标志告诉它你实际上想看到匹配元素的哪一部分。</p>
<p>由于关联数组的本质上是随机排序的，你无法在这里判断是选择 fred 还是 finnbar。然而，你可以使用大写形式 <code>(I)</code> 来告诉 shell 检索所有匹配项。这一次，让我们看看键被匹配的元素的值：</p>
<pre><code>  % print -l ${(v)assoc[(I)f*]}
  third man
  slip
</code></pre>
<p>在这里我们也得到了 <code>finnbar</code> 占据的位置。关于模式的规则与普通数组中的 <code>(r)</code> 相同——下标被视为一个模式，即使它本身来自一个参数替换。</p>
<p>你可能不会惊讶地听到，下标标志 <code>(r)</code> 和 <code>(R)</code> 尝试匹配关联数组的值而不是其键。这些也打印出实际匹配的部分，这里是值，除非你使用参数标志。</p>
<pre><code>  % print ${assoc[(r)*i*]}
  third man
  % print ${(k)assoc[(R)*i*]}
  fred finnbar
</code></pre>
<p>还有一对与关联数组特别相关的下标标志，<code>(k)</code> 和 <code>(K)</code>。它们的工作方式有点像一个 case 语句：下标被视为字符串，而关联数组的键被视为模式，而不是反过来。使用 <code>(k)</code>，匹配下标的第一个键的值被替换；使用 <code>(K)</code>，所有匹配键的值都被替换</p>
<pre><code>  % typeset -A assoc
  % assoc=('[0-9]' digit '[a-zA-Z]' letter '[^0-9a-zA-Z]' neither)
  % print ${assoc[(k)0]}
  digit
  % print ${assoc[(k)_]}
  neither
</code></pre>
<p>如果你仍然感到困惑，第一个下标中的 <code>0</code> 被当作一个字符串，<code>$assoc</code> 中的所有键依次被当作模式，有点像</p>
<pre><code>  case 0 in
    ([0-9]) print digit
            ;;
    ([a-zA-Z]) print letter
               ;;
    ([^0-9a-zA-Z]) print neither
                   ;;
  esac
</code></pre>
<p>这与 case 语句中的选择有一个重要的不同之处，那就是你不能依赖比较的顺序，所以你不能依赖于在更具体的模式之后匹配更通用的模式。你只需要使用足够明确的键来只匹配你想要匹配的字符串，而不匹配其他任何东西。这就是为什么我们选择模式 <code>[^0-9a-zA-Z]</code> 而不是像我们在 case 语句中可能会使用的 <code>*</code>。</p>
<p>我说过存储配置信息是关联数组的一个常见用途，但 shell 有一个更强大的方法来做到这一点：样式，这将在下一章关于可编程补全的讨论中占据重要位置。样式相对于关联数组的主要优点是它们可以被设置为上下文敏感的；你可以很容易地让同一个样式全局返回相同的值，或者让它有一个默认值但在一个特定的上下文中有一个不同的值，或者在不同的地方给它一大堆不同的值。每个 shell 应用程序都可以决定“上下文”的含义；你不必受限于补全系统使用的方案，或任何类似的东西。以补全系统的方式使用分层上下文意味着很容易为不同的模块创建不冲突的样式集。</p>
<p>最后，这里是 perl 和 zsh 中关联数组的一些用法的比较。</p>
<pre><code>      perl                          zsh
  -----------------------------------------------------------------
  %hash = qw(key value);         typeset -A hash; hash=(key value)
  $hash{key}                     ${hash[key]}
  keys %hash                     ${(k)hash}
  values %hash                   ${(v)hash}
  %hash2 = %hash;                typeset -A hash2; hash2=("${(@kv)hash}")
  unset %hash;                   unset hash
  if (exists $hash{key}) {       if (( ${+hash[key]} )); then
    ...                            ...
  }                              fi
</code></pre>
<p>最后一个提醒：如果你在函数内部创建的关联数组需要在函数结束后仍然存在，你应该用 <code>typeset -gA</code> 来创建它们，这会将它们放入周围的作用域。<code>-g</code> 标志当然对所有类型的参数都很有用，但关联数组是唯一一种在你在正确的上下文中给它赋值时不会自动产生的类型；因此，这个标志在这里特别值得注意。</p>
<p>[]{#l123}</p>
<h3 id="543-替换的替换首尾处理等"><a class="header" href="#543-替换的替换首尾处理等">5.4.3: 替换的替换、首尾处理等。</a></h3>
<p>你可以对参数替换的结果进行许多转换。最强大的涉及模式的使用。为此，你对模式了解得越多越好，所以我将保留一些最古怪的解释，直到我更详细地讲解模式之后。特别是，如果你知道如何告诉 shell 标记它已经匹配的子表达式以便将来提取，那会很有用。然而，你只需使用所有 shell 共有的基本模式就可以做一些非常有用的事情。</p>
<p><strong>标准形式：长度</strong>\</p>
<p>我将把 zsh 特有的形式分开，从所有源自 Bourne shell 的 shell 中都出现的一些形式开始。手册中一如既往地给出了一个更紧凑（读作：简洁）的列表。</p>
<p>一些简单的形式不使用模式。首先，替换 <code>${#</code><em>param</em><code>}</code> 输出 <code>$</code><em>param</em> 的长度。在 zsh 中，你在这里不需要花括号，尽管在大多数其他具有此功能的 shell 中你需要。请注意，<code>${#}</code> 本身是命令行参数数组中的参数数量，这就是为什么明确使用花括号更清晰的原因。</p>
<p><code>$#</code> 对标量值和数组值的处理方式不同；在前一种情况下，它给出字符长度，在后一种情况下，它给出元素数量。请注意，我说的是“值”，而不是“参数”——你必须弄清楚替换是给你一个标量还是一个数组：</p>
<pre><code>  % print ${#path}
  8
  % print ${#path[1]}
  13
</code></pre>
<p>第一个结果显示我的路径中有 8 个目录，后者显示第一个目录（实际上是 <code>/home/pws/bin</code>）有 13 个字符。你应该在嵌套替换时记住这一点，如下所述，它也可以返回一个数组或一个标量。</p>
<p>早期版本的 zsh 如果表达式在双引号中，或者在 shell 将表达式评估为单个单词的任何地方，总是返回一个字符计数，但这不再发生了；它只取决于值的类型。然而，你可以通过使用 <code>(c)</code> 标志强制 shell 计算字符，通过使用 <code>(w)</code> 标志计算单词（即使在标量中，它也会在必要时进行分割）：</p>
<pre><code>  % print ${#PATH}
  84
  % print ${(c)#path}
  84
  % foo="three scalar words"
  % print ${(w)#foo}
  3
</code></pre>
<p>比较前两个，你会看到数组的字符计数包括用于分隔的空格（等于 <code>$PATH</code> 中分隔元素的冒号数量）。<code>(w)</code> 的一个亲戚叫做 <code>(W)</code>，它将多个单词分隔符视为空长度的单词：</p>
<pre><code>  % foo="three  well-spaced  word"
  % print ${(w)#foo}
  3
  % print ${(W)#foo}
  5
</code></pre>
<p>比 <code>(w)</code> 多了两个单词，后者将空格组视为一个。作为参数标志，这些语法的修改是 zsh 特有的。</p>
<p>请注意，如果你在算术上下文中使用长度（在 <code>((...))</code> 或 <code>$((...))</code> 内部），你必须包含前导的 <code>$</code>，而替换参数本身时则不需要。那是因为 <code>#foo</code> 在这里意味着不同的东西——<code>$foo</code> 中第一个字符在 ASCII 字符集（或者如果你使用的是扩展字符集，则是它的任何扩展）中的编号。</p>
<p><strong>标准形式：条件替换</strong>\</p>
<p>下一组替换是一整系列，其中参数后跟一个可选的冒号，然后是 <code>-</code>、<code>=</code>、<code>+</code> 或 <code>?</code>。冒号在每种情况下的效果都相同：没有冒号，shell 在执行操作前测试参数是否已设置，而有冒号，它测试参数是否具有非零长度。</p>
<p>最简单的是 <code>${</code><em>param</em><code>:-</code><em>value</em><code>}</code>。如果 <code>$param</code> 具有非零长度（没有冒号，如果它根本被设置了），则使用它的值，否则使用提供的 <em>value</em>。假设 <code>$foo</code> 在以下开始时没有被设置（无论这看起来多么不可能）：</p>
<pre><code>  % print ${foo-bar}
  bar
  % foo=''
  % print ${foo-bar}
  
  % print ${foo:-bar}
  bar
  % foo='please no anything but bar'
  % print ${foo:-bar}
  please no anything but bar
</code></pre>
<p>更常用的是带冒号的形式。一个原因是，在函数中，你通常会在使用参数之前用 <code>typeset</code> 创建它，在这种情况下，它总是存在，初始长度为零，所以另一种形式永远不会使用默认值。我将用冒号来描述其他三种类型。</p>
<p><code>${</code><em>param</em><code>:=</code><em>value</em><code>}</code> 与前一种类型类似，但在这种情况下，shell 不仅会将 <em>value</em> 替换到行中，如果（且仅当）它这样做时，它还会将其赋给 <em>param</em>。这导致了脚本和函数中以下常见的用法：</p>
<pre><code>  : ${MYPARAM:=default}  ${OTHERPARAM:=otherdefault}
</code></pre>
<p>如果用户已经设置了 <code>$MYPARAM</code>，什么也不会发生，否则它将被设置为 <code>default</code>，<code>${OTHERPARAM}</code> 也类似。<code>:</code> 命令在命令行被处理后什么也不做，只返回 true。</p>
<p><code>${</code><em>param</em><code>:+</code><em>value</em><code>}</code> 是 <code>:-</code> 的反面，逻辑上足够：如果参数<em>不</em>具有零长度，则替换 <em>value</em>。在这种情况下，<em>value</em> 通常会是另一个参数替换：</p>
<pre><code>  print ${value:+"the value of value is $value"}
</code></pre>
<p>仅当 <code>$#value</code> 大于零时才打印该字符串。请注意，<code>+</code> 后面可以出现的几乎是 shell 可以解析的任何单个单词；所有通常的单单词替换（所以不包括通配）都将应用于它，并且引号将像往常一样工作。这也适用于 <code>:-</code> 和 <code>:=</code> 后面的值。另一个常见的技巧可能值得一提：</p>
<pre><code>  print ${1+"$@"}
</code></pre>
<p>如果第一个位置参数被设置，则替换所有传递的位置参数（这里你不需要冒号）。在一些旧的 shell 中这是必要的，因为当没有参数传递时，单独的 <code>"$@"</code> 会给你一个单个的空参数而不是没有参数。在 zsh 中，以及在大多数现代的 Bourne 派生 shell 中，这个变通方法是不必要的。然而，zsh 的处理有一个 bug；请参见第三章中关于函数参数的部分。</p>
<p>最后一种类型不常用（意思是我从未使用过）：<code>${</code><em>param</em><code>?</code><em>message</em><code>}</code> 测试 <em>param</em> 是否被设置（无冒号），如果未设置，则打印消息并退出 shell。交互式 shell 不会退出，但它会立即将你返回到提示符，跳过任何其他已存储待执行的内容。这是一个基本的安全特性，有点像 C 程序中的 <code>assert</code>；大多数 shell 程序员似乎通过更详细的测试来处理缺少参数设置的情况。在用于交互式使用的短 shell 函数中，它非常简洁：</p>
<pre><code>  mless() { mtype ${@:?missing filename} | $PAGER }
</code></pre>
<p><strong>标准形式：模式移除</strong>\</p>
<p>大多数更复杂的类 Bourne shell 定义了两对模式运算符，我称之为“首尾”运算符。一对（使用 <code>#</code> 和 <code>##</code>）从字符串的头部移除给定的模式，返回其余部分，而另一对（使用 <code>%</code> 和 <code>%%</code>）从字符串的尾部移除一个模式。在每种情况下，带一个符号的形式移除最短的匹配模式，而带两个符号的形式移除最长的匹配模式。两个典型的用法是：</p>
<pre><code>  % print $HOME
  /home/pws
  % print ${HOME##*/}
  pws
  % print ${HOME%/*}
  /home
</code></pre>
<p>在这里，它们与 <code>${HOME:t}</code> 和 <code>${HOME:h}</code> 有相同的效果，在 zsh 中你更可能使用后者。然而，如你所见，模式形式要通用得多。注意与以下的不同：</p>
<pre><code>  % print ${HOME#*/}
  home/pws
  % print ${HOME%%/*}
</code></pre>
<p>其中，头部 <code>*/</code> 的最短匹配只是第一个斜杠，因为 <code>*</code> 可以匹配空字符串，而尾部 <code>/*</code> 的最长匹配是整个字符串，一直回到第一个斜杠。虽然这些是标准形式，但请记住，zsh 模式的全部功能都是可用的。</p>
<p>你如何记住哪个运算符做什么？较长的形式做较长的匹配可能很容易记住。记住 <code>#</code> 在头部移除，<code>%</code> 在尾部移除则更难。试着想“hash”和“head”（如果你称它为“pound sign”，而它根本不是，因为英镑符号看起来像 <code>£</code>，你不会得到我的同情），以及“percent”和“posterior”。这对我从来没用过，但也许我只是没有那种精神纪律。Oliver Kiddle 指出，在标准的美国键盘上，<code>#</code> 更靠左（头部）。在我的英国键盘上，不幸的是，<code>#</code> 就在回车键旁边，尽管在这里与“pound sign”的混淆会唤醒你的记忆。</p>
<p>最重要的事情要记住是：这个表示法不是我们的错。无论如何，抱歉。顺便说一句，请注意，在模式运算符的情况下，没有关于冒号的奇怪事情。（嗯——除了下面提到的 zsh 变体。）</p>
<p><strong>Zsh 特有的参数替换</strong>\</p>
<p>现在是一些 zsh 对使用我刚刚给出的参数替换形式以及一些类似但不同的形式的增强。</p>
<p>一个简单的增强是，除了 <code>${</code><em>param</em><code>=</code><em>value</em><code>}</code> 和 <code>${</code><em>param</em><code>:=</code><em>value</em><code>}</code>，zsh 还有 <code>${</code><em>param</em><code>::=</code><em>value</em><code>}</code>，它执行一个无条件的赋值，并把值放在命令行上。它与使用普通赋值，然后是普通参数替换并没有真正的不同，只是 zsh 用户喜欢密集的代码。</p>
<p>所有赋值类型都受参数标志 <code>A</code> 和 <code>AA</code> 的影响，它们告诉 shell 执行数组和关联数组赋值（在第二种情况下，你像往常一样需要键/值对）。然而，你需要对数组元素和分词小心一点：</p>
<pre><code>  % print -l ${(A)foo::=one two three four}
  one two three four
  % print ${#foo}
  1
</code></pre>
<p>那确实使 <code>$foo</code> 成了一个数组，但将参数视为一个标量值并将其赋给第一个元素。有一个解决方法：</p>
<pre><code>  % print -l ${(A)=foo::=one two three four}
  one
  two
  three
  four
  % print ${#foo}
  4
</code></pre>
<p>在这里，参数名前的 <code>=</code> 与其他的效果完全不同：它打开了分词功能，就好像 <code>SH_WORD_SPLIT</code> 选项生效一样。你可能还记得我在<a href="zshguide03.html#syntax">第三章</a>的“函数参数”部分详细地讲过这个。</p>
<p>然而，你应该小心，因为更复杂的在参数值内放置数组的尝试很容易让你误入歧途。使用 <code>*array*</code>=<code>(*\...*)</code> 或 <code>set -A</code> <em>...</em>` 表示法通常要容易得多。</p>
<p>一个非常有用的 zsh 增强是表示法 <code>${+foo}</code>，如果 <code>$foo</code> 被设置则返回 1，否则返回 0。你可以在算术表达式中使用这个。这是一种比更标准的 <code>${foo?goodbye}</code> 表示法更灵活地处理可能未设置的参数的方法，因此 zsh 程序员更好地使用它。表示法“plus foo”表示“foo is set”也应该相当好记。一个更标准的做法（由 David Korn 指出）是 <code>0${foo+1}</code>，如果 <code>$foo</code> 未设置则给出 0，如果设置了则给出 01。</p>
<p><strong>参数标志和模式替换</strong>\</p>
<p>Zsh 通过一些参数标志增加了“首尾”运算符的用处。通常这些会显示移除某个匹配部分后剩下的内容。然而，使用 <code>(M)</code> 标志，shell 会转而显示匹配的部分。<code>(R)</code> 标志是相反的，显示其余部分：在正常情况下，这不那么有用，因为你默认得到的就是这个。只有当你将它与其他标志结合使用时，它才开始变得有用。</p>
<p>接下来，zsh 允许你匹配子字符串，而不仅仅是头部或尾部。你可以通过给 <code>#</code> 或 <code>%</code> 模式匹配形式加上 <code>(S)</code> 标志来做到这一点。这里的区别在于 shell 是从字符串的开头还是结尾开始搜索匹配的子字符串。让我们来看</p>
<pre><code>  foo='where I was huge lizards walked here and there'
</code></pre>
<p>看看我们匹配 <code>h*e</code> 会得到什么：</p>
<pre><code>  % print -l ${(S)foo#h*e} ${(S)foo##h*e} ${(S)foo%h*e} ${(S)foo%%h*e}
  wre I was huge lizards walked here and there
  w
  where I was huge lizards walked here and tre
  where I was huge lizards walked here and t
</code></pre>
<p>乍一看有一些奇怪的差异，但情况是这样的。在第一种情况下，<code>#</code> shell 向前查找，直到找到 <code>h*e</code> 的匹配，并取最短的，即第一个单词中的 <code>he</code>。对于 <code>##</code>，匹配在同一点成功，但最长匹配延伸到字符串末尾的 <code>e</code>。对于另外两种形式，shell 从末尾向后扫描，并在到达有匹配的起点时立即停止。对于 <code>%</code> 和 <code>%%</code>，这都是最后一个 <code>h</code>，但前者匹配 <code>he</code>，后者匹配 <code>here</code>。</p>
<p>你可以通过使用 <code>(I)</code> 标志来指定一个数字索引来扩展这个功能。索引需要被界定，通常，但不一定，用冒号。然后 shell 会向前或向后扫描，取决于使用的形式，直到找到第 <code>(I)</code> 个匹配。请注意，它只从每个位置计算一个匹配，要么是最长的，要么是最短的，所以第 <code>(I)</code> 个匹配从有任何匹配的第 <code>(I)</code> 个位置开始。这里是当我们使用上面的例子移除所有 <code>#</code> 的匹配时发生的情况。</p>
<pre><code>  % for (( i = 1; i &lt;= 5; i++ )); do
  for&gt; print ${(SI:$i:)foo#h*e}
  for&gt; done
  wre I was huge lizards walked here and there
  where I was  lizards walked here and there
  where I was huge lizards walked re and there
  where I was huge lizards walked here and tre
  where I was huge lizards walked here and there
</code></pre>
<p>每次我们匹配并移除一个可能的 <code>h*e</code> 集合，其中中间没有 <code>e</code>，从左到右移动。最后一次没有剩下什么可匹配的，返回了完整的字符串。请注意，我们使用的索引本身就是一个参数。</p>
<p>很明显 <code>##</code> 会发生什么：它会在所有相同的点找到匹配，但它们都会延伸到字符串末尾的 <code>e</code>。可能不太明显的是 <code>%%</code> 和 <code>%</code> 会发生什么，但如果你试试，你会发现它们产生与 <code>##</code> 和 <code>#</code> 完全相同的匹配集，只是索引顺序相反（4 对应 1，3 对应 2，等等）。</p>
<p>如果你愿意，你可以使用 <code>M</code> 标志来保留匹配的部分而不是字符串的其余部分。还有三个其他标志，可以让你得到与匹配相关的索引而不是字符串：<code>(B)</code> 表示开头，使用通常的 zsh 约定，即第一个字符是 1，<code>(E)</code> 表示结尾<em>之后</em>的字符，<code>(N)</code> 表示长度，即 <code>B-E</code>。你甚至可以有多个这样的标志；替换的值是一个字符串，其中包含给定的值，用空格分隔，总是按开头、结尾、长度的顺序。</p>
<p>有一个与 <code>(S)</code> 标志相反的东西，它不是匹配子字符串，而是只匹配整个字符串；要做到这一点，在 <code>#</code> 前面放一个冒号。因此：</p>
<pre><code>  % print ${foo:#w*g}
  where I was huge lizards walked here and there
  % print ${foo:#w*e}

  % 
</code></pre>
<p>第一个没有匹配，因为 <code>g</code> 不在末尾；第二个匹配了，因为末尾有一个 <code>e</code>。</p>
<p><strong>模式替换</strong>\</p>
<p>最强大的参数模式匹配形式是从 bash 和 ksh93 借来的；它在传统的 Bourne shell 中不存在。在这里，你用一对 <code>/</code> 来指示要替换的模式及其替换。让我们再用蜥蜴：</p>
<pre><code>  % print ${foo/h*e/urgh}
  wurgh
</code></pre>
<p>有点难以理解：那是因为像大多数模式匹配器一样，除非被告知，否则它会取最长的匹配。在这种情况下，<code>(S)</code> 标志被用来表示不是一个子字符串（那是自动的），而是最短的匹配：</p>
<pre><code>  % print ${(S)foo/h*e/urgh}
  wurghre I was huge lizards walked here and there
</code></pre>
<p>那只替换了第一个匹配。这就是 <code>//</code> 的用武之地；它替换每个匹配：</p>
<pre><code>  % print ${(S)foo//h*e/urgh}
  wurghre I was urgh lizards walked urghre and turghre
</code></pre>
<p>（毫无疑问，你已经开始感觉像一个典型的过时的好莱坞穴居人了。）注意语法：它有点像 <code>sed</code> 或 perl 中的替换，但末尾没有斜杠，并且对于 <code>//</code>，只有第一个斜杠是双写的。有点令人困惑的是，对于其他模式表达式，单个和双个形式意味着最短和最长的匹配，而在这里，是 <code>(S)</code> 标志起了作用。</p>
<p>索引标志 <code>(I)</code> 在这里也很有用。在 <code>/</code> 的情况下，它告诉 shell 要替换哪个单个匹配，在 <code>//</code> 的情况下，它告诉 shell 从哪个匹配开始：从那个开始的所有匹配都会被替换。</p>
<p>重叠的匹配永远不会被 <code>//</code> 替换；一旦它为一次匹配放入了新文本，该部分就不再被考虑，紧邻其右侧的文本被检查是否有匹配。这可能让你想起了其他替换方案。</p>
<p>你很可能在想“如果能在替换文本中使用匹配的文本或其一部分就好了？” 这就是你在 sed 中用 <code>\1</code> 或 <code>\&amp;</code>，在 perl 中用 <code>$1</code> 和 <code>$&amp;</code> 能做到的。事实证明，这在 zsh 中是<em>可能</em>的，这要归功于更复杂的模式匹配特性的一部分。当我们讲到模式时，我会谈到这个，因为它不完全是参数替换的一部分，尽管它被设计成能与那很好地配合。</p>
<p>[]{#l124}</p>
<h3 id="544-选项标志分割和连接"><a class="header" href="#544-选项标志分割和连接">5.4.4: 选项标志：分割和连接</a></h3>
<p>有三种看起来不像标志的标志，出于历史原因；你已经在<a href="zshguide03.html#syntax">第三章</a>中见过它们了。第一个是打开 <code>SH_WORD_SPLIT</code> 选项的那个，<code>${=foo}</code>。请注意，你可以将它与<em>确实</em>看起来像标志的标志混合使用，在括号中，在这种情况下，<code>=</code> 必须在右括号之后。你可以通过将符号加倍来强制为单个替换关闭该选项：<code>${==foo}</code>。然而，你不会这样做，除非该选项已经被设置，在这种情况下，你可能试图与某个其他 shell 兼容，并且不想使用那种形式。</p>
<p>通过三个更标准的标志类型，<code>(s)</code>、<code>(j)</code> 和 <code>(z)</code>，可以对分割和连接进行更多控制。它们分别在给定的字符串上进行分割，用给定的字符串进行连接，以及完全按照 shell 的方式进行分割。在前两种情况下，你需要以与为 <code>(I)</code> 标志指定索引相同的方式指定字符串。所以，例如，这里是如何将 <code>$PATH</code> 转换成一个普通数组而不使用 <code>$path</code>：</p>
<pre><code>  % print -l ${(s.:.)PATH}
  /home/pws/bin
  /usr/local/bin
  /usr/sbin
  /sbin
  /bin
  /usr/bin
  /usr/X11R6/bin
  /usr/games
</code></pre>
<p>任何字符都可以跟在 <code>(s)</code> 或 <code>(j)</code> 后面；字符串参数一直持续到匹配的字符，这里是 <code>.</code>。如果字符是像 <code>&lt;</code> 这样的括号类字符之一，那么“匹配”的字符是相应的右括号，例如 <code>${(s&lt;:&gt;)PATH}</code> 和 <code>${(s(:))PATH}</code> 都是有效的。这适用于所有需要参数的标志，包括 <code>(I)</code>。</p>
<p>虽然分割或连接字符串不是一个模式，但它不必是单个字符：</p>
<pre><code>  % foo=(array of words)
  % print ${(j.**.)foo}
  array**of**words
</code></pre>
<p><code>(z)</code> 标志不接受参数。由于它处理在 shell 的完整单词定义上的分割，它自然与带引号的表达式一起使用，我上面讨论了它与 <code>(Q)</code> 标志一起使用，用于从一行中提取单词并移除引号。</p>
<p>同一个参数表达式可能同时应用了分割和连接。这总是以相同的顺序发生，无论你如何指定标志：先连接，后分割。这在手册中关于参数替换的（相当棘手的）完整规则集里有描述。有一两种情况下，这可能有点令人惊讶。一种是当你设置了 <code>SH_WORD_SPLIT</code> 并尝试连接一个字符串时：</p>
<pre><code>  % setopt shwordsplit    
  % foo=('another array' of 'words with spaces')
  % print -l ${(j.:.)foo}
  another
  array:of:words
  with
  spaces
</code></pre>
<p>如果你不使用 <code>-l</code> 选项来打印，你可能没有注意到，但即使你要求用冒号连接数组，空格仍然导致了分词。要避免这种情况，要么不要使用 <code>SH_WORD_SPLIT</code>（我个人偏好），要么使用引号：</p>
<pre><code>  % print -l "${(j.:.)foo}"
  another array:of:words with spaces
</code></pre>
<p>在这种情况下，数组的元素通常会用空格连接，但 <code>(j)</code> 标志指定的字符优先。同样，如果 <code>SH_WORD_SPLIT</code> 生效，由 <code>(s)</code> 给出的任何分割字符串都会被使用，而不是通常的字符集，即默认情况下是空格、制表符、换行符和 NUL 的字符串 <code>$IFS</code> 中的任何字符。</p>
<p>为特定的参数替换指定一个分割不仅设置了要分割的字符串，而且还确保即使表达式被引用，分割也会发生：</p>
<pre><code>  % array=('element one' 'element two' 'element three')
  % print -l "${=array}"
  element
  one
  element
  two
  element
  three
</code></pre>
<p>为了清楚地说明这里发生了什么：引号强制元素用空格连接，形成一个单一的字符串，然后这个字符串在原始的空格以及用于连接数组元素的空格上被分割。</p>
<p>我稍后会谈到嵌套参数替换；你还应该注意，分割和连接会在必要时在嵌套替换的所有级别上发生，而不仅仅是最外层：</p>
<pre><code>  % foo="three blind words"
  % print ${#${(z)foo}}
  3
</code></pre>
<p>这打印了最内层表达式的长度；由于 zplit，那产生了一个三元素的数组。</p>
<p>[]{#l125}</p>
<h3 id="545-选项标志glob_subst-和-rc_expand_param"><a class="header" href="#545-选项标志glob_subst-和-rc_expand_param">5.4.5: 选项标志：<code>GLOB_SUBST</code> 和 <code>RC_EXPAND_PARAM</code></a></h3>
<p>另外两个不使用括号的标志也影响单个替换的选项。第二个是 <code>~</code> 标志，它打开 <code>GLOB_SUBST</code>，使得参数替换的结果有资格进行模式匹配。正如表示法所暗示的，它也使得文件名扩展成为可能，所以</p>
<pre><code>  % foo='~'
  % print ${~foo}
  /home/pws
</code></pre>
<p>是第一个 <code>~</code> 给了主目录；参数展开中的那个只是允许这种情况发生。如果你设置了 <code>GLOB_SUBST</code>，你可以使用 <code>$~foo</code> 来为一次替换关闭它。</p>
<p>还有另一个这样的选项标志：<code>^</code> 强制为当前替换打开 <code>RC_EXPAND_PARAM</code>，<code>^^</code> 强制关闭它。在<a href="zshguide03.html#syntax">第三章</a>中，我展示了用这个选项展开的参数如何与花括号展开相适应。</p>
<p>[]{#l126}</p>
<h3 id="546-更多参数标志"><a class="header" href="#546-更多参数标志">5.4.6: 更多参数标志</a></h3>
<p>这里还有一些其他的参数标志；我正在重复其中的一些。一个非常有用的标志是 <code>t</code>，用于告诉你一个参数的类型。这在<a href="zshguide03.html#syntax">第三章</a>中也出现过。它最常见的用途是在尝试使用参数之前测试其基本类型：</p>
<pre><code>  if [[ ${(t)myparam} != *assoc* ]]; then
    # $myparam 不是一个关联数组。做点什么。
  fi
</code></pre>
<p>另一个非常有用的类型是用于字符串的左或右填充，到指定的长度，并且可选地使用指定的填充字符串而不是空格；你甚至可以指定一个一次性的字符串紧挨着所讨论的字符串。</p>
<pre><code>  foo='abcdefghij'
  for (( i = 1; i &lt;= 10; i++ )); do
   goo=${foo[1,$i]}
   print ${(l:10::X::Y:)goo} ${(r:10::X::Y:)goo}
  done
</code></pre>
<p>打印出相当漂亮的：</p>
<pre><code>  XXXXXXXXYa aYXXXXXXXX
  XXXXXXXYab abYXXXXXXX
  XXXXXXYabc abcYXXXXXX
  XXXXXYabcd abcdYXXXXX
  XXXXYabcde abcdeYXXXX
  XXXYabcdef abcdefYXXX
  XXYabcdefg abcdefgYXX
  XYabcdefgh abcdefghYX
  Yabcdefghi abcdefghiY
  abcdefghij abcdefghij
</code></pre>
<p>请注意，那些冒号（可以是其他字符，正如我为 <code>(s)</code> 和 <code>(j)</code> 标志解释的那样）总是在参数前后成对出现，所以对于三个参数，中间的冒号是双写的。你可以省略 <code>:Y:</code> 部分和 <code>:X:</code> 部分，看看会发生什么。填充字符串不必是单个字符；如果它们不能精确地填充到填充空间中，最后一个重复将在离被插入的参数参数最远的一端被截断。</p>
<p>两个参数告诉 shell 你想对参数替换的值做一些特殊处理。<code>(P)</code> 标志强制将值视为一个参数名，这样你就能得到一个双重替换的效果：</p>
<pre><code>  % final=string
  % intermediate=final
  % print ${(P)intermediate}
  string
</code></pre>
<p>这有点像 <code>$intermediate</code> 是 ksh 中所谓的“nameref”，一个被标记为引用另一个参数的参数。Zsh 最终可能也会有这些；在某些地方，它们比 <code>(P)</code> 标志方便得多。</p>
<p>一个更强大的标志是 <code>(e)</code>，它强制对值重新扫描所有形式的单单词替换。例如，</p>
<pre><code>  % foo='$(print $ZSH_VERSION)'
  % print ${(e)foo}
  4.0.2
</code></pre>
<p>使得 <code>$foo</code> 的值被重新检查，此时命令替换被找到并执行。</p>
<p>剩下的标志是一些简单的特殊格式化技巧：用 <code>(o)</code> 按正常词法（字符）顺序排序数组元素，用 <code>(O)</code> 按相反顺序排序，用 <code>(oi)</code> 或 <code>(Oi)</code> 分别进行不区分大小写的排序，用 <code>(%)</code> 展开提示符的 <code>%</code>-转义（容易记住），用 <code>p</code> 像 <code>print</code> 那样展开反斜杠转义，用 <code>(U)</code> 强制所有字符为大写或用 <code>(L)</code> 为小写，用 <code>(C)</code> 将字符串或每个数组元素的第一个字符大写，用 <code>(V)</code> 将特殊字符显示为转义序列。这应该足够你用了。</p>
<p>[]{#l127}</p>
<h3 id="547-一些参数替换技巧"><a class="header" href="#547-一些参数替换技巧">5.4.7: 一些参数替换技巧</a></h3>
<p>我忍不住要描述几个额外的技巧。</p>
<p>Zsh 在参数表达式上能做的事情太多了，以至于有时即使没有参数也很有用！例如，这里是如何在不需要将其放入参数的情况下获取固定字符串的长度：</p>
<pre><code>  % print ${#:-abcdefghijklm}
  13
</code></pre>
<p>如果名称未给出的参数长度为零（确实如此，因为没有），则改用 <code>:-</code> 后面的字符串，并取其长度。请注意，你需要冒号，否则你是在要求 shell 测试一个参数是否已设置，当它意识到没有要测试的参数时，它会变得相当不高兴。其他 shell 不太可能容忍任何此类语法上的暴行；那种情况下的 <code>#</code> 很可能被视为 <code>$#</code>，即 shell 参数的数量。但 zsh 知道那不会是零长度，并假设你知道你在用额外部分做什么；这很有用，但技术上违反了规则。</p>
<p>有时你除了标志之外什么都不需要。最常见的情况是让“填充”标志生成重复的单词，效果类似于 perl 的 <code>x</code> 运算符（对于不熟悉 perl 的人，表达式 <code>"string" x 3</code> 产生字符串 <code>stringstringstring</code>。在这里，你需要记住你指定的填充宽度是总宽度，而不是重复次数，所以你需要将它乘以字符串的长度：</p>
<pre><code>  % print ${(l.18..string.)}
  stringstringstring
</code></pre>
<p>[]{#l128}</p>
<h3 id="548-嵌套参数替换"><a class="header" href="#548-嵌套参数替换">5.4.8: 嵌套参数替换</a></h3>
<p>Zsh 有一个用于多个嵌套参数替换的系统。而在大多数 shell 或其他脚本语言中，你会做类似这样的事情：</p>
<pre><code>  % p=/directory/file.ext
  % p2=${p##*/}            # 从头部移除最长的 */ 匹配
  % print $p2
  file.ext
  % print ${p%.*}          # 从尾部移除最短的 .* 匹配
  file
</code></pre>
<p>在 zsh 中，你可以在一次替换中完成这个：</p>
<pre><code>  % p=/directory/file.ext
  % print ${${p##*/}%.*}
  file
</code></pre>
<p>省去了中间的临时参数。（同样，在这种特殊情况下，你更可能使用 <code>${p:t:r}</code>。）当 <code>$p</code> 是一个数组时，这就成了一个主要优势：所有的替换都应用于数组的每个元素：</p>
<pre><code>  % p=(/dir1/file1.ext1 /dir2/file2.ext2)
  % print ${${p##*/}%.*}
  file1 file2
</code></pre>
<p>这可以大大减少处理数组的代码。这是一种绕过事实的方法，即像 zsh 这样的普通命令行界面，最初是为与用户直接交互而设计的，没有像 perl 这样的非交互式语言的所有复杂性，perl 的 <code>map</code> 函数可能是做同样事情的最简洁方法：</p>
<pre><code>   # Perl 代码。
   @p = qw(/dir1/file1.ext1 /dir2/file2.ext2);
   @q = map { m%^(?:.*/)(.*?)(?:\.[^.]*|)$%; } @p;
   print "@q\n";'
</code></pre>
<p>或无数可能的变体。在 shell 中，没有办法将那样的函数放入命令行而不使基本的“命令，参数”语法复杂化；所以我们求助于替换的技巧。然而，请注意，这种程度的简洁性即使在 Perl 中也会导致一定的可读性缺乏。此外，zsh 对常见情况进行了如此优化，以至于</p>
<pre><code>  print ${p:t:r}
</code></pre>
<p>对于数组和标量都有效：<code>:t</code> 只取文件名的尾部，去掉目录，<code>:r</code> 移除后缀。在 4.0.1 之前的 zsh 版本中，这两个运算符可能会有稍微意想不到的效果，例如移除包含目录路径的“后缀”（尽管这也是单独采用的模式形式所做的）。</p>
<p>注意嵌套替换的一个特性：你可能期望 <code>${...}</code> 在另一个内部会做一个完整的参数替换，以便外部的那个会对那个的值起作用——毕竟，如果替换是独立的，你会得到那个。然而，事实并非如此：内部的 <code>${...}</code> 只是一个语法技巧，表示“这里有更多对参数的操作”。这意味着</p>
<pre><code>  bar='这不会被替换'
  foo='bar'
  print ${${foo}}
</code></pre>
<p>只是打印 <code>bar</code>，而不是 <code>$bar</code> 的值。这是我们之前遇到的同样的情况，但没有任何额外的 <code>##</code> 和 <code>%</code> 部分。原因是历史性的：当添加非常有用的嵌套替换功能时，让前导的 <code>$</code> 向 shell 表明它应该再次调用替换函数，比找到另一种语法要简单得多。你可以使用上面描述的 <code>(P)</code> 替换标志，使该值被重新解释为另一个参数替换。只要记住 <code>${${foo}}</code> 和 <code>${(P)foo}</code> 是不同的。</p>
<p>[]{#l129}</p>
<h2 id="55-再谈那个替换"><a class="header" href="#55-再谈那个替换">5.5: 再谈那个替换</a></h2>
<p>最后，这里简要解释一下如何阅读本章开头的表达式。这只适用于高级学生（在我看来是疯子）。如果你足够努力，你可以在手册中找到所有的部分，甚至是我没有讲到的那些。举个例子，让我们假设数组包含</p>
<pre><code>  array=(long longer longest short brief)
</code></pre>
<p>看看</p>
<pre><code>  print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}
</code></pre>
<p>会给出什么。</p>
<ol>
<li>
<p>总是从内部开始。这里最里面的表达式是</p>
<pre><code>    ${(O@)array//?/X}
</code></pre>
<p>不太清楚？再从内部开始：这里有我们正在操作的参数，它的名字是 <code>array</code>。在它前面，括号里有两个标志：(<code>O</code>) 表示按降序字母顺序对结果进行排序，(<code>@</code>) 将结果视为一个数组，这是必要的，因为这个内部替换发生在一个通常是标量值（实际上是一个算术表达式）的地方，我们需要取一个数组元素。在数组名之后，<code>//?/X</code> 是一个全局替换：取模式 <code>?</code>（任何字符）出现的地方，并用字符串 <code>X</code> 替换它。这个的结果是一个像 <code>$array</code> 的数组，但所有元素都变成了由 <code>X</code> 组成的字符串，代替了原始字符，并且最长的排在最前面，因为对于具有相同字符的字符串，反向字母顺序就是这样工作的。所以</p>
<pre><code>    long longer longest short brief
</code></pre>
<p>会变成</p>
<pre><code>    XXXXXXX XXXXXX XXXXX XXXXX XXXX
</code></pre>
</li>
<li>
<p>接下来，我们有 <code>${#</code><em>result</em><code>[1]}</code> 包围着那个。那意味着我们取上面得到的数组的第一个元素（<code>[1]</code>：这就是为什么我们必须确保它被当作一个数组），然后取它的长度（<code>#</code>）。在这种情况下，我们最终会得到 7，即第一个（也是最长的）元素的长度。我们终于有所进展了。</p>
</li>
<li>
<p>下一步是 <code>${</code>(<code>l.</code><em>result</em><code>..?.</code>)<code>}</code>。我们之前的 <em>result</em> 作为 <code>(l)</code> 标志的参数出现。这是一个相当特殊的嵌套替换情况：在这一点上，shell 期望一个算术表达式，给出要向左填充的字符串的最小长度。之前的替换被评估了，因为算术表达式会进行参数替换。所以是那个的结果，7，出现在这里，给出了更易于管理的</p>
<pre><code>    ${(l.7..?.)}
</code></pre>
<p><code>(l)</code> 标志的完整表达式表示“将此参数替换的结果填充到最小宽度为 7，使用填充字符 <code>?</code>”。我们正在填充什么替换？它是空的：zsh 足够聪明，当你没有给出参数名时，它会假设你知道你在做什么，并只放入一个空字符串。所以空字符串被填充到长度 7，用问号填充，得到 <code>???????</code>。</p>
</li>
<li>
<p>现在我们有 <code>${array[(r)???????]}</code>。可能不明显（如果其余的都明显，恭喜你），但问号作为模式是活动的。下标在这方面是特殊的。下标标志 <code>(r)</code> 意味着“反向匹配”，不是向后的反向，而是相反的方式：在数组本身中搜索匹配的值，而不是将此作为索引。唯一能匹配这个的是一个长度为 7 的字符串。宾果！在这种情况下，那必须是元素“longest”。如果还有其他相同长度的元素，你只会得到那个长度的第一个；我还没有想出一种方法可以用单个表达式替换所有那个长度的元素，而不将 <code>$array</code> 变成一个关联数组，所以如果你有，你应该感到得意。</p>
</li>
</ol>
<p>我写完这个之后，Sven Wischnowsky（他负责补全函数中大部分类似的象形文字）指出，实现这个的一个类似方法是：</p>
<pre><code>  print ${(M)array:#${~${(O@)array//?/?}[1]}}
</code></pre>
<p>这确实显示了最大长度的所有元素。简要总结一下它的工作原理是，最里面的表达式产生一个对应于元素的 <code>?</code> 数组，最长的排在最前面，就像我们上面做的那样，将 <code>?</code> 变成模式匹配字符。下一个展开选择最长的。最后，最外层的展开遍历 <code>$array</code> 以查找与完整的 <code>?</code> 字符串匹配的元素，并选出那些匹配的。</p>
<p>如果你想知道如何在 perl 中用单个表达式做到这一点，可能按长度排序是最简单的：</p>
<pre><code>  # Perl 代码
  @array = qw(long longer longest short brief);
  @array = sort { length $b &lt;=&gt; length $a } @array;
</code></pre>
<p>然后取出 <code>@array</code> 的第一个或前几个元素。然而，在一个高度优化的脚本语言中，你几乎肯定会用其他方式来做：例如，避免排序，只记住最长的元素：</p>
<pre><code>  # Perl 代码
  $elt = '';
  $l = 0;
  foreach (@array) {
    $newl = length $_;
    $elt = $_, $l = $newl  if $l &gt; $newl;
  }
  print $elt, "\n";
</code></pre>
<p>在这种情况下，你可以在 zsh 中很容易地做同样的事情；</p>
<pre><code>  local val elt
  integer l newl
  for val in $array; do
    newl=${#val}
    if (( newl &gt; l )); then
      elt=$val
      (( l = newl ))
    fi
  done
  print $elt
</code></pre>
<p>所以这可能不是嵌套替换的一个特别好的用途，即使它说明了它的强大。</p>
<p>如果你喜欢那个表达式，补全函数套件中还有很多类似的供你惊叹。</p>
<p>[]{#l130}</p>
<h2 id="56-算术展开"><a class="header" href="#56-算术展开">5.6: 算术展开</a></h2>
<p>在 shell 内部进行数学运算最初是在<a href="zshguide03.html#syntax">第三章</a>中描述的，在那里我展示了如何用 <code>typeset</code> 的变体创建数值参数，并对算术替换说了一点。</p>
<p>除了可以用 <code>zmodload zsh/mathfunc</code> 加载的数学库，zsh 基本上拥有你期望从 C 和其他源自它的语言中得到的所有运算符。换句话说，像</p>
<pre><code>  (( foo = bar ? 3 : 1, ++brr ))
</code></pre>
<p>这样的东西是被接受的。逗号运算符的工作方式与 C 中完全相同；所有参数都被求值，在这种情况下，<code>foo = bar ? 3 : 1</code> 根据 <code>bar</code> 是否非零将 3 或 1 赋给 <code>$foo</code>，然后 <code>$brr</code> 增加 1。返回状态由最后的表达式决定，所以如果 <code>$brr</code> 在增加后为零，返回状态为一，否则为零（整数可以是负数）。</p>
<p>一个额外的运算符是从 FORTRAN 或许是 Perl 借来的，即求幂运算符 <code>**</code>。它可以接受整数或浮点数，尽管负指数会导致返回一个浮点数，所以 <code>$(( 2 ** -1 ))</code> 给你 0.5，而不是向下取整到零。这就是为什么标准库函数 <code>pow</code> 在 <code>zsh/mathfunc</code> 中缺失的原因——它已经以那种其他形式存在了。然而，纯整数求幂是通过重复乘法完成的——直到任意大小，所以 вместо <code>2 ** 100</code>，你应该使用 <code>1 &lt;&lt; 100</code>，对于任何其他整数的幂，如果你不需要精确结果，你应该使用浮点数。为此，<code>zsh/mathfunc</code> 库提供了“类型转换”；<code>float</code>(<em>num</em>)<code>强制表达式 *num* 被解释为一个浮点数，无论它本来会给出什么，尽管给一个数加上</code>0.0<code> 的技巧也有效。请注意，虽然这像 C 中的类型转换一样工作，但语法是普通函数调用的语法。同样，</code>int<code>(*num*)</code> 使该数被解释为一个整数——向零取整；你可以使用 <code>floor</code> 和 <code>ceil</code> 来向下或向上取整，<code>rint</code> 来四舍五入到最近的整数，尽管这三个实际上产生浮点数。它们是标准的 C 库函数。</p>
<p>为了完整起见，求幂的赋值形式 <code>**=</code> 也有效。我不记得用过它。</p>
<p>整数的范围取决于你的机器上 zsh 是如何配置的。主要目标是确保整数足够大以表示文件中的索引；在一些硬件通常处理 32 位整数的系统上，文件大小可能由 64 位整数给出，zsh 也会尝试使用 64 位整数。然而，即使没有大文件支持，zsh 也会测试大整数；通常它只要求你的编译器有一些易于识别的定义 64 位整数的方式，比如 <code>long long</code>，即使本地编译器不支持，gcc 也可能处理。你可以很容易地测试；如果你的 zsh 支持 64 位整数，可用的最大整数是：</p>
<pre><code>  % print $(( 0x7FFFFFFFFFFFFFFF ))
  9223372036854775807
</code></pre>
<p>如果你尝试给那个数加上一个正数，你会因为二进制补码算术而得到一个负数结果。这应该足够大来计算大多数东西了。</p>
<p>浮点数的范围总是 C 语言 <code>double</code> 的范围，通常也是 64 位，内部数字很可能采用 IEEE 标准形式，这也影响了你能得到的精度和范围，尽管那也是系统特定的。在大多数系统上，数学库函数处理 <code>double</code> 而不是单精度 <code>float</code>，所以这是自然的选择。类型转换函数被称为 <code>float</code>，因为与 C 不同，浮点数的表示是为你选择的，所以使用了通用名称。</p>
<p>[]{#l131}</p>
<h3 id="561-输入和输出基数"><a class="header" href="#561-输入和输出基数">5.6.1: 输入和输出基数</a></h3>
<p>我将说一两句关于基数的话。我已经说过你可以用像 <code>2#101010</code> 或 <code>16#ffff</code> 这样的形式输入任何小基数的数字，并且后者也可以是 <code>0xffff</code>，就像在 C 中一样。然而，你不能仅仅通过使用前导的 <code>0</code> 来输入八进制数，这可能是你从 C 中所期望的。这里有一个例子说明为什么不行。让我们设置：</p>
<pre><code>  % foo=${(%):-%D}
  % print $foo
  01-08-06
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="zshguide04.cn.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="zshguide06.cn.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="zshguide04.cn.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="zshguide06.cn.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
