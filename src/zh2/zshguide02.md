------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide01.html)
-   [下一章](zshguide03.html)

------------------------------------------------------------------------

[]{#init}[]{#l6}

# 第2章：在启动文件中放置什么

你可能希望对shell的行为进行各种更改。所有shell都有"启动"文件，其中包含在shell启动时执行的命令。像许多其他shell一样，zsh允许每个用户拥有自己的启动文件。在本章中，我将讨论你可能希望在其中放置的内容类型。这将作为shell功能的介绍；到结束时，你应该对稍后将详细讨论的许多内容以及它们为什么有趣有所了解。有时你会发现比你想知道的更多，比如zsh与其他你不会使用的shell有何不同。在这里解释这些差异可以省去我 later 再纠正关于shell如何工作的谎言：大多数人只想知道shell通常如何工作，并注意到有其他方法可以做到这一点。

[]{#l7}

## 2.1: shell类型：交互式和登录shell

首先，你需要了解**交互式**和**登录**shell的含义。基本上，shell只是在那里接收一系列命令并运行它们；它并不关心命令是在文件中还是在终端上输入的。在第二种情况下，当你在提示符下输入并等待每个命令运行时，shell是**交互式**的；在另一种情况下，当shell从文件中读取命令时，它就是**非交互式**的。以第二种方式使用的命令列表——通常通过输入类似`zsh filename`的内容（尽管有快捷方式）——被称为**脚本**，好像shell在阅读它时在演戏一样（shell在演戏时可以是真正的ham）。当你从键盘启动脚本时，实际上有两个zsh：你正在输入的交互式zsh，它正在等待另一个非交互式zsh完成运行脚本。第二个中几乎没有任何事情会影响第一个；它们是zsh的不同副本。

记住，当我给出要你输入的示例时，我经常像它们在脚本中出现的样子显示它们，前面没有提示符。如果你实际输入它们，你在屏幕上看到的内容前面会有很多东西。

当你第一次登录计算机时，你看到的shell是交互式的，但它也是一个登录shell。如果你输入`zsh`，它会启动一个新的交互式shell：因为你没有给它一个包含命令的文件名，它假定你将交互式地输入它们。现在你有两个交互式shell，一个等待另一个：这听起来似乎没用，但有时你会对shell的设置进行一些激进的临时更改，最简单的方法是启动另一个shell，做你想做的事，然后退出回到原始的、未更改的shell——所以这并不像听起来那么愚蠢。

然而，第二个shell将不是登录shell。zsh如何知道区别？好吧，登录程序在你输入密码后登录（可预测地称为**login**），实际上会在shell名称前加上`-`，zsh会识别这一点。另一种使shell成为登录shell的方法是使用`-l`选项运行它自己；输入`zsh -l`将启动一个zsh，它也认为自己是登录shell，稍后我将解释如何在shell中打开选项，你也可以使用登录选项做到这一点。否则，你自己启动的任何zsh都不会是登录shell。如果你使用X-Windows，并且有一个终端模拟器如xterm运行shell，那可能不是登录shell。然而，实际上可以通过给xterm选项`-ls`让它启动登录shell，所以如果你输入`xterm -ls &`，你将得到一个运行登录shell的窗口（`&`表示第一个窗口中的shell不会等待它完成）。

登录shell和任何其他交互式shell之间的第一个主要区别是与启动文件有关的，如下所述。另一个是当你完成时做什么。使用登录shell你可以输入`logout`退出shell；使用另一个你可以输入`exit`。然而，`exit`适用于所有shell，交互式、非交互式、登录shell，无论什么，所以很多人只使用它。实际上，唯一的区别是如果你在其他地方使用它并退出失败，`logout`会告诉你`not login shell`。命令`bye`与`exit`相同，只是更短且不太标准。所以我的建议只是使用`exit`。

正如最近有人指出给我的，登录shell不一定是交互式的。你总是可以通过两种方式启动shell使其成为登录shell；使shell成为交互式或非交互式的方式是独立的。实际上，一些窗口系统启动脚本运行一个非交互式登录shell，在执行启动窗口会话的命令之前包含来自适当登录脚本的定义。

[]{#l8}

### 2.1.1: 什么是登录shell？简单测试

判断你正在查看的shell是否是交互式的通常很容易：如果有提示符，它是交互式的。正如你可能已经收集到的，判断它是否是登录shell更复杂，因为你并不总是知道shell是如何启动的或者选项是否被更改了。如果你想了解，你可以输入以下内容（一次一行如果你愿意，见下文），

      if [[ -o login ]]; then
        print yes
      else
        print no
      fi

这将根据它是否是登录shell打印"yes"或"no"；语法将在我们进行时解释。有更短的方法来做到这一点，但这说明了测试事物的最常见的shell语法，这是你在启动文件中可能经常想要做的。你要测试的内容放在`[[ ... ]]`内；在这种情况下，`-o`告诉shell测试一个选项，这里是`login`。下一行说明测试成功时要做什么；`else`之后的行说明测试失败时要做什么。这种语法与ksh几乎相同；在本指南中，我不会给出关于你可以执行的测试的详尽细节，因为有很多，但只展示一些最有用的。一如既往，参见手册——在这种情况下，`zshmisc`手册页中的"条件表达式"。

虽然你通常知道shell何时是交互式的，但实际上你也可以用完全相同的方式测试：只需使用`[[ -o interactive ]]`。这是你不能在shell中更改的一个选项；如果你关闭从键盘读取，shell应该从哪里读取？但你至少可以测试它。

给初学者的旁注：也许分号看起来有点奇怪；那是因为`then`实际上是一个单独的命令。分号只是代替了把它放在新行上；这两者是可互换的。实际上，我可以写，

      if [[ -o login ]]; then; print yes; else; print no; fi

这做完全相同的事情。我甚至可以省略`then`和`else`后面的分号，因为shell知道每个后面必须跟一个命令——尽管`then`之前的分号或换行符通常是重要的，因为shell不知道接下来必须跟一个命令，并且可能会把`then`与`if`之后的命令参数混淆：这看起来很奇怪，但`[[` *...* `]]`实际上是一个命令。所以在shell程序中你会看到各种分割行的方式。你可能还想知道`print`是之前提到的内置命令之一；换句话说，整个程序块由shell本身执行。如果你使用的是shell的新版本，你会注意到zsh会告诉你它在等待什么，即`then`或`else`子句——参见下面关于`$PS2`的解释了解更多。最后，我在`print`命令前放的空格只是为了使它看起来更漂亮；在命令和参数之前、之后或之间可以出现任意数量的空格，只要普通单词之间（分号被识别为特殊字符，所以你在它之前不需要一个，尽管如果你放了一个也无害）至少有一个空格。

给sh用户的第二个旁注：你可能记得sh中的测试使用了一对方括号，`if [ ... ]; then ...`，或者等效地作为一个叫做**test**的命令，`if test ...; then ...`。Korn shell被故意设计成不同，zsh遵循这一点。原因是`[[`被特别处理，这允许shell做一些额外的检查并允许更自然的语法。例如，你可能知道在sh中测试可能为空的参数是危险的：`[ $var = foo ]`如果`$var`为空将失败，因为在这种情况下单词被省略了，shell永远不会知道它应该在那里；使用`[[` *...* `]]`，这是完全安全的，因为shell知道在`=`之前有一个单词，即使它是空的。此外，你可以使用`&&`和`||`表示逻辑"与"和"或"，这符合通常的UNIX/C约定；在sh中，它们会被当作开始一个新命令，而不是测试的一部分，你必须使用不太清楚的`-a`和`-o`。实际上，zsh提供旧形式的测试以保持向后兼容性，但如果你不使用它，事情会顺利得多。

[]{#l9}

## 2.2: 所有启动文件

现在这里是启动文件列表以及它们何时运行。你会看到它们分为两类：`/etc`目录中的那些，由系统管理员放置并为所有用户运行，以及你主目录中的那些，zsh像许多shell一样允许你将其缩写为`~`。后者的文件可能在其他地方；输入`print $ZDOTDIR`，如果你得到除空行或告诉参数未设置的错误消息之外的内容，它会告诉你`~`之外的目录，你的启动文件在那里。如果`$ZDOTDIR`（另一个参数）尚未设置，除非有充分理由，否则你不会想要设置它。

**`/etc/zshenv`**
:   始终为每个zsh运行。

**`~/.zshenv`**
:   通常为每个zsh运行（见下文）。

**`/etc/zprofile`**
:   为登录shell运行。

**`~/.zprofile`**
:   为登录shell运行。

**`/etc/zshrc`**
:   为交互式shell运行。

**`~/.zshrc`**
:   为交互式shell运行。

**`/etc/zlogin`**
:   为登录shell运行。

**`~/.zlogin`**
:   为登录shell运行。

现在你知道登录和交互式shell是什么，这应该很简单。你可能想知道为什么同时有`~/.zprofile`和`~/.zlogin`，当它们都是为登录shell时：答案是显而易见的，一个在`~/.zshrc`之前运行，一个在之后运行。这是历史性的；Bourne-type shell运行`/etc/profile`，csh-type shell运行`~/.login`，zsh试图通过自己的启动文件覆盖基础。

复杂性在"见下文"中暗示。文件`/etc/zshenv`，如所述，总是在任何zsh开始时运行。然而，如果设置了选项`NO_RCS`（或等效地，`RCS`选项未设置：我稍后会谈论选项，因为它们在启动文件中很重要），则不运行其他任何文件。设置此选项的最常见方法是在命令行上使用标志：如果你启动shell为`zsh -f`，该选项变为设置，因此只运行`/etc/zshenv`，跳过其他文件。通常，脚本这样做作为一种尝试获得基本shell而没有花哨功能的方法，正如我稍后将描述的；但如果在`/etc/zshenv`中设置了某些内容，则无法避免它。这导致了Zsh管理的第一定律：在文件`/etc/zshenv`中放置尽可能少的内容，因为每个启动的zsh都必须读取它。特别是，如果脚本假定只设置了基本选项而`/etc/zshenv`改变了它们，它可能根本无法工作。所以，至少你应该可能用以下内容包围`/etc/zshenv`中的选项设置

      if [[ ! -o norcs ]]; then
        ... <commands to run if NO_RCS is not set, 
             such as setting options> ...
      fi

你的用户将永远感激。交互式shell的设置，如提示符，在`/etc/zshenv`中没有业务，除非你*真的*坚持所有用户都将它们作为每个shell的默认值。想要绕过`/etc/zshenv`中选项更改问题的脚本编写者应该在脚本顶部放置`emulate zsh`。

有两个文件在末尾运行：`~/.zlogout`和`/etc/zlogout`，按此顺序。正如它们的名称所示，它们是`zlogin`文件的对应物，因此只在登录shell中运行——尽管你可以通过设置`login`选项欺骗shell。请注意，无论你使用`exit`、`bye`还是`logout`离开shell都不会影响这些文件是否运行：我这次没有撒谎（这次）当我说`exit`和`logout`之间的唯一区别是错误消息。如果你想在任何其他类型的shell结束时运行文件，你可以用另一种方式做到：

      TRAPEXIT() {
        # commands to run here, e.g. if you 
        # always want to run .zlogout:
        if [[ ! -o login ]]; then
          # don't do this in a login shell
          # because it happens anyway
          . ~/.zlogout
        fi
      }

如果你把它放在`.zshrc`中，它将强制在所有交互式shell结束时运行`.zlogout`。稍后将提到陷阱，但这更像是一个一次性事件；它实际上只是让命令在shell结束时运行的一种技巧。然而，我不会谈论注销文件，因为没有什么标准内容可以放在其中；有些人用`clear`命令清除屏幕以删除敏感信息。除此之外，你可能需要在退出时清理一些文件。

[]{#l10}

## 2.3: 选项

是时候谈谈选项了，因为我已经提到了几次。每个选项描述一个特定的shell行为；它们都是布尔值，即可以是开启或关闭，没有其他状态。它们有短名称，在文档和本指南中它们用大写书写，下划线分隔各部分（除了在实际代码中，我将用短形式书写）。然而，这两者都不是必需的。实际上，`NO_RCS`和`norcs`和`__N_o_R_c_S__`意思相同，都被shell接受。

第二件事是带有`no`前缀的选项只是没有前缀选项的反面。我也可以将测试`[[ ! -o norcs ]]`写成`[[ -o rcs ]]`；`!`表示"非"，如C语言中。你只能有一个`no`；`nonorcs`是无意义的。不幸的是，有一个选项`NOMATCH`，其基本名称中有`no`，所以在这种情况下反面真的是`NO_NOMATCH`；`NOTIFY`当然也是它自己的完整名称。

设置和取消设置选项的常用方法是使用命令**setopt**和**unsetopt**，它们接受一串选项名称。一些选项也有标志，如`NO_RCS`的`-f`，这些命令也接受，但使用完整名称更清楚，额外的时间和空间可以忽略不计。命令`set -o`等同于`setopt`；这来自ksh。请注意，不带`-o`的`set`做其他事情——它设置位置参数，这是zsh传递参数给脚本和函数的方式。

几乎每个人都会在他们的启动文件中设置一些选项。由于你希望它们在每个交互式shell中，至少在`~/.zshrc`或`~/.zshenv`中放置它们的选择。选择真正取决于你如何使用非交互式shell。它们可以在意想不到的地方启动。例如，如果你使用Emacs并在其中运行命令，如**grep**，那将启动一个非交互式shell，可能需要一些选项。我的经验法则是尽可能多地将选项放入`~/.zshrc`，如果我发现需要它们，则将它们转移到`~/.zshenv`。一些纯粹主义者反对在`~/.zshenv`中设置选项，因为它会影响脚本；但正如我已经暗示的，你必须更努力地工作以确保脚本不受那种事情的影响。在以下内容中，我假设它们将在`~/.zshrc`中。

[]{#l11}

## 2.4: 参数

你需要了解的另一件事是参数，也称为变量，以便编写启动文件。这些大多像其他编程语言中的变量。简单参数可以像这样存储（一个**赋值**）：

      foo='This is a parameter.'

注意两件事：首先，在`=`前后没有空格。如果前面有空格，zsh会认为`foo`是要执行的命令名称；如果后面有空格，它会将空字符串赋值给参数`foo`。其次，注意使用引号来防止字符串内的空格产生相同的效果。单引号，如这里，是引号的核选项：直到另一个单引号之前的所有内容都被视为简单字符串——换行符、等号、不可打印字符，所有这些，在这个例子中都会被赋值给变量；例如，

      foo='This is a parameter.
      This is still the same parameter.'

所以它们是当你还不知道如何处理双引号时使用的最佳选择。有时你不需要它们，例如，

      foo=oneword

因为`oneword`中没有会混淆shell的内容；但你仍然可以在那里放引号。

csh用户应该注意，你不要使用`set`来设置参数。这很重要，因为有一个`set`命令，但它工作方式不同——如果你尝试`set var="this wont't work"`，你不会得到错误但你也不会设置参数。输入`print $1`看看你实际上设置了什么。

要获取存储在参数中的内容，你使用名称在命令行的某处加上`$`前缀——这称为**扩展**，或者更准确地说，由于有其他类型的扩展，称为**参数扩展**。例如，在上面的第一个赋值之后。

      print -- '$foo is "'$foo'"'

给出

      $foo is "This is a parameter."

所以你可以看到我关于单引号效果的意思。注意不对称性——赋值参数时没有`$`，但扩展时前面有`$`。你可能有时会看到使用"替换"而不是"扩展"；我会尽量坚持手册中的术语。

还有两件事。首先，为什么我在`print`后面放了`--`？这是因为**print**，像许多UNIX命令一样，可以在它之后接受以`-`开头的选项。`--`表示没有更多选项；所以如果你试图打印的内容以`-`开头，它仍然会打印出来。实际上，在这种情况下你可以看到它没有，所以你是安全的；但养成这个习惯是好的，我希望我有。一如既往在zsh中，有例外；例如，如果你在`--`之前使用`-R`选项打印，它只识别BSD风格的选项，这意味着它不理解`--`。实际上，zsh程序员可以相当宽松地对待标准，并且经常使用旧的但现在已经不标准的单`-`来表示没有更多选项。目前，即使在`-R`之后这也有效。

下一点是我没有在单引号和`$foo`之间放空格，它仍然被扩展了——扩展发生在参数未被引用的任何地方；它不必单独存在，只需与可能使其看起来像不同参数的任何东西分开。这是使shell脚本看起来如此野蛮的事情之一。

除了定义你自己的参数外，还有一些shell自己设置的参数，以及其他一些在你设置它们时有特殊效果的参数。以上所有内容仍然适用。在本指南的其余部分，我将用`$`前缀指示参数，以提醒你它们是什么，但你应该记住在设置它们时或实际上任何时候当指参数名称而不是其值时，`$`是缺失的。

[]{#l12}

### 2.4.1: 数组

有一种特殊类型的参数叫做**数组**，zsh从ksh和csh继承而来。这是有点不稳定的婚姻，因为这两种shell使用它们的一些方式不兼容，zsh有两者的元素，所以如果你在任一者中使用过数组，你需要小心。选项`KSH_ARRAYS`是你可以设置的东西，使它们表现得更像它们在ksh中的行为，但许多zsh用户编写函数和脚本时假设它没有设置，所以这可能是危险的。

与普通参数（称为**标量**）不同，数组中有多个单词。在上面的例子中，我们让参数`$foo`得到一个有空格的字符串，但空格并不重要。如果我们做了

      foo=(This is a parameter.)

（注意缺少引号），它会创建一个数组。同样，在`=`和`(`之间必须没有空格，尽管在括号内空格像在命令行上一样分隔单词。如果你试图打印它，区别并不明显——看起来完全一样——但现在试试这个：

      print -- ${foo[4]}

你会得到`parameter.`。数组单独存储单词，你可以通过将数组元素的编号放在方括号中单独检索它们。还请注意大括号`{...}`——zsh并不总是需要它们，但当事情变得复杂时，它们会使事情更清楚，而且放进去永远不会错：你可以说`${foo}`当你想要打印完整参数时，它会被视为与`$foo`相同。大括号只是将扩展与可能混淆shell的其他任何东西隔离开来。在表达式如`${foo}s`中也很有用，以保持`s`不成为参数名称的一部分；最后，在设置了`KSH_ARRAYS`的情况下，大括号是强制性的，尽管不幸的是在这种情况下数组从0开始索引。

在定义数组时可以使用引号；和以前一样，这保护了shell认为空格是数组的不同元素。试试：

      foo=('first element' 'second element')
      print -- ${foo[2]}

数组在shell需要将一系列不同的东西保持在一起时很有用，所以我们将在启动文件中遇到一些你可能想要放置的数组。ksh用户会注意到zsh中的事情有些不同，但现在我假设你使用正常的zsh做事方式。

[]{#l13}

## 2.5: 在启动文件中放置什么

在最后一次计数时，有超过130个选项和几十个对shell特殊的参数，其中许多涉及我稍后才会谈论的事情。但作为让你开始的指南，并指示即将发生的事情，这里有一些你可能想要考虑在`~/.zshrc`中设置的选项和参数。

[]{#l14}

### 2.5.1: 兼容性选项：`SH_WORD_SPLIT`和其他

我已经提到zsh与ksh（其最近的标准亲属）的工作方式不同，其中一些差异可能会让新用户感到困惑，例如数组的使用。一些选项如`KSH_ARRAYS`存在，以允许你以ksh方式做事。其中大多数相当琐碎，但有一个让很多人陷入困境。上面，我说在

      foo='This is a parameter.'

然后`$foo`将被视为一个单词。在包括sh、ksh和bash在内的传统Bourne-like shell中，然而，shell将在它找到的任何空格处分割`$foo`。所以如果你运行一个命令

      command $foo

然后在zsh中命令得到单个参数`This is a parameter.`，但在其他shell中它得到第一个参数`This`，第二个参数`is`，依此类推。如果你喜欢这样，或者你已经习惯了它，改变起来会令人困惑，你应该在你的`~/.zshrc`中设置选项`SH_WORD_SPLIT`。大多数有经验的zsh用户在他们想要单词分割时使用数组，因为正如我解释的那样，你可以控制什么被分割什么不被分割；这就是为什么默认情况下不设置`SH_WORD_SPLIT`。其他shell的用户只是习惯于将东西放在双引号中，

      command "$foo"

这与单引号不同，允许`$`保持特殊，并且有副作用，即引号中的任何内容将保持为单个单词（尽管对此也有例外：参数`$@`）。

还有很多其他选项做类似的事情以让标准shell用户满意。其中许多只是关闭功能，因为其他shell没有它们，因此可能会发生意外的事情，或者只是调整一个略有不同或通常无关紧要的功能。目前这样的选项包括`NO_BANG_HIST`、`BSD_ECHO`（仅sh）、`IGNORE_BRACES`、`INTERACTIVE_COMMENTS`、`KSH_OPTION_PRINT`、`NO_MULTIOS`、`POSIX_BUILTINS`、`PROMPT_BANG`、`SINGLE_LINE_ZLE`（我已经按照它们作为`setopt`参数出现的方式编写了它们，以使选项按其他shell期望的方式设置，所以有些前面有`NO_`）。大多数人可能不会改变这些，除非他们注意到某些东西没有按预期工作。

其他一些有更明显的效果。以下是一些最可能让你在从另一个Bourne-like shell改变时挠头的选项。

**`BARE_GLOB QUAL`, `GLOB_SUBST`, `SH_FILE_EXPANSION`, `SH_GLOB`, `KSH_GLOB`**\

这些都是关于模式匹配如何工作的。你可能已经知道模式`*.c`将扩展为当前目录中以`.c`结尾的所有文件。像这样的简单用法在所有shell中都是相同的，文件名扩展的方式通常被称为"globbing"，出于历史原因（显然它代表"全局替换"），因此这些选项中有此名称。

然而，zsh和ksh在更复杂的模式上有所不同。例如，要匹配文件`foo.c`或文件`bar.c`，在ksh中你会说`@(foo|bar).c`。通常的zsh做事方式是`(foo|bar).c`。要打开ksh做事方式，设置选项`KSH_GLOB`；要关闭zsh方式，设置选项`SH_GLOB`和`NO_BARE_GLOB_QUAL`。最后那些关闭**限定符**，这是一种非常强大的通过类型（例如，目录或可执行文件）而不是通过名称选择文件的方式，我将在[第5章](zshguide05.html#subst)中讨论。

其他两个需要更多解释。试试这个：

      foo='*'
      print $foo

在zsh中，你通常会得到一个`*`被打印，而在ksh中`*`被扩展为目录中的所有文件，就像你输入了`print *`一样。这有点像`SH_WORD_SPLIT`，因为ksh假装`$foo`的值出现在命令行上，就像你输入它一样，而zsh使用你分配给`foo`的值而不允许它再被更改。要在zsh中也允许单词被扩展，你可以设置选项`GLOB_SUBST`。和`SH_WORD_SPLIT`一样，如果你不想改变值而绕过ksh行为的方法是使用双引号：`"$foo"`。

你不太可能需要担心`SH_FILE_EXPANSION`。它确定shell何时扩展像`~/.zshrc`到完整路径，例如`/home/user2/pws/.zshrc`。在zsh的情况下，这通常在相当晚的时候完成，在大多数其他形式的扩展如参数扩展之后。这意味着如果你设置了`GLOB_SUBST`并执行

      foo='~/.zshrc'
      print $foo

你通常会看到完整路径，以`/`开头。然而，如果你*也*设置了`SH_FILE_EXPANSION`，`~`在更早的时候被测试，在`$foo`被替换之前（那时还没有），所以`~/.zshrc`会被打印。这（与两个选项一起）是ksh的工作方式。这也意味着我撒谎了当我说ksh对待`$foo`就像它的值被输入一样，因为如果你输入`print ~/.zshrc`，`~`确实被扩展了。所以你可以看到撒谎是多么方便。

**`NOMATCH`, `BAD_PATTERN`**\

这些也与产生文件名的模式有关，但在这种情况下它们确定当模式由于某种原因不匹配文件时会发生什么。有两种可能的原因：要么没有文件碰巧匹配，要么你没有使用正确的模式。在这两种情况下，zsh与ksh不同，会打印错误消息。例如，

      % print nosuchfile*
      zsh: no matches found: nosuchfile*
      % print [-
      zsh: bad pattern: [-

（记住`%`行是你输入的内容，前面有来自shell的提示符。）你可以看到有两个不同的错误消息：你可以通过设置`NO_NOMATCH`停止第一个，通过设置`NO_BAD_PATTERN`停止第二个。在这两种情况下，这使得shell在没有匹配文件时打印出你最初输入的内容而没有任何扩展。

**`BG_NICE`, `NOTIFY`**\

所有UNIX shell都允许你通过在行尾放置`&`来启动*后台*作业；然后shell不会等待作业完成，所以你可以输入其他内容。在zsh中，这样的作业通常以较低优先级（在UNIX术语中是"更高nice值"）运行，这样它们不会像前台作业（所有其他没有`&`的作业）那样使用那么多处理器时间。这是为了让编辑或使用shell等作业不会变慢，这可能非常令人烦恼。你可以通过设置`NO_BG_NICE`来关闭此功能。

当后台作业完成时，zsh通常会立即通过打印消息告诉你，这会打断你正在做的事情。你可以通过设置`NO_NOTIFY`来停止这种情况。实际上，这在大多数版本的ksh中也是一个选项，但在zsh中稍微不那么烦人，因为如果它在你向shell输入其他内容时发生，shell会重新打印你已经输入到的行。例如：

      % sleep 3 &
      [1] 40366
      % print The quick brown
      [1]  + 40366 done       sleep 3
      % print The quick brown

命令sleep只是在你告诉它的秒数内什么都不做，但在这里它在后台做了（zsh打印了一条消息告诉你）。在你输入三秒钟后，作业退出了，并且设置了`NOTIFY`它打印了另一条消息：`done`是关键，因为它告诉你作业已经完成。但zsh足够聪明知道显示被搞乱了，所以它重新打印了你正在编辑的行，你可以继续。如果你已经在前台运行另一个程序，然而，它不会知道zsh打印了消息，所以显示仍然会被搞乱。

**`HUP`**\

信号是说服作业做它不想做的事情的方式，比如死亡；当你输入`^C`时，它发送一个信号（在这种情况下称为`SIGINT`）给作业。在zsh中，如果你在shell退出时有后台作业运行，shell会假设你想要杀死它；在这种情况下它被发送一个特定的信号叫做`SIGHUP`，代表"挂断"（像电话，不像伍迪·艾伦），这是UNIX中"该回家了"的等价物。如果你经常启动应该在shell退出后继续运行的作业，那么你可以设置选项`NO_HUP`，后台作业将被单独留下。

**`KSH_ARRAYS`**\

我已经提到了这一点，但这里是细节。假设你定义了一个数组`arr`，例如用

      arr=(foo bar)

尽管ksh中的语法，zsh也允许，

      set -A arr foo bar

在zsh中，`$arr`给出整个数组；在ksh中它只产生第一个元素。在zsh中，`${arr[1]}`指的是数组的第一个元素，即`foo`，而在ksh中第一个元素被称为`${arr[0]}`，所以`${arr[1]}`给你`bar`。最后，在zsh中你可以逃脱使用`$arr[1]`来指代一个元素，而ksh坚持使用大括号。通过设置`KSH_ARRAYS`，zsh将切换到ksh做事方式。这是你需要在编写函数和脚本时特别小心的一个选项。

**`FUNCTION_ARG_ZERO`**\

Shell函数是指定一组由shell运行的命令的有用方法。这里有一个简单例子：

      % fn() { print My name is $0; }
      % fn
      My name is fn

注意特殊语法：`()`出现在函数名称后表示你正在定义一个，然后一组命令出现在`{ ... }`之间。当你输入函数名称时，这些命令被执行。如果你知道编程语言C，语法会很熟悉，尽管注意`()`有点错觉：你可能认为你会在那里放函数的参数，但你不能，它必须总是简单地出现为`()`。如果你不知道C，没关系；C中的任何东西实际上都不适用细节，这只是表面上的相似。

在这种情况下，zsh打印特殊参数`$0`（"参数零"）并且如你所见，这变成了函数的名称。现在`$0`在函数外意味着壳的名称，或非交互式shell的脚本名称，所以如果你输入`print $0`它可能会说`zsh`。在大多数版本的ksh中，这是`$0`的唯一用途；它在函数中不会改变，`fn`会打印`ksh`。要获得这种行为，你可以设置`NO_FUNCTION_ARG_ZERO`。可能没有理由让你这样做，但zsh函数经常测试自己的名称，所以这是它们可能不工作的一个原因。

在定义函数时还有另一个差异，不管`FUNCTION_ARG_ZERO`如何：在zsh中，你可以在`fn`定义的末尾没有`;`的情况下逃脱，因为它知道`}`必须结束最后一个命令以及函数；但ksh在这里不那么宽容。许多语法专家可能能够告诉你为什么这是件好事，但幸运的是我不能。

**`KSH_AUTOLOAD`**\

ksh和zsh中都有一个加载函数的简单方法。而不是把它们都放在一个大的启动文件中，你可以在其中放一行，

      autoload fn

函数`fn`只有在你通过输入其名称作为命令来运行它时才会被加载。shell需要知道函数存储在哪里。这是通过一个叫做`$fpath`的特殊参数完成的，一个目录列表数组；它将在所有目录中搜索名为`fn`的文件，并使用它作为函数定义。如果你想试试这个你可以输入`autoload fn; fpath=(. $fpath)`并在当前目录中写一个名为`fn`的文件。

不幸的是ksh和zsh在那个文件中应该包含什么上有些分歧。正常的zsh做事方式只是把函数的主体放在那里。所以如果文件`fn`是可自动加载的并且包含，

      # this is a simple function
      print My name is $0

然后输入`fn`将与上面的函数`fn`有完全相同的效果，打印`My name is fn`。Zsh用户倾向于喜欢这个，因为函数的编写方式与脚本相同；如果你改为输入`zsh fn`，以自己的新zsh副本来调用文件作为脚本，它会以相同的方式工作。第一行是注释；它被忽略，并且在zsh中在函数运行时甚至不会被自动加载，所以添加解释性内容不仅更清楚，而且也不会使用更多内存。当然，它使用更多磁盘空间，但如今即使是家用PC也有足够大的磁盘空间让你在可读性上有点放纵。

然而，ksh做事方式不同，这里的文件`fn`需要包含

      fn() {
        # this is a simple function
        print My name is $0
      }

换句话说，正是你定义函数时会输入的内容。这种形式的优点是你可以把其他东西放在文件中，这些将在运行时立即执行并被遗忘，比如定义`fn`可能需要使用但不需要每次运行`fn`时都重新定义的东西。强制zsh以ksh方式在这里工作的选项叫做`KSH_AUTOLOAD`。（如果你想尝试第二个例子，你需要输入`unfunction fn; autoload fn`以从内存中移除函数并再次标记为自动加载。）

实际上，zsh更聪明一些。如果选项`KSH_AUTOLOAD`未设置，但文件包含以ksh形式的函数定义且没有其他内容（像上面最后一个例子），那么zsh假设它需要立即运行刚刚加载的函数。另一种可能性是你要定义一个除了定义同名函数外什么都不做的函数，这被假定为不太可能——如果你真的想这样做，你需要通过在同一文件中放置一个无作用命令来欺骗zsh，比如在最后一行放置一个`:`。

最后的复杂情况——抱歉，但这种情况确实会发生——是有时在zsh中你不仅想定义要调用的函数，还想定义一些帮助它的函数。那么你需要这样做：

      fn() {
        # this is the function after which the file is named
      }
      helper() {
        # goodness knows what this does
      }
      fn "$@"
      # this actually calls the function the first time,
      # with any arguments passed (see the subsection
      # `Function Parameters' in the section `Functions'
      # of the next chapter for the "$@").

如果没有`KSH_AUTOLOAD`，最后一行非注释是不必要的。随zsh提供的函数假设`KSH_AUTOLOAD`未设置，因此除非你需要，否则不应打开它。你可以像往常一样将`fn`做成整个主体，并在其中定义`helper`；问题是`helper`将在每次执行`fn`时被重新定义，这是低效的。避免问题的更好方法是将helper定义为一个完全独立的函数，本身是自动加载的：在zsh和ksh中，函数是在另一个函数内部还是外部定义没有区别，这与（例如）Pascal或Scheme不同。

**`LOCAL_OPTIONS`, `LOCAL_TRAPS`**\

这两个选项也涉及函数，这里的ksh做事方式通常是可取的，所以许多人在他们的许多函数中至少设置`LOCAL_OPTIONS`。zsh的早期版本没有这些，这就是为什么你需要手动打开它们。

如果在函数中设置`LOCAL_OPTIONS`（或者在函数之前已经设置但未在其中取消设置），那么在函数内部更改的任何选项将在函数完成时恢复原状。所以

      fn() {
        setopt localoptions kshglob
        ...
      }

允许你使用ksh globbing语法的函数，但会确保选项`KSH_GLOB`在函数退出时恢复到原来的设置。即使函数被`^C`中断，这也能工作。请注意，`LOCAL_OPTIONS`本身也会恢复到原来的方式。

选项`LOCAL_TRAPS`，首次出现在版本3.1.6中，出于类似原因但涉及（猜猜看）**陷阱**，这是停止发送给shell的信号的方法，例如通过输入`^C`取消某事（`SIGINT`，简称"信号中断"），或`^Z`暂时挂起它（`SIGTSTP`，"信号终端停止"），或我们已经遇到的`SIGHUP`等等。要做自己的事情当shell收到`^C`时，你可以做

      trap 'print I caught a SIGINT' INT

并且引号中的命令集将在`^C`到达时运行（你甚至可以在不运行任何东西的情况下尝试）。如果字符串为空（只是`''`里面没有任何东西），信号将被忽略；输入`^C`没有效果。要把它恢复正常，命令是`trap - INT`。

陷阱在函数中最有用，你可能临时（比如）不想在你击中`^C`时停止事情，或者你可能想在从函数返回之前清理一些东西。所以现在你可以猜到`LOCAL_TRAPS`做什么；用

      fn() {
        setopt localoptions localtraps
        trap '' INT
        ...
      }

shell将忽略函数结束时的`^C`，但然后恢复之前的陷阱，或者如果之前没有则完全移除它。陷阱在[第3章](zshguide03.html#syntax)中有更详细的描述。

有一个非常方便的速记方法来使选项和陷阱本地化，以及设置其他选项到标准值：在函数开始放置`emulate -L zsh`。这将选项值设置回zsh启动时的设置，但同时也设置了`LOCAL_OPTIONS`和`LOCAL_TRAPS`，所以你现在确切知道在函数的其余部分事情将如何工作，无论外部世界设置了什么选项。实际上，这只改变了影响正常编程的选项；你可以使用`emulate -RL zsh`将每个有设置意义的选项设置为其标准值（例如，此时更改像`login`这样的选项没有意义）。此外，你可以通过执行`emulate -L ksh`使shell尽可能像ksh一样工作，无论有没有`-R`。

`emulate`的`-L`选项实际上只出现在3.0.6和3.1.6版本中。在此之前你需要

      emulate zsh
      setopt localoptions

因为`localtraps`不存在，而且实际上在3.0.6中也不存在。

**`PROMPT_PERCENT`, `PROMPT_SUBST`**\

如承诺的，设置提示符将在稍后讨论，但现在有两种方法可以将信息放入提示符中，例如参数`$PS1`，它决定了在新命令行开始时的通常提示符。一种是使用*百分比转义*，这意味着一个`%`后跟另一个字符，可能在两个字符之间有一个数字。例如，默认的zsh提示符是`%m%# `。第一个百分比转义变成主机计算机的名称，第二个通常变成`%`，但对于超级用户是`#`。然而，ksh没有这些，所以你可以通过设置`NO_PROMPT_PERCENT`来关闭它们。

另一方面，ksh的通常做事方式是通过在提示符中放置参数来替换。要让zsh这样做，你必须设置`PROMPT_SUBST`。然后分配

      PS1='${PWD}% '

是将当前目录名称（`$PWD`显然以命令`pwd`来"打印工作目录"命名）放入提示符的另一种方式。注意单引号，所以当提示符显示时才会发生这种情况，而不是在分配时。如果它们不在那里，或为双引号，则`$PWD`将在分配时扩展到目录，可能是你的主目录，并且不会改变以反映你实际所在的目录。当然，你也需要引号来处理空格，否则它在执行分配时会被吞掉。

由于参数中潜在的信息比预定义的百分比转义多得多，你可能无论如何都想设置`PROMPT_SUBST`。此外，你可以通过其他形式的扩展将命令的输出放入提示符，不仅仅是参数扩展；实际上，带有`PROMPT_SUBST`的提示符在每次显示提示符时都像双引号内的字符串一样扩展。

**`RM_STAR_SILENT`**\

每个人在某个时候或另一个都会删除比他们想要的更多的文件（而且*那是*严重的 understatement）；我最喜欢的是：

      rm *>o

那个`>`应该是`.`，但我仍然按着shift键。这会删除所有文件，将输出（没有）回显到文件`o`中。令人愉快的是，空文件`o`不会被删除。（不要在家尝试这个。）

zsh中内置了一种保护机制来阻止你意外删除目录中的所有文件。如果zsh发现命令是`rm`，并且命令行上有`*`（可能还有其他东西），那么它会问你是否真的想删除所有这些文件。你可以通过设置`RM_STAR_SILENT`来关闭它。过度依赖此选项是个坏主意；它只是最后一道防线。

**`SH_OPTION_LETTERS`**\

许多选项也有单个字母来代表它们；你可以通过例如`set -f`来设置一个选项，这设置了`NO_RCS`。然而，即使sh、ksh和zsh共享选项，也不是所有选项都有相同的字母。这个选项允许单字母选项更像sh和ksh中的那些。如果你想知道，查阅手册，但我已经建议你无论如何使用选项的全名。

**`SH_WORD_SPLIT`**\

我已经谈过了，见上文，但这里提到它是为了不让你忘记它，因为这是一个重要的差异。

**以ksh启动zsh**\

最后关于兼容性，你可能想知道除了`emulate`之外还有另一种方法迫使zsh尽可能像sh或ksh一样行为。这是通过实际上以ksh的名称调用zsh。你不需要重命名zsh，你可以制作一个从名称zsh到名称ksh的链接，这就足够了。

当你在zsh内部这样做时有一个更简单的方法。参数`$ARGV0`是特殊的；它是作为shell运行的命令的第一个参数传递的值。通常这是命令的名称，但它不必是，因为命令只有在已经运行之后才知道它是什么。你可以用它来欺骗程序认为它的名字不同。所以

      ARGV0=ksh zsh

将启动一个试图让自己像ksh的zsh副本。请注意，除非你已经在zsh中，否则这不会起作用，因为`$ARGV0`不会特殊。

我没有提到在命令名称前放置参数赋值，但这只是为命令持续时间分配参数（严格来说是环境变量）；`$ARGV0`的值在该命令（ksh-like zsh）完成后不会被设置，你可以用`print`轻松测试。在这里，我应该提到它的一些其他功能。首先，参数自动导出到环境，意味着它对zsh启动的其他程序（包括在这种情况下新的zsh）可用——参见下面关于环境变量的部分。其次，这不会做你可能期望的事情：

      FOO=bar print $FOO

因为扩展的顺序：命令行及其参数在执行前被扩展，给出`$FOO`之前的任何值，可能是无，然后FOO=bar被放入环境，然后执行命令但不使用`$FOO`的新值。

[]{#l15}

### 2.5.2: csh爱好者的选项

除了老ksh用户外，还有一些选项可以让老csh和tcsh用户感觉更自在。正如你已经注意到的，语法非常不同，所以你永远不会完全感觉自在，最好只是记住这个事实。但这里是一个简短的列表。最后一个，`CSH_NULL_GLOB`，实际上相当有用。

**`CSH_JUNKIE_HISTORY`**\

Zsh有旧的csh机制，用于使用`!`引用先前命令行上的单词；现在编辑器更强大了，所以不太常用，但仍然是提取前一行短位的便捷速记。这种机制有时被称为**bang-history**，因为忙碌的人有时喜欢说`!`为`bang`。这个选项影响单个`!`如何工作。例如，

      % print foo bar
      % print open closed
      % print !-2:1 !:2

在最后一行，`!-2`意味着两步前，即行`print foo bar`。`:1`选择命令后的第一个单词，即`foo`。在第二个表达式中，`!`后没有给出数字。通常zsh解释为选择刚刚选择的相同项，在这种情况下是-2。设置了`CSH_JUNKIE_HISTORY`，它反而指代最后一个命令。请注意，如果你没有给出那个-2，它无论如何都会指代最后一个命令，尽管显式指代最后一个命令的方式是`!!`——如果你后面没有`:``位，你需要使用它。总之，zsh通常给你`print foo bar`；使用`CSH_JUNKIE_HISTORY`你得到`print foo closed`。

还有另一个控制这个的选项，`BANG_HIST`。如果你取消设置它，该机制将完全不起作用。还有一个参数，`$histchars`。第一个字符是主要的历史扩展字符，当然是`!`；第二个是快速替换的字符（通常是`^`——使用方法如下所述）；第三个是引入注释的字符，通常是`#`。强烈不建议更改第三个字符。实际上没有真正理由更改任何字符。

**`CSH_JUNKIE_LOOPS`**\

正常的zsh循环看起来像这样，

      while true; do
        print Never-ending story
      done

这只会一遍又一遍地打印消息（如果你愿意，可以逐行在提示符下输入，然后`^C`停止它）。设置了`CSH_JUNKIE_LOOPS`，你可以改为做

      while true
        print Never-ending story
      end

这当然会使你的zsh代码与大多数其他人的不同，所以对大多数用户来说最好学习正确的语法。

**`CSH_NULL_GLOB`**\

这是`NO_NOMATCH`家族的另一个选项，已经提到过。在这种情况下，如果你有一行命令由一组模式组成，至少有一个必须匹配至少一个文件，否则会导致错误；任何不匹配的都会从命令行中删除。默认是所有都必须匹配。这个集合中还有最后一个选项，`NULL_GLOB`：所有不匹配的模式都从命令行中删除，不会导致错误。作为总结，假设你输入命令`print file1* file2*`并且目录只包含文件`file1.c`。

1.  默认情况下，必须有文件匹配两个模式，所以报告错误。
2.  设置了`NO_NOMATCH`，任何不匹配的模式都被保留，所以打印`file1.c file2*`。
3.  设置了`CSH_NULL_GLOB`，`file1*`匹配，所以`file2*`被静默删除；报告`file1.c`。如果那不在那里，会报告错误。
4.  设置了`NULL_GLOB`，任何不匹配的模式都被删除，所以再次打印`file1.c`，但在这种情况下如果那不在那里，会打印一个空白行，没有错误。

`CSH_NULL_GLOB`是件好事，因为它可以让你走上正轨而不会太多不必要的错误消息，所以这次它不仅仅是为了csh爱好者。

**`CSH_JUNKIE_QUOTES`**\

这里只是为了完整性。Csh及其朋友不允许多行引号，如zsh可以；如果你在新行前不完成一对引号，csh会抱怨。这个选项使zsh也这样做。但多行引号非常有用且在zsh脚本和函数中非常常见；这只是为那些被csh使用真正弄乱头脑的人准备的。

[]{#l16}

### 2.5.3: 历史机制：历史类型

"历史机制"这个名字指的是zsh保存你输入的命令的"历史"。有三种方法可以获取这些；所有这些都使用相同的命令行集，但获取它们的机制相当不同。出于某种原因，历史列表中的项目（一次输入并执行的完整输入行）被称为"事件"。

**直接编辑历史**\

首先，你可以使用编辑器；通常按上箭头会带你到前一行，下箭头带你回来。这通常是最简单的方法，因为你可以看到你确切在做什么。我将在[第4章](zshguide04.html#zle)中详细说更多关于编辑器的内容；首先要知道的是它的基本命令像emacs或vi一样工作，所以如果你知道其中一个，你可以立即开始编辑行。shell会尝试从环境变量`$VISUAL`或`$EDITOR`中猜测使用emacs还是vi，按此顺序；这些传统上保存你偏爱的编辑器名称，供需要你编辑文本的程序使用。在旧时代，`$VISUAL`是全屏编辑器，`$EDITOR`是行编辑器，像记忆中的`ed`，但现在区别非常模糊。如果其中任何一个包含字符串`vi`，行编辑器将以vi模式启动，否则将以emacs模式启动。如果你在错误的模式下，`~/.zshrc`中的`bindkey -e`带你到emacs模式，`bindkey -v`到vi模式。对于vi用户，要记住的是你以插入模式开始，所以输入`ESC`以能够输入vi命令。

**`Bang`-历史**\

第二，你可以使用csh-style `bang-history`机制（除非你设置了选项`NO_BANG_HIST`）；`bang`是感叹号`!`，也被称为`pling`或`shriek`（或阶乘，但那是另一个故事）。因此`!!`检索上一个命令行并执行它；`!-2`检索倒数第二个。你可以选择单词：`!!:1`选择上一个命令的第一个单词（如果你上面注意了，你会注意到你只需要一个`!`在这种情况下）；`0`在冒号后选择命令词本身；`*`选择命令后的所有参数；`$`选择最后一个单词。你甚至可以有范围：`!!:1-3`选择那三个单词，像`!!:3-$`这样的东西也有效。

在单词选择器之后，你可以有第二组冒号，然后是一些称为**修饰符**的特殊命令——这些非常有用要记住，因为它们可以应用到参数和文件模式上，所以这里有一些更多细节。`:t`（尾部）修饰符选择文件名的最后一部分，斜杠后的所有内容；相反，`:h`（头部）选择之前的所有内容。所以用历史条目，

      % print /usr/bin/cat
      /usr/bin/cat
      % print !!:t
      print cat
      cat

注意两件事：首先，bang-history机制总是打印它即将执行的内容。其次，你不需要单词选择器；shell可以知道`:t`是一个修饰符，并假设你想将其应用到整个前一个命令。（在这里要小心，因为实际上`:t`会将表达式减少到*任何*单词中最后一个斜杠后的所有内容，这有点出乎意料。）

用参数：

      % foo=/usr/bin/cat
      % print ${foo:h}
      /usr/bin

（你通常可以省略`{`和`}`，但有它们更清楚和安全）。最后用文件——如果你为sh-like行为设置了`NO_BARE_GLOB QUAL`，这将不起作用：

      % print /usr/bin/cat(:t)
      cat

你在哪里需要括号告诉shell`:t`不是文件名的一部分。

完整列表见`zshexpn`手册，或手册的打印版或Info版本中的`Modifiers`部分，但这里有一些更有用的。`:r`移除文件的后缀，将`file.c`变成`file`；`:l`和`:u`使单词全部小写或全部大写；`:s/foo/bar/`将单词中的第一个`foo`替换为`bar`；`:gs/foo/bar`替换所有出现的（`g`代表全局）；`:&`重复上次这样的替换，即使你在前一行做了；`:g&`也有效。所以

      % print this is this line
      this is this line
      % !!:s/this/that/
      print that is this line
      that is this line
      % print this is no longer this line
      this is no longer this line
      % !!:g&
      print that is no longer that line
      that is no longer that line

最后，有一个快捷方式：`^old^new^`完全等同于`!!:s/old/new/`；你甚至可以在它后面放另一个修饰符。`^`实际上是上面提到的`$histchars`的第二个字符。如果后面没有其他东西要跟，你可以省略最后一个`^`。顺便说一下，你可以把修饰符放在一起，但每个都需要冒号：`:t:r`应用于`dir/file.c`产生`file`，重复应用`:h`会让你得到越来越短的路径。

在我们离开bang-history之前，请注意选项`HIST_VERIFY`。如果设置了它，那么替换后该行会再次出现并带有更改，而不是立即打印和执行。因为你只需要输入`<RET>`来执行它，这是一个有用的技巧来保存你执行错误的东西，这在复杂的bang-history行上很容易发生；我自己设置了这个。

最后一个提示：shell的扩展和完成，我稍后会详细描述，允许你通过在输入完整引用后立即按`TAB`来立即扩展bang-history引用，你通常可以按control连同斜杠（在某些键盘上，你被限制为`^Xu`）将其恢复到原来的样子，如果你不喜欢结果——这是编辑器的"撤销"功能的一部分。

**Ksh-style历史命令**\

第三种历史形式使用`fc`内置命令。这是最麻烦的：你必须告诉命令执行哪些完整行，并且可能给你机会先编辑它们（但使用外部编辑器，而不是在shell中）。你可能不会以这种方式使用它，但有三件事实际上由`fc`控制，你可能会使用：首先，`r`命令重复上一个命令（忽略`r`），这有点像`!!`。其次，叫做`history`的命令实际上也是`fc`的伪装。它给你最近命令的列表。它们旁边有数字；你可以用这些代替使用负数来向后计数，就像我最初解释的那样，优势是它们不会随着你输入更多命令而改变。你可以给`history`一个数字范围，第一个数字用于开始列出的地方，第二个数字用于停止的地方：一个特定的例子是`history 1`，它列出所有命令（即使它仍然记住的第一个命令高于1；它只是默默地省略所有那些）。`fc`的第三个用途是读取和写入你的历史，这样你就可以在会话之间保留它。

[]{#l17}

### 2.5.4: 设置历史

实际上，shell能够在不被告诉的情况下读取和写入历史。但是你需要告诉它在哪里保存历史，为此你必须将参数`$HISTFILE`设置为你想要使用的文件名（常见选择是`~/.history`）。接下来，你需要将参数`$SAVEHIST`设置为你想要保存的历史行数。当这两个被设置时，shell将在交互式会话开始时从`$HISTFILE`读取`$HISTSIZE`行，并在会话结束时保存你执行的最后`$SAVEHIST`行。要让它在中间读取或写入，你需要设置下面描述的选项之一（`INC_APPEND_HISTORY`和`SHARE_HISTORY`），或者使用`fc`命令：`fc -R`和`fc -W`分别读取和写入历史，而`fc -A`将其追加到文件（尽管如果它比`$SAVEHIST`长则修剪它）；`fc -WI`和`fc -AI`是相似的，但`I`表示只写出自上次写入历史以来的事件。

还有第三个参数`$HISTSIZE`，它确定shell在一个会话中将保留的行数；除了我不会谈论的特殊原因，你应该将`$SAVEHIST`设置为不超过`$HISTSIZE`，尽管它可以更少。`$HISTSIZE`的默认值是30，这对于今天计算机的内存和磁盘空间来说有点吝啬；zsh用户经常使用高达1000。所以在`.zshrc`中设置的一组简单参数是

      HISTSIZE=1000
      SAVEHIST=1000
      HISTFILE=~/.history

这足以让事情运转起来。请注意，你*必须*设置`$SAVEHIST`和`$HISTFILE`以使自动读取和写入历史行工作。

[]{#l18}

### 2.5.5: 历史选项

还有许多影响历史的选项；这些在版本3.1.6中大幅增加，首次提供了`INC_APPEND_HISTORY`、`SHARE_HISTORY`、`HIST_EXPIRE_DUPS_FIRST`、`HIST_IGNORE_ALL_DUPS`、`HIST_SAVE_NO_DUPS`和`HIST_NO_FUNCTIONS`。我已经描述了`BANG_HIST`、`CSH_JUNKIE_HISTORY`和`HIST_VERIFY`，我不会再谈它们。

**`APPEND_HISTORY`, `INC_APPEND_HISTORY`, `SHARE_HISTORY`**\

通常，当它写入历史文件时，zsh只是覆盖那里的一切。`APPEND_HISTORY`允许它将新历史附加到旧历史。shell会努力不去写入应该已经在那里存在的行；如果你有很多zsh在不同窗口中同时运行，这会变得复杂。这个选项对大多数人来说是个好选择。`INC_APPEND_HISTORY`意味着不是在shell退出时这样做，而是在执行时以这种方式将每行添加到历史中；这意味着，例如，如果你在主shell中启动一个zsh，它的历史将看起来像主shell的历史，这相当有用。这也意味着同时运行的不同shell的命令排序更加合乎逻辑——基本上就是它们被执行的顺序——所以在3.1.6及更高版本中推荐这个选项。

`SHARE_HISTORY`更进一步：当添加每行时，检查历史文件看是否有其他shell写入了什么，如果有，则也包含在当前shell的历史中。这意味着在不同窗口但同一主机（或更一般地说，同一主目录）上运行的zsh共享相同的历史。请注意，zsh试图不通过意外的历史条目弹出来混淆你：如果你使用`!`-style历史，来自其他会话的命令在你显式输入`history`命令显示它们之前不会出现在历史列表中，所以你可以确定你实际重新执行的是什么命令。Korn shell总是表现得好像设置了`SHARE_HISTORY`，可能是因为它不在内部存储历史。

**`EXTENDED_HISTORY`**\

这使历史条目的格式更加复杂：除了仅仅命令，它还保存命令开始的时间和运行时间。`history`命令有三个使用这个的选项：`history -d`打印命令的开始时间；`history -f`打印那个以及日期；`history -D`（你可以与`-f`或`-d`结合使用）打印命令的经过时间。日期格式可以用`-E`改为欧洲（*日*.*月*.*年*）和`-i`改为国际（*年*-*月*-*日*）格式。你不想要设置这个的主要原因将是磁盘空间短缺，或者因为你希望你的历史文件被另一个shell读取。

**`HIST_IGNORE_DUPS`, `HIST_IGNORE_ALL_DUPS`, `HIST_EXPIRE_DUPS_FIRST`, `HIST_SAVE_NO_DUPS`, `HIST_FIND_NO_DUPS`**\

这些选项给出了处理历史中经常出现的重复行的方法。最简单的是`HIST_IGNORE_DUPS`，它告诉shell如果它与前一行相同，则不存储历史行，从而将许多重复命令折叠为一行；这是一个非常好的选项。当重复行不相邻时它什么也不做，所以例如交替的命令对总是被存储。接下来的两个选项可以在这里帮助：`HIST_IGNORE_ALL_DUPS`只是删除仍在历史列表中的行的副本，保留新添加的行，而`HIST_EXPIRE_DUPS_FIRST`更微妙：它在历史填满时优先删除重复项，但在那之前什么也不做。`HIST_SAVE_NO_DUPS`意味着无论当前会话设置了什么选项，shell都不会多次保存重复行；而`HIST_FIND_NO_DUPS`意味着即使重复行已被保存，向后搜索的编辑器命令也不会多次显示它们。

**`HIST_ALLOW_CLOBBER`, `HIST_REDUCE_BLANKS`**\

这些允许历史机制在输入行时对它们进行更改。第一个影响输出重定向，你使用符号`>`将命令或命令集的输出重定向到命名文件，或使用`>>`将输出追加到该文件。如果你设置了`NO_CLOBBER`选项，那么

      touch newfile
      echo hello >newfile

失败，因为`touch`命令创建了`newfile`，`NO_CLOBBER`不会让你在下一行覆盖（破坏）它。使用`HIST_ALLOW_CLOBBER`，第二行在历史中显示为

      echo hello >|newfile

其中`>|`覆盖`NO_CLOBBER`。所以要绕过`NO_CLOBBER`，你可以只需回到前一行并执行它而无需编辑。

第二个选项，`HIST_REDUCE_BLANKS`，将通过在输入历史时删除任何对shell没有意义的多余空白来整理行。这也意味着该行可能变成与前一行重复，即使在未整理的形式下不会是这样。它足够聪明不会删除重要的空白，即被引用的空白。

**`HIST_IGNORE_SPACE`, `HIST_NO_STORE`, `HIST_NO_FUNCTIONS`**\

这三个选项允许你说某些行根本不应该进入历史。`HIST_IGNORE_SPACE`意味着以空格开头的行不会进入历史；想法是你故意输入一个空格，这对shell没有其他意义，然后再输入任何你希望立即被遗忘的行。在zsh 4.0.1中，这被实现为即使你立即回忆前一行进行编辑也可以；但当下一行被执行并输入历史时，以空格开头的行被遗忘。

`HIST_NO_STORE`告诉shell不要存储`history`或`fc`命令。而`HIST_NO_FUNCTIONS`告诉它不要存储函数定义，因为这些虽然通常不频繁，但可能令人厌烦地长。函数定义是以`function funcname {...`或`funcname () { ...`开头的任何东西。

**`NO_HIST_BEEP`**\

最后，`HIST_BEEP`在编辑器中使用：如果你试图向上或向下滚动超出历史列表的末尾，shell会发出哔哔声。默认情况下它是开启的，所以使用`NO_HIST_BEEP`来关闭它。

[]{#l19}

### 2.5.6: 提示符

大多数人在`.zshrc`中有一些定义来改变你在每行开始时看到的提示符。我已经提到了`PROMPT_PERCENT`（默认设置）和`PROMPT_SUBST`（默认未设置）；我在这里假设你没有改变这些设置，并指出使用**提示符转义**的一些可能性，以`%`开头的序列。如果你变得非常复杂，你可能需要打开`PROMPT_SUBST`。

主要提示符在名为`$PS1`或`$PROMPT`或`$prompt`的参数中；有所有这些名称的原因是历史性的——它们来自不同的shell——所以我只坚持最短的。还有`$RPS1`，在屏幕右侧打印提示符。这样做的意义是，如果你输入足够远以至于碰到它，它会自动消失，所以它可以帮助充分利用空间来显示像目录这样的长东西。

`$PS2`在shell等待更多输入时显示，即它知道到目前为止你输入的内容不是完整行：它可能包含引用表达式的开始，但没有结束，或者包含尚未完成的某些语法结构的开始。通常你会保持它与`$PS1`不同，但在所有五个提示符中都理解相同的转义。

`$PS3`在shell的`select`机制启动的循环中显示，当shell想要你输入选择时：见`zshmisc`手册页，因为我不会说太多关于这个。

`$PS4`在调试时很有用：有一个选项`XTRACE`，它使shell在执行前打印出行，前面是`$PS4`。只有从版本3.1.6开始它才开始以与其它提示符相同的方式替换，尽管这被证明非常有用——见下面列表中的"脚本或函数中的位置"。

这里有一些你可能想在提示符中包含的东西。请注意，你可以通过使用`print -P`来尝试这个：这扩展字符串就像它们在提示符中一样。你可能需要将字符串放在单引号中。

**时间**\

Zsh允许你使用百分比转义以许多不同的方式将时间放入提示符中。最简单的是`%t`和`%T`，12小时和24小时格式的时间，以及`%*`，与`%T`相同但带秒；你也可以有日期如`Wed 22`使用`%w`，如`9/22/99`（美国格式）使用%W，或如`99-09-22`（国际格式）使用%D。然而，有另一种使用%D的方法来获得更多可能性：后面的字符串用大括号括起来，`%D{...}`可以包含一组完全不同的百分比转义，所有这些都指时间日期的元素。在大多数系统上，`strftime`函数的文档会告诉你这些是什么。zsh有它自己的几个，给定在`zshmisc`手册页的`PROMPT EXPANSION`部分。例如，我使用`%D{%L:%M}`，它给出小时和分钟的时间，小时为1到9的单个数字；在我看来更亲切。

你可以通过使用`%`(*numX*.*true*.*false*)语法获得更多乐趣，其中*X*是`t`或`T`之一。对于`t`，如果分钟时间与*num*（默认为零）相同，则*true*用作提示符的这部分文本，否则使用*false*。`T`对小时做同样的事。因此

      PS1='%(t.Ding!.%D{%L:%M})%# '

在整点时打印消息`Ding!`，否则打印更传统的时间。`%#`是标准序列，如果超级用户（root），打印`#`，否则为每个人打印`%`，这出现在许多人的提示符中。同样，你可以使用`%(`30t.Dong!.`\...`在半小时时获得消息。

**当前目录**\

序列`%~`打印目录，任何主目录或命名目录（见下文）缩短为以`~`开头的形式；序列`%/`不这样做缩短，所以通常`%~`更好。目录可以很长，有各种方法处理它。首先，如果你使用窗口系统，你可以将目录放在标题栏中，而不是窗口内的任何地方。第二，你可以使用`$RPS1`，当你在它附近输入时它会消失。第三，你可以从`%~`或`%/`中挑选段，通过在`%`后给它们一个数字：例如，`%1~`只挑选当前目录路径的最后一段。

第四种方法给你最多的控制。提示符或提示符的部分，不仅仅是显示目录的部分，可以被截断为你选择的任何长度。要从左侧截断路径，使用类似`%10<`*\...*`<%~`的东西。这样工作：`%<``<`是截断的基本形式。10在`%`后说以下任何内容都限制为10个字符，字符`*\...*`在提示符否则会更长时显示（你可以让它为空）。这适用于以下任何内容，所以现在`%~`不能超过10个字符，否则它将被截断（到7个字符，一旦`...`被打印）。你可以用`%<``<`关闭截断，即`%`后没有数字；然后截断适用于在打开和关闭之间区域的整个部分（这与旧版本的zsh改变了，其中它只适用于单个`%`结构）。

**你在等什么？**\

提示符`$PS2`在shell等待你完成输入某物时出现，知道你到目前为止输入的不是完整的行是有用的。序列`%_`显示这个。它是默认`$PS2`的一部分，即`%_> `。因此，如果你输入`if true; then`和`<RET>`，提示符会说`then> `。你也可以在跟踪提示符`$PS4`中使用它，以显示关于在脚本或函数中执行的内容的相同信息，尽管因为那里通常有足够的信息（如下所述），它不是默认的一部分。在这种情况下，`%`后的数字将限制显示的深度，所以`%1_`只提到了最近的东西。

**脚本或函数中的位置**\

默认的`$PS4`包含`%N`和`%i`，它们告诉你最近开始的函数、脚本或源文件的名称，以及在其中执行的行号；它们在其他提示符中不太有用。然而，`$PS1`中的`%i`会告诉你当前的交互行号，zsh会跟踪它，尽管通常不显示给你；参数`$LINENO`包含相同的信息。

关于`%i`的另一点是显示的行号适用于首次读入的函数版本，而不是它在`functions`命令中出现的方式，后者是整理过的。然而，如果你使用自动加载函数，包含函数的文件通常是你想要修改的，所以在调试时这不应该是一个问题。

记住，`$PS4`显示只在设置了`XTRACE`选项时发生；由于选项可能对函数是本地的，对脚本总是如此，你通常需要在你要调试的任何东西的顶部放置一个显式的`setopt xtrace`。或者，你可以使用`typeset -ft` *funcname*为该函数打开跟踪（我刚刚发现的东西）；使用`typeset +ft` *funcname*再次关闭它。

**其他零散的东西**\

在`zshmisc`手册页中有许多其他百分比转义描述，大多简单明了。例如，`%h`显示历史条目号，如果你使用bang-history很有用；`%m`显示当前主机名到任何点；`%n`显示用户名。

还有两个我自己碰巧使用的其他功能。首先，有时知道上一个命令何时失败是很方便的。每个命令返回一个状态，这是一个数字：零表示成功，其他数字表示某种失败。你可以从参数`$?`或`$status`（再次，它们指的是同一件事）得到这个。它在提示符中也可用为`%?`，还有我为时间描述的带括号的所谓"三元"表达式之一，根据测试选择不同的字符串。这里的测试是，合理地，`%(`?...`。把这两个放在一起，你可以得到只在退出状态非零时显示的消息；我在数字周围加了一组额外的括号，只是为了更清楚，其中`)`需要变成`%)`以停止它标记组的结束：

      PS1='%(?..(%?%))%# '

有时也知道你是否在子shell中也很方便，也就是说如果你通过输入`zsh`在主shell中启动了另一个shell。你可以通过使用另一个三元表达式来做到这一点：

      PS1='%(2L.+.)%# '

这检查参数`SHLVL`，每次新zsh启动时都会递增，所以如果已经有一个运行（这将设置`SHLVL`为1），它现在将是2；如果`SHLVL`至少为2，则在提示符前额外打印一个`+`，否则什么都不打印。如果你使用窗口系统，你可能需要将2变成3，因为在你第一次登录时可能已经有一个zsh运行，所以窗口中的shell已经有`SHLVL`设置为2。这在很大程度上取决于你的窗口系统如何设置；找出更多留作读者练习。

**颜色**\

许多终端现在可以显示颜色，在提示符中放入这些颜色以区别于周围文本是相当有用的。我经常发现一个程序刚刚在我的终端上输出了一大堆内容，而不太明显它从哪里开始。能够找到提示符之前的内容帮助很大。

颜色，像粗体或下划线文本一样，使用不移动光标的转义序列。在提示符中插入任何此类转义序列的黄金规则是在开始用`%{`包围，在结束用`%}`。否则，shell会对行的长度感到困惑。这影响当行编辑器需要重画行时发生的事情，也改变右提示符`$RPS1`的位置，如果你使用它的话。你不需要用特殊序列`%B`和`%b`，它们开始和停止粗体文本，因为shell已经知道如何处理这些；只有随机字符，碰巧你知道不移动光标，尽管shell不知道，才会引起问题。

在颜色的情况下，有一个shell函数`colors`随标准发行版提供来帮助你。当加载并运行时，它定义关联数组参数`$fg`和`$bg`，你用它们来提取给定颜色的转义序列，例如`${fg[red]}${bg[yellow]}`产生红字黄背景的序列。所以例如，

      PS1="%{${bg[white]}${fg[red]}%}%(?..(%?%))\ 
      %{${fg[yellow]}${bg[black]}%}%# "

如果上一个程序以状态1退出，产生红白背景的`(1)`，但如果以状态0退出则什么也不产生，后面跟着黄黑背景的`%`或`#`如果你是超级用户的话。注意这里使用双引号来强制参数立即扩展——转义序列是固定的，所以它们不需要在每次提示符显示时从参数中重新提取。

即使你的终端确实支持颜色，也不能保证所有可能性都有效，尽管基本的ANSI颜色方案是相当标准的。理解的颜色是：青色、白色、黄色、洋红色、黑色、蓝色、红色、灰色、绿色。你也可以使用"默认"，它将终端恢复到开始时的状态。此外，你可以使用基本颜色与参数`$bg_bold`和`$fg_bold`用于粗体颜色变体，以及`$bg_no_bold`和`$fg_no_bold`明确切换回非粗体。

**主题**\

还有一组主题作为函数提供，以将你的提示符设置为各种预定义的可能性。这些利用了如上所述设置的颜色。参见`zshcontrib`手册页了解如何做到这一点（搜索"提示符主题"）。

[]{#l20}

### 2.5.7: 命名目录

如前所述，`~/`在文件名开始处扩展到你的主目录。更一般地，`~`*user*`/`允许你引用任何其他用户的主目录。此外，zsh让你定义自己的命名目录，使用这种语法。基本思想很简单，因为任何参数都可以是命名目录：

      dir=/tmp/mydir
      print ~dir

打印`/tmp/mydir`。到目前为止，这与使用参数`$dir`没有什么不同。区别在于如果你在提示符中使用`%~`结构（如上所述）。然后当你切换到该目录时，你会看到缩写`~dir`，而不是消息`/tmp/mydir`。

shell不会在你至少使用一次`~dir`强制它注册目录名称之前注册名称。你可以在`.zshrc`中做以下事情：

      dir=/tmp/mydir
      bin=~/myprogs/bin
      : ~dir ~bin

其中`:`是一个不做任何事情的命令——但它的参数像往常一样检查参数等，所以shell可以将`dir`和`bin`放入其命名目录列表中。一个更简单的方法是设置选项`AUTO_NAME_DIRS`；然后任何创建的引用目录的参数将自动变成名称。目录必须有绝对路径，即其扩展值，在将任何开头的`~`转换为完整路径后，必须以`/`开头。参数`$PWD`，显示当前目录，受到保护不变成`~PWD`，因为那不会告诉你任何东西。

[]{#l21}

### 2.5.8: 给高级用户的"加速"选项

这里有一些你可能想在`.zshrc`中设置的更多随机选项。

**`NO_BEEP`**\

通常zsh如果不喜欢某事会发出哔哔声。这可能变得极其令人烦恼；`setopt nobeep`会关闭它。我非正式地称这为`OPEN_PLAN_OFFICE_NO_VIGILANTE_ATTACKS`选项。

**`AUTO_CD`**\

如果设置了此选项，并且你输入没有参数的内容，而它不是命令，zsh将检查它是否实际上是目录。如果是，shell将切换到该目录。所以`./bin`单独等同于`cd ./bin`，只要目录`./bin`确实存在。这在`..`形式中特别有用，它切换到父目录。

**`CD_ABLE_VARS`**\

这是另一种在切换目录时节省输入的方法，尽管只有一个字符。如果在你尝试切换到目录时目录不存在，zsh将尝试查找同名参数并使用它代替。你也可以在参数后有`/`和其他位。所以`cd `foo/dir`，如果没有目录`foo`但有参数`$foo`，就等同于`cd `$foo/dir`。

**`EXTENDED_GLOB`**\

模式，匹配文件名和其他东西，可以在zsh中非常复杂，但要充分利用它们你需要使用此选项，因为否则某些功能未启用，所以习惯于更简单模式（可能只是`*`、`?`和`[...]`）的人不会被奇怪的事情混淆。我会说更多关于zsh的模式功能，但这提醒你如果你在做任何聪明的事情与`~`、`#`、`^`或glob标志有关——并且也提醒你如果设置了该选项，这些字符可能会有奇怪的效果。

**`MULTIOS`**\

我上面提到要让zsh像ksh一样工作你需要设置`NO_MULTIOS`，但我没有说`MULTIOS`选项做什么。它对输出和输入有两种不同效果。

首先，对于输出。这是`tee`程序的替代品。我曾提到一次，但没有详细描述，你可以使用`>filename`告诉shell将输出发送到给定名称的文件而不是终端。设置了`MULTIOS`，你可以在命令行上有多个这样的重定向：

      echo foo >file1 >file2

在这里，`foo`将被写入**两个**命名文件；zsh复制输出。管道机制，我将在[第3章](zshguide03.html#syntax)中更好地描述，是重定向到另一个程序而不是文件的一种形式：`MULTIOS`也影响这个：

      echo foo >file1 | sed 's/foo/bar/'

在这里，`foo`再次被写入`file1`，但也被发送到管道到程序`sed`（"流编辑器"），它将`foo`替换成`bar`并（因为这部分没有输出重定向）打印到终端。

注意上面的第二个例子多次被报告为bug，通常形式如：

     some_command 2>&1 >/dev/null | sed 's/foo/bar/'

这里的意图显然是将标准错误发送到标准输出（`2>&1`，一个非常常用的shell象形文字），并且不发送标准输出到任何地方（`>/dev/null`）。（如果你还没有遇到"标准错误"的概念，它只是另一个输出通道，除非你重定向，否则去与正常输出相同的地方；它被用来，例如，将错误消息发送到终端，即使你的输出去其他地方。）在这个例子中，`MULTIOS`功能也迫使原始标准输出进入管道。你可以看到如果我们将`some_command`的版本放进去会发生什么：

     { echo foo error >&2; echo foo not error;  } 2>&1 >/dev/null |
      sed 's/foo/bar/'

你可以将`{...}`中的东西视为一个黑盒子，它将消息`foo error`发送到标准错误，将`foo not error`发送到标准输出。然而，使用`MULTIOS`，结果是

     error bar
      not error bar

因为两者都被发送到管道。没有`MULTIOS`你会得到预期的结果，

     error bar

就像任何其他Bourne-style shell会产生的那样。有

在输入时，`MULTIOS`安排一系列文件按顺序读取。这次它有点像使用程序`cat`，它结合了列出在其后的所有文件。换句话说，

      cat file1 file2 | myprog

（其中`myprog`是一些读取发送给它的所有文件作为输入的程序）可以替换为

      myprog <file1 <file2

这做同样的事情。再一次，管道算作重定向，管道首先被读取，在任何列在`<`后的文件之前：

      echo then this >testfile
      echo this first | cat <testfile

**`CORRECT`, `CORRECT_ALL`**\

如果你设置了`CORRECT`，shell将检查你输入的所有命令，如果它们不存在，但有一个同名的命令，它会问你是否意味着那个命令。你可以输入`n`表示不，不纠正，继续前进；`y`表示是，纠正然后继续前进；`a`表示中止，什么都不做；`e`表示编辑，返回编辑器再次编辑同一行。使用新完成系统的用户应该注意这与那里得到的纠正不同：这只是简单的命令纠正。

`CORRECT_ALL`应用于行上的所有单词。它稍微不那么有用，因为目前shell必须假设它们应该是文件名，并且如果它们作为这样的文件不存在会尝试纠正它们，但当然命令的许多参数不是文件名。如果特定命令生成太多纠正其参数的尝试，你可以通过在命令名称前放置`nocorrect`来关闭它。别名是这样做的非常好的方法，如下所述。

[]{#l22}

### 2.5.9: 别名

别名像命令一样使用，但它扩展成一些其他文本，这些文本本身用作命令。例如，

      alias foo='print I said foo'
      foo

打印（猜猜）`I said foo`。注意定义语法——你需要`=`，你需要确保整个别名被shell视为一个单词；你可以给同一个`alias`命令一个完整的别名列表。你可能能够想到一些你想在启动文件中定义的别名；`.zshrc`可能是正确的地方。如果你设置了`CORRECT_ALL`，避免`mkdir`命令拼写检查其参数的方法——这是无用的，因为它们*必须*对命令工作而言是不存在的——是定义：

      alias mkdir='nocorrect mkdir'

这显示了别名的一个有用功能：别名可以包含与自身同名的东西。当它在扩展文本（右侧）中遇到时，shell知道不要再次扩展别名，而是将其视为真实命令。请注意，函数*不*具有此属性：函数比别名更强大，在某些情况下让它们调用自己是有用的。让函数一遍又一遍地调用自己直到shell抱怨是一个常见错误。我将在[第3章](zshguide03.html#syntax)中描述解决方法。

函数比别名更强大的另一种方式是函数可以接受参数而别名不能——换句话说，在别名内部没有方法引用命令行上跟随它的内容，不像函数，也不像csh中的别名（因为它没有函数，这就是为什么）。它只是盲目地扩展，并且命令行的其余部分粘在末尾。因此zsh中的别名通常保留用于相当简单的事情，函数用于任何更复杂的事情。你不能用函数做那个`nocorrect`的技巧，尽管，因为函数调用得太晚：别名立即扩展，所以`nocorrect`及时找到以有用。你几乎可以认为它们只是普通的打字缩写。

正常别名只在命令位置工作，即在命令行的开头（更严格地说，当zsh期望命令时）。还有其他称为"全局别名"的东西，你通过`alias`的`-g`选项定义，它们将在命令行的任何位置扩展。在定义这些之前你应该认真考虑，因为它们可能有剧烈的影响。请注意，引用一个单词，甚至一个字符，将阻止别名为它扩展。

我只倾向于在交互式shell中使用别名，所以我从`.zshrc`中定义它们，但如果你更广泛地使用别名，你可能想使用`.zshenv`。实际上，为了保持我的`.zshrc`整洁，我将所有别名保存在一个单独的文件`.aliasrc`中，在`.zshrc`中我有：

      if [[ -r ~/.aliasrc ]]; then
        . ~/.aliasrc
      fi

这检查是否有可读文件`~/.aliasrc`，如果有，它以与正常启动文件运行完全相同的方式运行它。你可以使用`source`代替`.`如果对你更有意义；`.`是传统的Bourne和Korn shell名称，然而。

[]{#l23}

### 2.5.10: 环境变量

通常，程序的手册会告诉你定义某些环境变量，通常是一组大写字母，可能有数字和偶尔的下划线。这些可以在不使用额外参数的情况下向程序传递信息。在zsh中，环境变量作为普通shell参数出现，尽管它们必须以稍微不同的方式定义：严格来说，环境是shell外部的一个特殊区域，zsh必须被告知在那里放一个副本以及保留自己的一个副本。通常语法是

      export VARNAME='value'

换句话说，像普通赋值一样，但在前面有`export`。注意在环境变量名称前没有`$`；所有`export`和类似语句都以相同方式工作。最容易放置这些的地方是`.zshenv`——因此它的名字。环境变量将传递给从shell运行的任何程序，所以可能足以在`.zlogin`或`.zprofile`中定义它们：然而，任何非交互式为你启动的shell不会运行那些，并且如果你使用窗口系统由非zsh shell启动或根本不运行shell启动文件——我不得不调整我的让它这样做。所以`.zshenv`是最安全的地方；定义环境变量不需要很长时间。其他人无疑会给你完全矛盾的观点，但那就是人。

注意你不能导出数组。如果你导出一个参数，然后分配一个数组给它，环境中什么也不会出现；你可以使用外部命令`printenv VARNAME`（再次没有`$`因为命令需要知道名称，而不是值）来检查。数组还有一个更微妙的问题。`export`内置命令只是内置命令**typeset**的一个特例，它定义一个变量而不标记它导出到环境。你可能认为你可以做

      typeset array=(this doesn\'t work)

但你不能——特殊数组语法只有在赋值不跟随命令时才被理解，不像这里的情况，在普通参数中，所以你必须将数组赋值放在下一行。这是一个非常容易犯的错误。`typeset`的更多用途将在[第3章](zshguide03.html#syntax)中描述；它们包括在函数中创建本地参数，以及为参数定义特殊属性（其中"导出"属性只是其中之一）。

[]{#l24}

### 2.5.11: 路径

能够找到外部程序是有帮助的，即任何不是shell一部分的任何命令，任何不是内置命令、函数或别名的命令。`$path`数组用于此。实际上，系统需要的是环境变量`$PATH`，它包含一个在其中搜索程序的目录列表，由冒号分隔。这些目录是数组`$path`的各个组成部分。所以如果`$path`包含

      path=(/bin /usr/bin /usr/local/bin .)

那么`$PATH`将自动包含的效果

      PATH=/bin:/usr/bin:/usr/local/bin:.

而你不必设置那个。想法很简单，虽然系统需要`$PATH`因为它不理解数组，但在shell中使用数组要灵活得多，因此几乎忘记`$PATH`形式。

对路径的更改类似于上面描述的环境变量更改，所以所有这些都适用。然而，在`.zshenv`中设置`$path`有一个小困难，尽管上面给出的原因仍然适用。通常，路径会由系统或系统管理员在全局启动文件之一中设置，如果你更改路径，你只想添加到它。但如果你的`.zshenv`包含

      path=(~/bin ~/progs/bin $path)

——这是在`$path`前面添加东西的正确方法——那么每次调用`.zshenv`时，`~/bin`和`~/progs/bin`都会被粘在前面，所以如果你启动另一个zsh，你会有两个集合在那里。

当然，你可以添加测试来看某物是否已经在那里。Zsh方便地允许你测试数组中元素的存在。通过在数组索引前加上`(r)`（代表reverse），它会尝试找到匹配的元素并返回它，否则返回空字符串。这里是这样做的方法（但不要添加这个，见下一段）：

      for dir in ~/bin ~/progs/bin; do
        if [[ -z ${path[(r)$dir]} ]]; then
          path=($dir $path)
        fi 
      done

那个`for`\... `do` \... `done`是另一个特殊的shell构造。它获取`in`后面的东西并依次分配给`in`前面命名的参数——`$dir`，但是因为这是一个赋值形式，`$`被省略了——所以第一次它有`dir=~/bin`的效果，下一次`dir=~/progs/bin`。然后它执行循环中的内容。测试`-z`检查跟随的内容是否为空：在这种情况下，如果目录`$dir`尚未在`$path`中，它会继续并添加到前面。请注意，目录以与它们出现的顺序相反的顺序添加。

然而，实际上，zsh为你省去了所有这些麻烦。咒语`typeset -U path`，其中`-U`代表唯一，告诉shell如果它已经在`$path`中，就不要添加任何东西。准确地说，它保留最左边的出现，所以如果你在末尾添加了某物，它会消失，如果你在开头添加了某物，旧的会消失。因此以下内容在`.zshenv`中很好地工作：

      typeset -U path
      path=(~/bin ~/progs/bin $path)

你可以把那个`for`东西作为shell编程的一课写下来。你可以通过输入`typeset +U`列出所有具有唯一性开启的变量，用`+`代替`-`，因为后者情况下shell会显示参数的值，而这正是你在这里不需要的。`-U`标志也适用于冒号分隔的数组，如`$PATH`。

[]{#l25}

### 2.5.12: 邮件

Zsh会为你检查新邮件。如果你只需要时不时地被提醒有东西到达你的普通文件夹，你只需要将参数`$MAIL`设置到无论哪里：它通常是`/usr/spool/mail`、`/var/spool/mail`或`/var/mail`之一。

数组`$mailpath`允许更多可能性。像`$path`一样，它有一个大写同事`$MAILPATH`，这是一个冒号分隔的数组。系统不需要那个，这次，所以它主要在那里所以你可以将其导出到另一个zsh版本；导出数组不会工作。正如现在可能痛苦清楚的，如果你在`.zshenv`或中设置它
