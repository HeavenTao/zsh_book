# 第六章：补全，旧的和新的

命令参数的补全是zsh特别擅长的功能。最简单的情况是，你按`<TAB>`键，shell会猜测那里应该填什么内容并为你填充：

      % ls
      myfile  theirfile  yourfile
      % cat t<TAB>

将命令行扩展为

      % cat theirfile

而你只需要输入首字母，然后按`TAB`。

在C shell中出现此功能的早期，只能补全文件名；对于名称不明确的情况，没有巧妙的技巧来帮助你，它只是打印出不明确的部分并发出蜂鸣声，因此你必须决定下一步该做什么。你还可以列出可能的补全；由于某些原因，这在csh中与`^D`键相关联，后来具有Emacs风格绑定的shell中也删除了下一个字符，因此历史让zsh像其他shell一样具有了稍微奇怪的组合行为：

      % cat yx 

现在将光标移回x字符上并按^D两次，你会看到：`yourfile`。如果你使用vi风格的绑定，或者显然如果你重新绑定了`^D`，这将不起作用。

接下来，可以补全其他项目，如用户名、命令或主机名。然后zsh引入了菜单补全，这样你可以继续盲目地按`<TAB>`直到出现正确的答案，而无需自己输入额外的字符。

下一个发展是tcsh的，然后是zsh的可编程补全系统；你可以给shell指令，在某些上下文中，只有某些项目应该被补全；例如，在`cd`之后，你只想补全目录。在tcsh中，有一个叫做`complete`的命令；每个\``complete ...`\'语句定义了特定命令（如`cd`）参数的补全；zsh中的等效命令是`compctl`，它受到`complete`的启发，但在几乎所有重要细节上都不同。在shell发行版的`Misc`目录中有一个perl脚本`lete2ctl`可以帮助你从tcsh格式转换为zsh格式。你可以在`.zshrc`中放入一系列`compctl`命令，其他一切由shell完成。

Zsh的系统变得越来越复杂，在版本3.1.6中出现了一个新的补全系统，它应该能为你完成所有事情：你只需从初始化文件中调用一个函数`compinit`，之后zsh就知道，例如，`gunzip`后面应该跟以`.gz`结尾的文件。新系统基于shell函数，这是一个额外的好处，因为它们极其灵活，你已经知道语法。然而，鉴于其复杂性，现在开始编写自己的补全变得相当困难，而且很难知道如何按你喜欢的方式更改设置。本章的其余部分应该有所帮助。

我将专注于新的补全系统，它似乎注定要完全取代旧系统，现在3.1发布系列已成为4.0生产版本。旧的**compctl**命令仍然可用，旧的补全定义将在未来版本的zsh中继续工作——实际上，在大多数支持动态链接库的操作系统上，旧的补全系统位于一个不同的文件中，shell在需要时加载它，因此几乎没有开销。

新系统的一大区别在于，不是在shell启动时一次性设置所有内容，而是在你按下`<TAB>`后调用各种shell代码来即时生成补全。shell中有足够多的新功能，可以替代`compctl`的所有那些难以记忆的选项（\``-f`\'表示文件，\``-v`\'表示变量等），这些可以通过直接生成补全列表的命令来替换；在这种情况下，关键命令叫做\``compadd`\'，它传递这个列表并决定使用什么来补全命令行上的单词。因此，最简单的新型补全形式大致如下：

      # 告诉shell函数mycompletion可以通过名为my-completion-widget的小部件进行补全，并且
      # 它的行为类似于现有的小部件complete-word
      zle -C my-completion-widget .complete-word mycompletion
      
      # 定义一个调用补全小部件的键
      bindkey '^x^i' my-completion-widget
      
      # 定义将被调用的函数
      mycompletion() {
        # 添加补全列表
        compadd alpha bravo charlie delta
      }

这非常粗略地描述了补全系统的工作方式，除了被调用的函数叫做`_main_complete`并调用许多其他函数来根据补全被调用的上下文（所有`compctl`曾经做的事情）做脏活，而小部件只是重新定义的旧补全小部件（\``expand-or-complete`\'等）并仍然绑定到所有原始键上。但是，如果你还没有猜到，还有更多内容。

这是本章各节的计划。

1.  对补全和扩展的广泛描述，同样适用于旧的和新的补全。
2.  如何使用shell选项配置补全。本节的大部分内容也适用于旧的补全，尽管我不会明确指出任何差异。此后，我将离开`compctl`世界。
3.  如何启动新的补全。
4.  新补全系统工作原理的基础知识。
5.  如何使用新的\``zstyle`\'内置命令进行配置。
6.  单独的命令，它们执行不同于通常补全系统的事情，以及其他一些与补全有关的编辑小部件。
7.  匹配控制，一种强大的方式，用于决定是否不区分大小写地补全，允许在标点字符之前插入额外的单词部分，或忽略命令行上单词中的某些字符。
8.  如何编写自己的补全函数；你不需要对前述内容有太深入的理解就可以进行简单的补全，但我会逐渐介绍如何使标签和样式在你自己的函数中工作，以及如何使补全处理命令参数和选项的工作。
9.  优雅地结束本章，遵循古老的“开始、中间、结束”原则。

## 6.1：补全和扩展

按tab键时，不仅仅是补全发生。zsh首先尝试做的事情是扩展行。扩展在前一章中有所涉及：基本上那里描述的所有事情都是可能的候选者，可以由编辑器内联扩展。换句话说，历史替换（使用感叹号）、各种使用\``$`\'或反引号的扩展，以及文件名生成（globbing）都可以发生，结果会替换命令行上的内容：

      % echo $PWD<TAB>
        ->    echo /home/pws/zsh/projects/zshguide
      % echo `print $ZSH_VERSION`<TAB>
        ->    echo 3.1.7
      % echo !!<TAB>
        ->    echo echo 3.1.7
      % echo ~/.z*<TAB>
        ->    echo /home/pws/.zcompdump /home/pws/.zlogout
              /home/pws/.zshenv /home/pws/.zshrc                   

请注意，在这种情况下，\``~`\'也会被扩展。

这通常是记住\`撤销\'键的好时机，\``^_`\'或\``^Xu`\'；输入这个将恢复扩展之前的内容，如果你不喜欢结果的话。许多键盘有一个怪癖，描述为\``^_`\'的应该按控制键加斜杠，你会写成\``^/`\'，但不幸的是这会做其他事情；这不是zsh的错。还有一个半例外，即文件名生成：像\``~/file`\'这样的路径不会被扩展，因为通常你知道它们指的是什么，而且保留它们以供补全使用通常很方便。但是，除非设置了`NO_EQUALS`，否则\``=cmdname`\'形式会被扩展。

实际上，有时决定是进行扩展还是补全可能会很棘手，因为如果它们是完整的，那些本可以被扩展的东西可能需要先被补全；例如`$PAT`可能应该被补全为`$PATH`，但很可能也存在一个参数`$PAT`。如果你更喜欢，你可以决定是哪一个。首先，命令`expand-word`，绑定到\``^X*`\'，以及相应的列出将被扩展内容的命令`list-expand`，绑定到\``^Xg`\'，只进行扩展——所有可能的形式，包括将\``~/file`\'变成完整路径。

从另一个角度看，你可以使用除`expand-or-complete`之外的命令（默认绑定到`<TAB>`），只执行补全。基本的命令是`complete-word`，默认情况下未绑定。如果你习惯使用单独的命令进行扩展，将其绑定到\``^I`\'（即`<TAB>`）是相当合理的，例如

      # 现在tab只做补全，不做扩展
      bindkey '^i' complete-word

此外，如果你这样做并使用新的补全系统，正如我们将看到的，有一种方法可以让补全系统执行扩展——参见下面`_expand`补全器的描述。在这种情况下，你可以更好地控制尝试哪些形式的扩展，以及在何时尝试，但你必须确保使用`complete-word`而不是`expand-or-complete`，否则标准扩展系统将接管。

`expand-or-complete`有一个近亲，`expand-or-complete-prefix`，默认情况下未绑定。唯一的区别是它在补全时会忽略光标下方及右侧的所有内容。这就像光标所在位置有一个空格，所有被忽略的内容都向右移动（猜猜它是如何实现的）。如果你习惯在其他单词之前在行中输入新单词，并期望它们独立补全或扩展，即使你还没有输入它们后面的空格，这很有用。一些其他shell总是以这种方式工作。更明确地说：

      % ls
      filename1
      % ls filex

将光标移动到`x`并按tab。使用`expand-or-complete`什么都不会发生；它正在尝试补全一个叫做\``filex`\的文件——或者，设置了`COMPLETE_IN_WORD`选项时，它正在尝试找到一个以\``file`\'开头并以\``x`\结尾的文件。如果你执行

      bindkey '^i' expand-or-complete-prefix

并尝试相同的实验，你会发现整个内容被补全为\``filename1x`\，因此\``x`\被忽略了，但没有被删除。

一个可能的陷阱是，列出命令，包括默认绑定到emacs模式中的\``^D`\'的`delete-char-or-list`和默认绑定到vi插入模式中的\``^D`\'的`list-options`（基本的列出补全的命令，因为它没有删除字符的行为），不会显示可能的扩展，因此使用默认绑定你可以使用\``^D`\'来列出，然后按`<TAB>`并发现行已经被某些扩展完全重写。使用`complete-word`而不是`expand-or-complete`当然会解决这个问题。如果你知道如何编写新的编辑器小部件（[第4章](zshguide04.html#zle)），你可以制作一个函数，尝试`list-expand`，如果失败则尝试`list-options`。

还有四个我没有提到的补全命令：三个是`menu-complete`、`menu-expand-or-complete`和`reverse-menu-complete`，它们执行菜单补全，你可以在按相同键时循环浏览所有可能的补全。前两个分别对应于`complete-word`和`expand-or-complete`，而第三个没有真正的等效命令，因为它让你在补全列表中向后移动。第三个的效果无法仅通过设置菜单补全选项来达到，因此将它单独绑定是有用的。我将它绑定到\``\M-\C-i`\'，即按住Meta键的tab，但默认情况下未绑定。

第四个是`menu-select`，它执行一种称为\`菜单选择\`的增强型菜单补全，我将在下面讨论选项时描述它。你必须确保加载了`zsh/complist`模块才能使用这个zle命令。如果你使用样式，只要具有动态加载功能（这些天你可能有），zsh应该能够在需要时自动加载它。 

## 6.2：使用shell选项配置补全

有两种主要方法可以在不编写或重写shell函数的情况下改变补全行为：shell选项，如在[第2章](zshguide02.html#init)中介绍的，以及样式，如上所述。我将首先讨论shell选项，尽管正如你将看到的，其中一些选项引用了样式机制。设置shell选项会影响每个补全，除非采取了特殊措施（使用相应上下文的样式，或本地设置选项）来避免这种情况。

除了直接影响补全系统的选项外，补全还对描述shell行为的各种其他选项敏感。例如，如果设置了选项`MAGIC_EQUAL_SUBST`，使得所有看起来像\``foo=~/file`\'的命令参数都将\``~`\'扩展，就像它在参数的开头一样，那么默认的命令参数补全（未特别处理）将尝试在\``=`\'之后补全文件名。

不用说，如果你编写补全函数，你将需要担心许多其他可能影响shell语法的选项。补全的主要起点（除了单独绑定到按键的特定补全命令）是函数`_main_complete`，它包含了以下行的效果，以确保至少基本选项在补全函数内设置：

      setopt glob bareglobqual nullglob rcexpandparam extendedglob unset
      unsetopt markdirs globsubst shwordsplit shglob ksharrays cshnullglob
      unsetopt allexport aliases errexit octalzeroes

但这远未穷尽可能性。实际上，它不包括这些行：要设置的选项存储在数组`$_comp_options`中，如果它们要被关闭，则前面加上`NO_`。如果你发现需要修改它（也许还要告诉维护者）。

顺便说一下，如果你想知道是否可以重用函数`_main_complete`，通过用稍微不同的补全定义绑定到不同的键，看看下面对`_generic`命令小部件的描述。它只是`_main_complete`的前端，允许你在不同的样式集中生效。

### 6.2.1：模糊补全

最大的一组选项处理补全模糊时发生的情况，换句话说，有多个可能的补全。相关的七个选项如下，如FAQ中复制的；许多不同的组合是可能的：

-   设置`NO_BEEP`，烦人的蜂鸣声消失，
-   设置`NO_LIST_BEEP`，蜂鸣只在模糊补全时关闭，
-   设置`AUTO_LIST`，当补全模糊时，你会在不按`^D`的情况下得到一个列表，
-   设置`BASH_AUTO_LIST`，列表只在你第二次按tab时发生，
-   设置`LIST_AMBIGUOUS`，这样修改后，如果有明确的前缀或后缀要插入，则不会列出任何内容——这可以与`BASH_AUTO_LIST`结合，因此在两者都适用的情况下，你需要按三次tab才能列出，
-   设置`REC_EXACT`，如果命令行上的字符串正好匹配可能的补全之一，则接受它，即使有另一个补全（即该字符串加上其他内容）也匹配，
-   设置`MENU_COMPLETE`，总是插入一个完整的补全，然后当你按TAB时它会更改为下一个，依此类推，直到你回到开始的地方，
-   设置`AUTO_MENU`，你只有在再次按TAB时才会得到菜单行为。

### 6.2.2：`ALWAYS_LAST_PROMPT`

默认情况下设置`ALWAYS_LAST_PROMPT`选项，并且自zsh的早期3.1版本以来一直如此；在列出补全后，光标会回到之前所在的行，而不是在下面重新打印。这样做的缺点是，当你执行命令或生成不同的列表时，列表将被遮挡，因此你可能想要取消该选项。菜单选择需要`ALWAYS_LAST_PROMPT`行为，这就是为什么我现在提到它而不是在下面的杂项中提到。

当你编写自己的调用补全的编辑器函数时，你可以通过小部件`end-of-list`来取消这种效果，你会调用为`zle end-of-list`（它是一个正常的编辑函数，而不是补全函数）。你也可以将其绑定到一个键上以用于保留现有的补全列表。另一方面，如果你想在补全函数内控制行为，即决定补全是否会尝试返回到列表上方的提示，你可以使用`$compstate`关联数组的`last_prompt`元素来操作它，例如：

      compstate[last_prompt]=''

将关闭正在进行的补全的这种行为。`$compstate`是当你想要如此详细地控制补全行为时转向的地方；参见`zshcompwid`手册页。

### 6.2.3：菜单补全和菜单选择

上面决定的最重要的事项是是否使用菜单补全。如果你不使用，当补全模糊时，你需要显式输入下一个字符；如果你使用，你只需要继续按tab直到出现你想要的补全。在第二种情况下，当然，这在可能性不多时效果最好。使用`AUTO_MENU`或将`menu-complete`小部件绑定到单独的按键可以让你两者兼得。

3.1.6版中出现了一种新的菜单补全变体；实际上，它比原始形式更应该被称为\`菜单补全\`，但由于这个名字已经被占用，它被称为\`菜单选择\`。这允许你在补全列表中移动光标以选择一个。它由一个单独的模块`zsh/complist`实现；你可以在`.zshrc`中放入\``zmodload -i zsh/complist`\来确保它被加载，尽管当如下所述设置`menu`样式时它应该被自动加载。要使其有用，你需要另外两件事。第一是`ALWAYS_LAST_PROMPT`行为；如果整个补全列表不会出现在屏幕上，则会抑制此行为，因为没有行可以返回。但是，菜单选择仍然有效，允许你上下滚动列表。第二件事是你需要以任何通常的方式启动菜单补全；菜单选择是对菜单补全的添加，而不是替代。

现在你应该设置以下样式：

      zstyle ':completion:*' menu select=<NUM>

如果模糊补全产生至少`<NUM>`个可能性，则启动菜单选择。你可以通过尝试来最好地理解这一点。列表中的一个补全（最初是最左上角的）会被高亮显示并插入到行中。通过在明显的方向移动光标（在边缘处换行），你可以更改高亮显示的值和插入到行中的值。当你有了想要的值后，按回车，这将移除列表并留下插入的值。按`^G`（编辑器函数`send-break`）中止菜单选择，移除列表并恢复命令行。

在内部，zsh实际上使用参数`$MENUSELECT`来提供数字并启动菜单选择。但是，这总是从上面定义的样式初始化，所以你不应该直接设置`$MENUSELECT`（除非你使用`compctl`，它会愉快地使用菜单选择）。与其他样式一样，你可以在不同的上下文中为不同的值指定不同的值；如果当前上下文没有为样式生成值，则检查`default`标签。请注意，`menu`样式还允许你控制是否启动菜单补全，无论是否选择；换句话说，它是一个对应于`MENU_COMPLETE`选项的样式。

在使用菜单选择时还有一个额外的功能。zle命令`accept-and-infer-next-history`在这里有不同的含义；它接受一个补全，然后尝试使用菜单选择再次补全。这对于目录层次结构非常有用，结合`undo`给你一个简单的文件浏览器。你需要在特殊的键映射`menuselect`中绑定它；例如，我使用

      bindkey -M menuselect '^o' accept-and-infer-next-history

因为这种行为让我想起通常绑定到`^O`的emacs模式，即`accept-line-and-down-history`。像这样绑定它对正常键映射中的`^O`没有影响。通过在一组包括目录的文件上进入菜单选择并输入目录上的`^O`来试用它。你应该立即得到该目录内容的呈现以供下一次选择，而`undo`足够聪明，不仅可以移除该选择，还可以返回到父目录的补全。

你可以使用与为特定类型的匹配指定颜色完全相同的机制来选择在补全列表中当前选中的值的高亮显示方式；参见下面对`list-colors`样式的描述。

### 6.2.4：改变补全行为的其他方式

**`COMPLETE_ALIASES`**\

如果你设置了一个别名，例如

      alias pu=pushd

那么在补全系统查找命令名称时，别名\``pu`\将被扩展，因此它将找到命令名称\``pushd`\。这对于避免为所有别名定义额外的补全非常有用。但是，你可能希望为别名定义与它扩展的命令不同的内容。在这种情况下，你需要设置`COMPLETE_ALIASES`，并为每个尚未匹配命令名称的别名安排补全。因此\``alias zcat="myzcat -dc"`\在设置该选项时会起作用，即使你没有告诉系统关于\``myzcat`\，而\``alias myzcat="gzip -dc"`\不会起作用，除非你确实定义了myzcat的补全：这里\``compdef _gzip myzcat`\可能就足够了。不设置该选项时，情况正好相反：第一个别名在没有额外的`compdef`时不会起作用，但第二个会起作用。

**`AUTO_REMOVE_SLASH`**\

默认情况下打开此选项。如果你补全一个目录名并添加了一个斜杠——通常会添加，既告诉你已经补全了一个目录，也允许你在不手动添加\``/`\的情况下补全其中的文件——而你接下来输入的*不是*会插入或补全该目录中文件的内容，则斜杠将被删除。因此：

     % rmdir my<TAB>
       ->  rmdir mydir/
     % rmdir mydir/<RETURN>
       ->  `rmdir mydir' executed
     

这个例子显示了为什么要添加这种行为：某些版本的\``rmdir`\不喜欢目录名后面的斜杠。另一方面，如果你在斜杠后继续输入，或者再次按tab在`mydir`内补全，则斜杠将保留。

在大多数情况下，这最多是无害的。但是，如果你不喜欢这种行为，可以取消设置`AUTO_REMOVE_SLASH`选项。有一件事可能会造成轻微的混淆，尽管它与其他后缀（即自动添加但不是补全值的一部分的位）相同，即如果值是通过菜单补全插入的，则斜杠会立即添加。这可能会让你错误地认为补全已经完成，因此在补全不唯一时它是唯一的。

请注意，某些形式的补全在这种类型的行为中内置了此功能，不一定使用斜杠，在补全参数列表时。例如，输入\``typeset ZSH_V<TAB>`\你会看到\``ZSH_VERSION=`\出现，以防你想为参数赋值；按空格，这不是一个可能的值，会使\``=`\消失。这种行为不受`AUTO_REMOVE_SLASH`选项控制，该选项仅适用于标准文件名补全系统插入的目录。

**`AUTO_PARAM_SLASH`, `AUTO_PARAM_KEYS`**\

当补全包含参数替换的表达式时，这些选项开始生效。如果设置了`AUTO_PARAM_SLASH`，那么任何值为目录名称的参数表达式在补全时将附加一个斜杠，就像值本身由补全系统插入一样。

`AUTO_PARAM_KEYS`的行为更加复杂。试试这个：

      print ${ZSH_V<TAB>

你会发现你得到了完整的词\``${ZSH_VERSION}`\，带有闭合的大括号（假设没有其他匹配的参数）和一个空格。但是，通常在你以这种方式补全参数后，你想要立即在它之后输入一些内容，比如下标。使用`AUTO_PARAM_KEYS`，如果你在这个时候输入一些看起来可能需要放在参数名称之后的内容，它将立即被放置在那里，而无需你删除中间的字符——例如，用\``[`\试试。请注意，这只在参数名称和额外的位是由补全添加时发生；如果你手动输入所有内容，输入\``[`\不会有这种神奇的效果。

**`COMPLETE_IN_WORD`**\

如果设置了此选项，补全总是在单词中的光标位置进行。例如，如果你输入了\``Mafile`\，回到\``f`\上，然后按tab，shell将补全\``Makefile`\，而不是其通常的行为，即转到单词末尾并尝试在那里找到补全，即匹配\``Mafile*`\的内容。某些类型的新型补全（如文件名补全）似乎无论选项设置如何都实现这种行为；某些其他功能（如下面描述的\``_prefix`\补全器）需要它，因此最好设置并习惯它，除非你真的只需要在单词末尾补全。

**`ALWAYS_TO_END`**\

如果设置了此选项，即使补全在中间进行，光标也会始终移动到单词末尾。菜单补全时也会发生这种情况。

### 6.2.5：改变补全显示方式

**`LIST_TYPES`**\

这类似于`ls`的`-F`选项；在补全列表中出现的文件有尾随的\``/`\表示目录，\``*`\表示当前进程可执行的常规文件，\``@`\表示链接，\``|`\表示命名管道，\``%`\表示字符设备，\``#`\表示块设备。默认情况下启用此选项。

请注意，只有当补全系统知道该项应该是文件时，标识符才会出现。如果使用常规的文件名补全命令，这是自动的。在编写自己的补全函数时，还有一个选项`-f`用于`compadd`，如果你想要告诉shell值可能是现有文件以应用`LIST_TYPES`（尽管如果没有这样的文件，也不会造成伤害）。

**`LIST_PACKED`, `LIST_ROWS_FIRST`**\

这些会影响补全列表的排列。使用`LIST_PACKED`，补全列表通过改变列宽而不是将它们格式化成完全规则的网格来尽可能紧凑。使用`LIST_ROWS_FIRST`，列表顺序被改变，使得相邻项目沿行而不是沿列出现，这很像`ls`的`-x`选项。

可以使用样式`list-packed`和`list-rows-first`为特定上下文改变这两者。在这种情况下，样式总是覆盖选项；如果找不到相应的样式，则使用选项设置。

另请注意下面关于补全组的讨论：可以有不同类型的补全出现在单独的列表中，然后可以使用这些标签敏感的样式以不同方式格式化。

## 6.3：开始使用新补全

在我详细介绍新补全之前，这里是设置它的方法，这样你就可以尝试它。如上所述，执行补全的基本对象是shell函数。这些都是自动加载的，因此shell需要通过`$fpath`数组知道在哪里找到它们。如果shell安装正确，并且初始化文件中没有任何内容从`$fpath`中删除了所需的位，这应该会自动发生。甚至可能你的系统已经为你设置了补全（Mandrake Linux 6.1是第一个开箱即用的系统），在这种情况下，输入\``which compdef`\你应该看到一个完整的shell函数——实际上是允许你定义额外补全函数的那个。然后你可以跳过下一段。

如果你想加载补全，在命令行上试试这个：

      autoload -U compinit
      compinit

这应该会无声地工作。如果没有，你需要询问你的系统管理员补全函数发生了什么，或者自己找到它们，然后将所有需要的目录添加到你的`$fpath`中。它们要么都在一个大目录中，要么在一组名为`AIX`、`BSD`、`Base`、`Debian`、`Redhat`、`Unix`、`X`和`Zsh`的子目录中；在第二种情况下，所有目录都需要在`$fpath`中。当这起作用时，你可以将相同的行，包括你可能需要的对`$fpath`的任何修改，添加到你的`.zshrc`中。

现在你可以看看它是否真的在工作。输入\``cd `\，然后按`^D`，你应该会看到一个只包含目录的列表，没有常规文件。如果你设置了`$cdpath`，你可能会看到用`ls`不会出现的目录。正如这所暗示的，补全系统提供了许多常见（以及一些相当深奥）命令的补全。实际上，想法是大多数用户的补全在大多数时候无需干预就能正常工作。如果你认为它应该工作但没有工作，那可能是一个错误或疏忽，你应该报告它。

关于\`它只是工作\`的另一个例子：

      tar xzf archive.tar.gz ^D

将查看gzip压缩的tar归档——假设是GNU版本的`tar`，对于第一个参数集中的\``z`\表示归档已用gzip压缩——并给你一个可以提取的文件或目录列表。这是以与正常文件补全非常相似的方式完成的；尽管有差异，但你可以补全到归档内的任何目录深度。（此时，你应该感到印象深刻。）

补全系统知道的不仅仅是命令及其参数，它还理解一些shell语法。例如，有一个名为`$_comps`的关联数组，它将命令名称存储为键，将补全函数名称存储为相应的值。试着输入：

      print ${_comps[

然后按`^D`。你可能会收到一条消息，询问你是否真的想看到所有可能的补全，即`$_comps`的键；如果你说\``y`\，你会看到一个列表。如果你插入其中任何一个键，然后闭合大括号，使其成为例如\``${_comps[mozilla]}`\并按回车，你会看到处理该命令的补全函数；在这种情况下（在撰写本文时）它是`_webbrowser`。这是找出特定命令由哪个函数处理的方法之一。如果没有条目——即\``print ${_comps[mycmd]}`\给你一个空行——那么该命令没有被特殊处理，将简单地使用为\``-default-`\上下文定义的函数，通常是`_default`。通常这只会尝试补全文件名。你可以自定义`_default`，如果你愿意的话。

除了`-default-`之外，`_comps`的这些键中的一些看起来像`-this-`：它们是特殊上下文，即参数命令之外的地方。我们使用了名为`-subscript-`的上下文；你会发现这种情况下函数叫做`_subscript`。许多补全函数的名称简单地是在命令或上下文名称前加上下划线，减去任何连字符。如果你想了解补全函数的样子，试试\``which _subscript`\；你可能会发现里面有很多你还不知道的其他命令。

重要的是要记住，以这种方式找到的函数是补全执行方式的根源。无论你如何调整选项或样式——我将在接下来的几节中讨论的内容——都不会改变这一点；如果你想要改变基本补全，你只需要编写自己的函数。

顺便说一下，你可能有想要混合使用的旧式补全——或者也许你特别不想混合它们，这样你就可以确保一切都使用新格式工作。默认情况下，新补全系统将首先尝试找到特定的新式补全，如果找不到，它将尝试为相关命令找到`compctl`定义的补全。如果所有这些都失败了，它将尝试通常的新式默认补全，通常是文件名补全。请注意，特定的新式补全优先，这是公平的，因为如果你添加了它们，你几乎肯定不想回去使用旧形式。但是，如果你从不想尝试旧式补全，你可以在`.zshrc`中添加以下咒语：

      zstyle ':completion:*' use-compctl false

现在，这只是黑魔法，但稍后我会详细解释\`样式\`机制，你会看到这符合在新式补全中关闭事物的正常方式。

## 6.4：shell如何找到正确的补全

### 6.4.1：上下文

上面的例子表明，补全系统是高度上下文敏感的，因此了解这些上下文是如何描述的很重要。这个系统是逐渐演变的，但我所说的一切都适用于所有主要版本为4的zsh。

状态我们处于补全中，并且以一种类似冒号分隔的路径给出，从最不具体的部分开始。有一种简单的方法可以找出你处于什么上下文中：在你想要补全某物的地方，输入\``^Xh`\，它会告诉你。在`$_comps`的例子中，你会发现，

      :completion::complete:-subscript-::

加上一个所谓的\`标签\`列表和补全函数，我稍后会讨论。完整的形式是：

      :completion:<func>:<completer>:<command>:<argument>:<tag>

其中如果未设置元素，则可能缺失，但冒号将始终存在以使模式匹配更容易。这里是上下文在`completion:`部分之后的含义。

***\<func\>***
:   是从中调用补全的函数名称——如果从标准补全系统启动，则为空，并且仅在少数特殊情况下出现，在本章第六节中列出。

***\<completer\>***
:   在这种情况下称为\``complete`\：这指的是补全系统可以做的不仅仅是简单的补全；例如，它可以进行更受控的扩展（如我所提到的），拼写纠正，以及完成带有拼写错误的单词。我稍后会介绍其他补全器；\``complete`\是最简单的一种，只做基本的补全。

***\<command\>***
:   是命令或上述其他类似上下文的名称，这里是\``-subscript-`\。

***\<argument\>***
:   当`<command>`是真实命令的名称时最有用；它描述了我们在该命令参数中的位置。你稍后会看到它是如何工作的。许多较简单的补全不使用这个；只有那些具有复杂选项和参数组合的补全使用。你只需要用`^Xh`找出是否需要知道。

***\<tag\>***
:   描述补全的类型，本质上是区分在同一命令行上可以补全的不同事物的一种方式。

现在看看更正常的命令参数补全的上下文，例如在`cd`之后；在这里你会看到上下文
\``:completion::complete:cd::`\。这里命令名称部分的上下文是一个真正的命令。

对于更复杂的情况，试试在\``cvs add`\之后（如果你没有`cvs`命令，这无关紧要）。你会看到一个冗长且重复的标签列表，适用于两个可能的上下文，

      :completion::complete:cvs:argument-rest:
      :completion::complete:cvs-add:argument-rest:

有两者的原因是\``add`\不仅是`cvs`的参数，如第一个上下文所暗示的，它本身也是一个子命令，有自己的参数，这就是第二个上下文的用途。第一个上下文意味着在\``add`\及其参数之后可能还有更多的子命令，这些子命令与它们完全独立——尽管实际上CVS不这样工作，所以这种形式在这里不会给你任何补全。

在两者中，\``argument-rest`\显示补全正在寻找另一个参数，\``rest`\表示这是行末的参数列表；如果位置很重要（参见\``cvs import`\的例子），上下文将包含\``argument-1`\，或其他任何内容。通过用连字符而不是冒号分隔，\``cvs-add`\显示了子命令的处理方式，这样就不会混淆上下文的不同部分。

除了命令和子命令的参数外，选项的参数是另一种常见的可能性；例如，在\``dvips -o`\之后输入`^Xh`，你会看到上下文
\``:completion::complete:dvips:option-o-1:`\；这显示你正在补全`dvips`的`-o`选项的第一个参数（它只需要一个参数），这是输出文件的名称。

### 6.4.2：标签

现在继续讨论与上下文有关的另一个问题，即标签。让我们回到在`cd`命令后使用`^Xh`帮助测试的完整输出：

      tags in context :completion::complete:cd::
        local-directories path-directories  (_alternative _cd)

与迄今为止考虑的上下文不同，它们告诉你补全是如何到达那一点的，标签描述了它可以在那里补全的东西。在这种情况下，有三个：`directory-stack`指的是诸如\``+1`\之类的条目；目录栈是使用`pushd`命令定义的目录集，你可以通过使用`dirs`命令看到它。接下来，`local-directories`指的是当前工作目录的子目录，而
`path-directories`指的是通过搜索`$cdpath`数组找到的任何目录。系统提供的每个可能的补全都属于这些类别之一。

在括号中，你可以看到生成补全的函数名称；如果你想要改变基本的补全行为，这些是你需要更改或替换的。调用函数出现在右侧，被调用函数出现在左侧，因此在这种情况下，函数\``_cd`\是处理`cd`命令参数的第一个被调用的函数，符合通常的约定。一些标准补全函数已从此列表中过滤掉——知道它已通过`_main_complete`和`_complete`不会对你有帮助，例如。

也许很明显，让系统以不同方式处理不同类型的补全是很有用的，但这里有一个例子，让你预览一下稍后讨论的\`样式\`机制。样式是一种高级的shell参数；它们使用`zstyle`命令定义，使用样式名称和可能的数组值；你总是可以将样式定义为数组，但一些样式可能只是将其用作字符串，将你给它的参数用空格连接起来。你还可以使用`zstyle`命令，用不同的参数，来检索它们的值，这是补全系统本身所做的；参数及其值之间没有实际重叠，因此它们不会妨碍正常的shell编程。

样式与参数的不同之处在于，它们可以在不同的上下文中采用不同的值。`zstyle`命令的第一个参数给出一个上下文；当你定义一个样式时，这个参数实际上是一个模式，将与当前上下文匹配以查看样式是否适用。查找适用规则是：精确的字符串匹配优先于模式，较长的模式优先于较短的模式。这里是一个例子：

      zstyle ':completion:*:cd:*' tag-order local-directories \ 
        path-directories

从上面关于上下文的讨论中，该模式将在补全`cd`命令的参数时匹配。正在设置的样式称为`tag-order`，值是`cd`中有效的两个标签。

`tag-order`样式确定尝试标签的顺序。上面给出的值意味着首先将尝试`local-directories`补全；只有在没有补全时才会尝试`path-directories`。你可以输入命令并尝试这个；如果你没有设置`$cdpath`，你可以分配\``cdpath=(~)`\，这将允许\``cd foo`\更改为目录\``~/foo`\并相应地允许补全目录。转到除`~`以外的目录；`cd`的补全将只显示子目录，而不是`~`的子目录，除非你输入一个字符串，它是`~`下目录的前缀，但不是当前目录的前缀。例如，

      % cdpath=(~)
      % ls -F ~
      foo/    bar/
      % ls -F
      rod/    stick/
      # 没有那个tag-order zstyle命令，你会得到...
      % cd ^D
      bar/    foo/    rod/    stick/
      % zstyle ':completion:*:cd:*' tag-order local-directories \ 
         path-directories
      # 现在你只得到本地目录，如果有的话...
      % cd ^D
      rod/    stick/

你可以用`tag-order`样式做更多的事情：如果你把标签放到同一个词中通过引用，例如
`"local-directories path-directories"`，那么它们将同时被尝试，这在这种情况下给你默认的效果。事实上，由于要为每个可能的补全知道哪些标签将是可用的太费工作，当没有适当的`tag-order`时，默认情况下会尝试在上下文中可用的所有标签；这当然是最初在`cd`后补全时发生的事情。

即使有一个`tag-order`规范，任何未指定的标签通常会在最后一起尝试，因此你可以从原始示例中省略`path-directories`，效果是一样的。如果你不希望这种情况发生，你可以在标签列表中的某处指定一个\``-`\'，它不会被用作标签，但告诉补全只应尝试列表中的标签，而不是可能可用的其他任何标签。此外，如果你不想显示某个特定标签，你可以在值中包含\``!tagname`\，所有其他的但这个将被包含。例如，你可能已经注意到在命令位置补全时，你也被提供了要设置的参数以及命令等：

      Completing external command
      tex             texhash         texi2pdf        text2sf
      texconfig       texi2dvi        texindex        textmode
      texdoc          texi2dvi4a2ps   texlinks        texutil
      texexec         texi2html       texshow         texview
      Completing parameter
      TEXINPUTS                               texinputs

（我还没有告诉你如何生成这些描述，或者如何使不同标签的补全分开显示，但我会——参见下面对\``format`\和\``group-name`\样式的描述。）如果你设置

      zstyle ':completion:*:-command-:*' tag-order '!parameters'

那么最后两行将从补全中消失。当然，你的补全列表可能看起来与我的完全不同。顺便说一句，样式的一个好处是，无论它们是在补全加载之前还是之后定义的都不重要，因为样式由shell的另一部分存储和检索。

要排除多个标签名称，你需要将名称包含在同一个词中。例如，要排除参数和保留字，值将是`'!parameters reserved-words'`，而*不是*
`'!parameters' '!reserved-words'`，这将尝试一次补全排除参数，然后再次排除保留字。
此外，标签实际上可以是模式，或者更准确地说，`tag-order`的任何参数中的任何词都可以包含模式，然后将其与所有有效的标签进行匹配以查看是否匹配。有时甚至有用的是使用\``*`\来匹配所有标签，如果你在同一个词中指定标签的特殊形式——也许使用标签，如下所述——这很有用。有关补全函数理解的所有标签名称，请参阅手册。

`tag-order`样式允许你给标签\`标签\`，这是一种别名，指示补全系统使用不同的名称使用标签。你通过给出标签后跟冒号来安排，后跟标签。标签也可以在前面加上连字符，这意味着在查找标签时原始标签名称应放在前面；这只是让名称看起来更整洁的一种方式。其结果是，通过使用带有标签名称而不是标签名称的上下文，你可以安排特殊行为。此外，你可以为标记的标签提供替代描述；这些与我将在下面描述的`format`样式一起显示（我个人觉得非常有用）。你把描述放在另一个冒号后面，用引号括起任何空格。它看起来像这样：

      zstyle ':completion:*:aliens:*' tag-order \ 
      'frooble:-funny:funny\ frooble' frooble

这在你为命令`aliens`补全时使用，它显然有标记为\``frooble`\的补全（如果没有，你很奇怪）。然后补全首先在名称`frooble-funny`下查找样式的标签，如果使用这些样式找到补全，它将用描述（如果你使用`format`）列出它们，描述为\`funny frooble\`。否则，它将在其常用名称下查找标签的样式并再次尝试补全。显然，如果你没有为标签的两个标签设置不同的样式，你每次都会得到相同的补全。

与其让你现在就被关于标签的信息过载，通过给出如何使用标签标签的例子，我将保留这部分内容以供稍后描述`ignored-patterns`样式时使用，这是标签的一个巧妙用途。事实上，这就是为它发明的；可能还有很多我们还没有想到的其他用途。

关于`tag-order`的一个重要注意事项，我可能没有像应该的那样明确说明：*它不会改变在该补全中实际有效的标签*。仅仅将标签名称放入列表中并不意味着该标签名称将被使用；这完全由特定上下文的补全函数决定。`tag-order`样式只是改变了*有效*标签的检查顺序。当你无法弄清楚为什么`tag-order`没有按你想要的方式工作时，请回来再读一遍这段话。

请注意，测试模式的规则意味着你总是可以通过\``zstyle "*" style ...`\指定一个最坏情况的兜底，这将总是最后尝试——不仅在补全中，因为shell的其他部分也使用样式机制，而且没有在上下文开头的\``:completion:`\，这个样式定义也会在那里被选中。

像`tag-order`这样的样式是标签单独使用的最重要情况。在其他情况下，它们可以添加到上下文的末尾；这对于可以为不同补全集提供不同结果的样式很有用，特别是决定补全列表如何显示的样式，或补全如何插入到命令行中的样式。标签是最后一个元素，因此后面不跟冒号。完整的上下文看起来像\``:completion::complete:cd::path-directories`\。稍后，你会看到一些样式可以在不同的标签上下文中有所不同。但是，请记住，上下文的标签部分，像其他部分一样，如果补全系统还没有弄清楚它应该是什么，可能是空的。

## 6.5：使用样式配置补全

现在你知道如何使用以下命令为特定上下文定义样式

      zstyle <context> <style> <value...>

以及一些有用的情况。在介绍其他样式之前，这里有一些更详细的信息。我已经说过，样式可以采用数组值，即在`zstyle`命令末尾的一组值对应于数组元素，你已经看到在一种情况（`tag-order`）中这是有用的。然而，许多样式只使用一个值。有一种特别常见的情况，你只想打开或关闭一个值，即布尔值。在这种情况下，你可以使用\``true`\'、\``yes`\'、\``on`\'或\``1`\'表示开，\``false`\'、\``no`\'、\``off`\'或\``0`\'表示关。你以相同的方式定义所有样式；只有在使用时才决定它们应该是标量、数组还是布尔值，样式的名称也不会被检查以查看它是否有效，因为shell不知道稍后可能会查找哪些样式。上下文也是如此。

你可以使用\``zstyle`\或\``zstyle -L`\列出现有样式（不是单独列出，而是作为完整列表）。在第二种情况下，它们以一组`zstyle`命令的形式输出，这些命令将重新生成当前定义的样式。这在与`grep`一起使用时也很有用，因为你可以轻松检查所有可能上下文的特定样式。

使用`zstyle`的最强大方式是使用选项`-e`。这表示你提供的词将被评估为`eval`的参数。这应该将数组`$reply`设置为要使用的词。所以

      zstyle '*' days 'Monday Tuesday'

和

      zstyle -e '*' days 'reply=(Monday Tuesday)'

是等价的——但当然，意图是第二种情况下的参数可以在每次返回不同的值，因此样式可以变化。它通常在补全的激烈过程中进行评估，因此会拾取所有编辑参数；例如

      zstyle -e ':completion:*' mystyles 'reply=(${NUMERIC:-0})'

将使样式在你为命令输入非零前缀参数时返回非零整数（可能表示`true`），如[第4章](zshguide04.html#zle)中所述。但是，参数可以包含任何zsh代码，而不仅仅是简单的赋值。记住要引用它以防止在运行`zstyle`命令行时将其转换为其他内容。

最后，你可以通过以下方式删除样式的上下文或样式列表

      zstyle -d [ <context-pattern> [ <style> ] ] ...

——请注意，虽然第一个参数是模式，但在这种情况下它是精确处理的，所以如果你给出模式
\``:completion:*:cd:*`\，只有使用*恰好*该模式给出的值才会被删除，而不是其他以
\``:completion:`\开头并包含\``:cd:`\的值。模式和样式在删除时是可选的；如果省略，将删除上下文的所有样式，或删除所有样式的任何样式。补全系统有其自己的默认值，但这些是内置的，因此你指定的任何内容都优先。

顺便说一下，我在[第4章](zshguide04.html#zle)中提到过，你可以在普通的zle小部件（用\``zle -N`\创建的）中以完全相同的方式使用样式，但你可能很快就忘记了这一点。本章中关于定义样式和在你自己的函数中使用它们的所有说明都适用于zle函数。唯一的区别是，在这种情况下，上下文的约定是将上下文设置为\``:zle:`*小部件名称*\'以执行小部件*小部件名称*。

本节的其余部分描述了一些有用的样式。由你来实验上下文，如果你想让样式的值在不同地方不同，或者如果你不在乎，就使用\``*`\。

### 6.5.1：指定补全器及其选项

\`补全器\`是在幕后决定进行哪种补全的函数。你使用\``completer`\'样式设置要使用的补全器，它接受一个要按顺序尝试的补全器数组。例如，

      zstyle ':completion:*' completer _complete _correct _approximate

指定首先尝试正常的补全（\``_complete`\），然后是拼写纠正（\``_correct`\），最后是近似补全（\``_approximate`\），这实际上是前两者的综合效果，即补全输入的单词但允许拼写错误。所有补全器都设置上下文，所以在`_complete`内部你通常会找到\``:completion::complete:...`\，在纠正中\``:completion::correct:..`\，依此类推。

补全器有一个标签功能，类似于上面描述但未详细说明的标签功能。你可以像这样将补全器放在列表中：

      zstyle ':completion:*' completer ... _complete:comp-label ...

这调用补全器`_complete`，但在样式中查找时假装它的名字是`comp-label`，所以你可以多次尝试补全器但启用不同的功能。与标签一样，你可以将其写成\``_complete:-label`\，正常名称将被添加到前面以获得名称\``complete-label`\——只是一个快捷方式，不会引入任何新内容。我将推迟举例，直到你知道补全器的作用。

以下是现有补全器的更详细描述；它们都是函数，所以你可以简单地复制和修改一个来制作自己的补全器。

**`_complete`**\

这是基本的补全行为，我们到目前为止一直在假设。它的主要用途只是检查上下文——这里的意思是判断我们是在补全普通命令参数还是特殊\``-context-`\地方——并调用适当的补全函数。可以通过设置参数\``compcontext`\来欺骗它，这将代替自动生成的参数使用；这在为特殊情况编写自己的补全命令时可能很有用。如果你这样做，你应该使参数对你的函数是局部的。

**`_approximate`**\

这执行近似补全：它实际上被写成`_complete`补全器的包装器，所以它执行`_complete`所做的一切，但它也设置系统以允许有拼写错误的补全。通常，你会想先尝试没有拼写错误的补全，所以这个补全器通常出现在`completers`样式中的`_complete`之后。

主要的控制方式是通过`max-errors`样式。你可以将其设置为允许的最大错误数。错误的定义如近似模式匹配手册中所述：缺少字符如\``rhythm`\ /\``rhytm`\，额外字符如\``rhythm`\ /\``rhythms`\，不正确的字符如\``rhythm`\ /\``rhxthm`\，或一对字符转置如\``rhythm`\ \``rhyhtm`\都算作一个错误。近似将首先尝试找到一个或多个匹配，然后是两个错误，依此类推，直到并包括`max-errors`的值；具有最低错误数的匹配集被选择，所以即使你设置`max-errors`很大，具有较低错误数的匹配将总是优先。设置大的`max-errors`的真正问题是它会更慢，并且更可能生成完全不像你想要的匹配——对于打字错误，两三个可能就是你能承受的极限。否则，总有Mavis Beacon。因此：

      % zstyle ':completion:*' max-errors 2
      # 只是为了举例...
      % zstyle ':completion:*' completer _approximate
      % ls
      ashes    sackcloth
      % echo siccl<TAB>
        -> echo sackcloth
      % echo zicc<TAB>
        <Beep.>

因为\``s[i/a]c[k]cloth`\只有两个错误，而
\``[z/s][i/a]c[k]cloth`\将是三个，所以不会补全。

还有另一种给出最大错误数的方法，使用用`ESC-<digit>`在Emacs模式中指定的数字前缀，直接用数字键在vi命令模式中，或用`universal-argument`。要启用此功能，你必须在`max-errors`的值中包含字符串`numeric`——因此这实际上可以是一个数组，例如

      zstyle ':completion:*:approximate:*' max-errors 2 numeric

允许自动最多两个错误，但你可以通过给补全命令指定前缀来指定更高的最大值。所以继续上面的例子，输入新的`zstyle`和：

      % echo zicc<ESC-3><TAB>
        -> echo sackcloth

因为我们允许了三个错误。你现在可以开始看到允许太多错误的问题：如果你有文件\``zucchini`\，那只会有一个错误，并且会被找到并插入，而\``sackcloth`\甚至不会被考虑。

请注意，上下文在补全器中被立即检查，所以在这个阶段它只是\``:completion::approximate:::`\；没有更详细的上下文信息可用，所以不可能为不同的命令或标签指定不同的`max-errors`。

近似还有其他次要样式控制。如果`original`样式为真，则始终将原始值视为可能的补全，即使它不匹配任何内容，即使没有任何其他匹配。补全原始值和更正使用不同的标签，毫不奇怪地称为`original`和`corrections`，所以你可以用`tag-order`样式组织这个。

因为在这种情况下补全通常与命令行上的内容不匹配，并且可能彼此不匹配，所以菜单补全会立即为你提供选择补全的机会。你可以安排如果在开头有一个明确的部分要先插入，则不会发生这种情况，方法是设置布尔样式`insert-unambiguous`。

最后两个样式（`original`和`insert-unambiguous`）在生成更正时在上下文中被较早地查找，因此只有到达补全器名称的上下文可用。补全器名称后面会跟一个连字符和当前接受的错误数。因此，尝试用一个错误进行近似时，上下文是\``:completion::approximate-1:::`\；如果失败并且系统需要寻找用两个错误补全，则上下文将是\``:completion::approximate-2:::`\，依此类推；对于使用\``correct-1`\等的纠正和上面描述的补全器也是如此。

**`_correct`**\

这与`_approximate`非常相似，只是上下文是\``:completion::correct:*`\（或在生成更正时为\``:completion::correct-<num>:*`\，如上所述）并且它不会执行补全，只是拼写纠正，所以现在补全器必须在行上的单词末尾添加的额外字符算作额外的错误而不是以普通方式进行补全：`zicc`与`sackcloth`相差甚远，有七个错误，但`ziccloth`只算三个。`_correct`补全器的控制方式与`_approximate`完全相同。

还有一个单独的命令只进行更正而不做其他事情，通常绑定到\``^Xc`\，所以如果你乐于使用它，你不需要在补全器列表中包含`_correct`。如果你包含它，并且你也有`_approximate`，`_correct`应该在前面；`_approximate`注定会生成`_correct`所做的所有匹配，可能还有更多。像其他单独的补全命令一样，它有自己的上下文，这里以\``:completion:correct-word:`\开头，所以很容易使这个命令的行为与普通的补全器不同。

老用户会记得shell中还有另一种拼写纠正形式，称为\``ESC-$`\或\``ESC-s`\。这只纠正文件名，不理解新的补全机制；使用它的唯一原因是它可能更快。但是，如果你使用`CORRECT`或`CORRECT_ALL` shell选项，你将使用旧的文件名纠正机制；目前还不可能改变这一点。

**`_expand`**\

这实际上执行扩展，而不是补全；区别在本章开头解释过。如果你使用它，你应该将tab绑定到`complete-word`，而不是`expand-or-complete`，因为否则在启动补全机制之前将执行扩展。由于扩展通常应该在补全之前尝试，这个补全器应该出现在`completers`样式值列表中的`_complete`及其相关项之前。

使用这个补全器而不是正常扩展的原因是你可以使用样式控制执行哪些扩展在\``:completion:*:expand:*`\上下文中。以下是相关样式：

**`glob`**
:   扩展glob表达式，换句话说，使用通配符进行文件名生成。

**`substitute`**
:   扩展包含活动的\``$`\或反引号的表达式。

但请记住，你需要

      bindkey '^i' complete-word

当使用这个补全器时，因为否则由正常绑定`expand-or-complete`运行的内置扩展机制将接管。

你还可以控制如何插入扩展。添加扩展的标签是`original`（大概不言自明），`all-expansions`，它指的是添加包含所有可能扩展的单个字符串（默认值，就像编辑器函数`expand-word`一样），和`expansions`，它指的是逐个添加的结果。通过改变尝试标签的顺序，如上面`tag-order`样式的描述，你可以决定这是如何发生的。例如，

      zstyle ':completion:*' completer _expand _complete
      zstyle ':completion::expand:*' tag-order expansions

设置为通过补全执行glob扩展，扩展逐个呈现（通常通过菜单补全，因为没有公共前缀）。将`expansions`改为`all-expansions`将插入列表，就像正常的扩展机制一样，而将其改为\``expansions original`\将保持逐个输入但也将原始字符串作为可能性呈现。你甚至可以拥有所有三个，即整个列表作为一个字符串成为可能性集中的一个。

还有一个`sort`样式，它确定生成的扩展是否将按补全通常排序的方式排序，或者保留为扩展生成的原始顺序。如果为`true`，它们将总是被排序，如果为`false`或未设置则从不排序，如果为`menu`，则对于`expansions`标签将被排序，但对于`all-expansions`标签将是一个按原始顺序的值的单个字符串。

当你只尝试生成`glob`扩展而不使用`substitute`时，有一个小问题。事实上，不需要太多思考就能看出像\``$PWD/*.c`\这样的表达式在`substitute`不活动时没有任何意义；它必须活动才能理解这样的表达式。但是，如果没有任何匹配项，这会很烦人：你最终会得到一个扩展，其中扩展的$PWD，但\``*.c`\仍然附加在末尾，这不是你想要的。如果你主要将`_expand`用于globbing，你可能想要将样式`subst-globs-only`设置为true：如果补全只扩展参数，并且globbing不做任何事情，则扩展被拒绝并且行保持不变。

`_expand`补全器还将使用样式

**`accept-exact`**
:   适用于以\``$`\或\``~`\开头的单词。假设有一个参数\``$foo`\和一个参数\``$foobar`\，并且你在行上有\``$foo`\。通常补全系统会在这一点上执行补全。但是，设置了`accept-exact`后，\``$foo`\将被扩展，因为它匹配一个参数。

**`add-space`**
:   意味着在扩展后添加一个空格，就像成功的补全一样——尽管目录被给予一个\``/`\。为了更精细的控制，它可以设置为单词`file`，这意味着只有在扩展的单词匹配已经存在的文件时才添加空格（其想法是，如果不存在，你可能想要进一步补全）。`true`和`file`都可以与`subst`结合，这防止在扩展\``${...}`\或\``$(...)`\形式的替换后添加空格。

**`keep_prefix`**
:   也解决了是否应该扩展\``~`\或\``$`\的问题。如果设置，前缀将被保留，因此将\``~/f*`\扩展为\``~/foo`\不会将\``~`\变成\``/home/pws`\。默认值是\``changed`\，这是`false`和`true`之间的中间地带：这意味着如果没有其他变化，即没有找到其他可能的扩展，则\``~`\或\``$`\将被扩展。如果此样式的效应是扩展与未扩展的单词相同，则将尝试`_expand`之后的列表中的下一个补全器。

**`suffix`**
:   与`keep_prefix`类似。所指的\`后缀\`是在以\``~`\或\``$`\开头的表达式之后不会成为该扩展一部分的内容。如果设置了此样式，并且存在这样的后缀，则不会执行扩展。因此，例如，\``~pw<TAB>`\可以扩展为\``~pws`\，但\``~pw/`\不符合扩展条件；同样，\``$fo`\和\``$fo/`\也是如此。此样式默认为`true`——因此如果你希望`_expand`总是扩展这样的表达式，你需要自己将其设置为`false`。

获得`_expand`补全器提供的扩展控制的更简单方法是使用`_expand_word`函数，通常绑定到`\C-xe`，它执行上面描述的所有操作，而不会与其它补全器混淆。在这种情况下，上下文字符串以\``:completion:expand-word`\开头，因此你可以为这个补全器设置不同的样式。

为扩展设置不同的优先级是补全器标签的一个很好的用途，例如

      zstyle ':completion:*' completer _expand:-glob _expand:-subst
      zstyle ':completion:*:expand-glob:*' glob yes
      zstyle ':completion:*:expand-subst:*' substitute yes

这是基本的设置，使`_expand`尝试glob补全，如果失败则进行替换，将结果作为扩展呈现。你几乎肯定想要添加细节来帮助这个过程。

**`_history`**\

这从shell的历史中补全单词，换句话说，你之前在先前行上输入或补全或扩展的所有内容。有三个样式影响它，`sort`和`remove-all-dups`；它们在下面描述了命令小部件`_history_complete_word`。该小部件本质上执行此补全器的工作作为一个特殊按键。

**`_prefix`**\

严格来说，这个补全器本身不执行补全，因此应该在下面以`_match`开头的组中。然而，它*看起来*在执行补全...让我解释一下。

许多shell包括zsh都有只补全光标前单词的功能，zsh补全术语称其为\`前缀\`。我在上面解释了`expand-or-complete-prefix`时提到了这一点；当你使用它而不是正常的补全函数时，最终补全的单词看起来像\``<prefix><completion><suffix>`\'，其中补全将\``<prefix>\'更改为\``<prefix><completion>\'，在整个过程中忽略`<suffix>`。

`_prefix`补全器允许你在正常补全中这样做。发生的情况是，补全器从左到右评估，直到找到补全。如果到达`_prefix`，则尝试仅在前缀上补全。因此，如果你的补全器是\``_complete _prefix`\，shell将首先尝试在整个单词、前缀和后缀上补全，然后仅在前缀上补全。只有第一个\`真正的\'补全器（`_complete`、`_approximate`、`_correct`、`_expand`、`_history`）被使用。

你可以通过在补全器列表中多次包含`_prefix`来多次尝试前缀补全；第二次，它将尝试列表中的第二个\`真正的\'补全器；所以如果它们是\``_complete _prefix _correct _prefix`\，你将首先得到普通的补全，然后是仅前缀的补全，然后是普通的纠正，然后是仅前缀的补全。你可以将任一`_prefix`补全器移动到你希望仅前缀版本被尝试的序列中的任何位置。

`_prefix`补全器将重新查找`completer`样式。这意味着你可以使用非默认的补全器集仅用于`_prefix`。这里，如手册中所述，是如何强制`_prefix`仅作为最后的手段使用，并且仅使用普通补全：

      zstyle ':completion:::::' completer _complete \ 
        <other-completers> _prefix
      zstyle ':completion::prefix:::' completer _complete

显示了完整的上下文，只是为了强调形式；一如既往，如果你不在乎，你可以使用通配符。在这种情况下，你可以*仅*使用`_prefix`作为补全器，并且永远不会尝试包括后缀的补全；然后你必须确保有`prefix`上下文的`completer`样式，否则将不会进行任何补全。

补全器标签技巧在这里再次有用：你可以在补全器列表中的任何你选择的位置多次调用`_prefix`，并强制它在每次查找不同的上下文。

      zstyle ':completion:*' completer _complete _prefix:-complete \ 
        _approximate _prefix:-approximate
      zstyle ':completion:*:prefix-complete:*' completer _complete
      zstyle ':completion:*:prefix-approximate:*' completer _approximate

这首先尝试普通补全，然后是仅前缀的补全，然后是近似补全，然后是仅前缀的补全。如上一段所述，完全可以省略原始的`_complete`和`_approximate`补全器，只使用带有`_prefix`前缀的形式。

`_prefix`补全器的一个陷阱：你必须确保设置了选项`COMPLETE_IN_WORD`。这可能听起来违反直觉：毕竟，`_prefix`强制补全*不*在单词内完成。关键在于，没有这个选项，补全只在单词末尾尝试，所以当你在`<prefix><suffix>`的中间输入`<TAB>`时，在补全系统有机会看到那里有什么之前，光标被移动到后缀的末尾之后，因此整个事情被视为前缀，没有后缀。

`_prefix`补全器还有一个样式：\``add-space`\。这使得`_prefix`在补全前缀时添加一个真正的空格，而不是假装那里有一个空格，因此将补全的单词与原始后缀分开；否则它会简单地将结果单词连接在一起，就像`expand-or-complete-prefix`通常做的那样。

**`_ignored`**\

像`_prefix`一样，这是一个混合体，在已经生成的补全之后进行清理。它允许你有已经被样式\``ignored-patterns`\拒绝的补全。我将在下面描述它，但它的效果非常简单：对于给定的上下文，你指定的模式列表将与可能的补全进行匹配，并且任何匹配的都将从列表中删除。`_ignored`补全器允许你在补全器列表的后面检索那些被删除的补全，以防没有其他匹配。

这由`$fignore`机制使用——一个文件列表的后缀，这些文件通常不被补全——实际上建立在`ignored-patterns`之上，所以如果你以zsh用户熟悉的方式使用它，在没有未忽略的匹配时显示被忽略的匹配，你需要在补全器列表中包含`_ignored`。

如果只有一个可能的补全，`_ignored`有一个稍微令人烦恼的功能，因为它会被无条件地插入。这并不令人惊讶，但如果你真的不想要这个选择，可能会很烦人。有一个样式`single-ignored`，你可以将其设置为`show`——只显示单个被忽略的匹配，不要插入它——或者设置为`menu`——进入菜单补全，这样TAB会循环你和你原来输入的内容之间的补全。后者提供了一种非常自然的方式来处理被忽略的文件；这有点像在说\`好吧，我找到了这个，但你可能不喜欢它，所以再按一次tab如果你想要回到你原来的内容\`。

我说这就像`_prefix`，实际上你可以在相同的上下文中为`_ignored`指定补全器，就像使用\``:completion:*:ignored:*`\一样。这意味着我的描述有点过于简化：`_ignored`实际上并不使用之前被忽略的补全；相反，当它被调用时，它生成一个可能性列表，其中通过`ignore-patterns`匹配的选择——或内部使用`$fignore`——不会被忽略。所以它应该真的被叫做\``_not_ignored`\，但它不是。

**`_match`**\

这和剩下的补全器是工具，当放入补全列表时会影响上面给出的主要补全器，而不是自己执行补全。

`_match`补全器应该出现在`_complete`*之后*；它是`GLOB_COMPLETE`选项的更灵活形式。换句话说，如果`_complete`没有成功，它将尝试将行上的单词作为模式匹配，而不仅仅是固定字符串，与可能的补全匹配。为了使其像正常补全一样工作，它通常表现为在光标位置插入一个\``*`\，即使单词已经包含通配符。

你可以通过\``match-original`\样式控制添加\``*`\；如果未设置此样式，则发生正常行为。如果设置为\``only`\，则不插入\``*`\，如果设置为\``true`\，或实际上任何其他字符串，它将首先尝试不带\``*`\，然后带。

例如，考虑输入\``setopt c*ect<TAB>`\与使用中的`_match`补全器。通常这会产生两种可能性，
\``correct`\和\``correctall`\。在设置样式后，

      zstyle ':completion::match:*' original only

在你点击\``TAB`\的地方不会插入\``*`\，所以\``correct`\是唯一可能的匹配。

`_match`补全器以与`_approximate`相同的方式使用`insert-unambiguous`样式。

**`_all_matches`**\

这与执行扩展而不是补全有类似的效果：
所有可能的补全都会插入到命令行上。
然而，它使用普通上下文补全的结果来实现这一点。补全系统实现这一点的正常方式是通过影响随后调用的任何补全器的行为——因此你需要将`_all_matches`放在你希望它具有此行为的补全器列表之前。

你不太可能希望对每种类型的补全都这样做，因此有两种限制其效果的方法。首先，有`avoid-completer`样式：你可以将其设置为不应插入所有匹配项的补全器列表，它们将被正常处理。

然后是样式`old-matches`。这强制`_all_matches`使用现有的匹配列表（如果存在），而不是这次生成的列表。你可以将样式设置为`only`而不是true；在这种情况下，`_all_matches`永远不会应用于这次生成的补全，它只会使用任何已存在的补全列表。

如果应用于正常补全生成，这可能会很麻烦——永远不会生成通常的列表，因为`_all_matches`只会插入上次的非存在列表——因此手册建议两种其他使用带有此样式的补全器的方法。首先，你可以向样式的使用添加条件：

      zstyle -e ':completion:*' old-matches 'reply=(${NUMERIC:-false})'

这在没有非零数字参数时返回false；如果你在emacs模式下输入`<ESC>1`，或在vi模式下只输入`1`，然后补全，它将插入由紧接在前的补全生成的所有值。

否则，你可以单独绑定`_all_matches`。这可能是更有用的；复制手册条目：

      zle -C all-matches complete-word _generic
      bindkey '^Xa' all-matches
      zstyle ':completion:all-matches:*' completer _all_matches
      zstyle ':completion:all-matches:*' old-matches only

这里我们基于`complete-word`小部件生成一个新的补全，称为`all-matches`——这个名称是任意的但方便。我们将它绑定到按键序列`^Xa`，并给它两个正常补全不会看到的特殊样式。对于`completer`我们只设置`_all_matches`，对于`old-matches`我们设置`only`；效果是`^Xa`只会插入由上次补全生成的所有补全，无论那是什么——它不必是普通的上下文补全，它可能是任何补全小部件的结果。

**`_list`**\

如果你在补全器列表中有这个（在开头和任何地方一样好），那么第一次你尝试补全时，你只会得到一个列表；什么都不会改变，甚至不会插入一个共同的前缀。第二次，补全继续正常进行。这就像输入`^D`，然后按tab，但只用一个键。这与通常的`AUTO_LIST`行为不同，因为它完全不考虑补全是否模糊；你总是第一次得到列表，第二次总是按通常的方式进行补全。

`_list`补全器还使用`condition`样式，它的工作方式有点像`_expand`补全器的样式：它必须被设置为对应于\`true\'的值，以便`_list`延迟行为生效。你可以通过使用`zstyle`定义样式时的`-e`选项来测试特定的`$NUMERIC`值或任何其他条件。

最后，布尔样式`word`也相关。如果为false或未设置，`_list`在决定是否已更改时检查整行，因此补全应延迟到下次按键。如果为true，它只检查当前单词。请注意，`_list`对那些补全调用之间发生的事情没有了解；查看命令行是它唯一的资源。

**`_menu`**\

这只是在shell代码中实现了菜单补全；它应该在`completers`样式中的\`real\'补全生成器之前。它忽略了`MENU_COMPLETION`选项和其他相关选项，并且正常的菜单补全小部件与它配合不好。但是，你可以复制它并编写自己的补全器。

**`_oldlist`**\

当你习惯使用特殊补全函数时，即命令不同于标准补全系统的命令时，这个补全器最有用。它能够保留一个旧的补全列表，否则这个列表会被新生成的列表替换。这有两个方面。

首先，列出。假设你尝试从shell历史中补全某些内容，使用绑定到\``ESC-/`\的命令。例如，我输入了\``echo ma<ESC-/>`\并得到了\``max-errors`\。在这一点上，你可能想要列出可能的补全。不幸的是，如果你输入`^D`，它将简单地列出所有通常的上下文补全——对于`echo`命令，这不是特别处理的，这些只是文件。所以它不起作用。通过将`_oldlist`补全器放入`completers`样式中*在`_complete`之前*，它可以工作，因为旧的匹配列表被保留用于`^D`使用。

在这种情况下，你可以通过将`old-list`样式设置为`always`或`never`来强制旧列表行为的开启或关闭；通常它显示当前补全集的列表（如果尚未显示），否则生成标准列表。你甚至可以将`old-list`的值设置为一个补全器列表，这些补全器将始终以这种方式保留其列表。

`_oldlist`有用的另一个地方是在菜单补全中，这里出现了完全相同的问题：如果你从特殊命令生成菜单，然后尝试通过按tab循环，补全将寻找正常的上下文匹配而不是。这一次有解决办法——重复使用特殊命令键而不是tab。这对于多个键序列来说相当乏味。再次，`_oldlist`解决了这个问题，你也可以通过样式`old-menu`控制行为，它采用布尔值（默认情况下是开启的）。正如奥威尔所说，oldlisters unbellyfeel menucomp。

**排序补全器**\

我给出了关于补全器应该按什么顺序的建议，这可能会令人困惑。因此，这里是一个建议的顺序；只需省略你不想使用的补全器：

      _all_matches _list _oldlist _menu _expand _complete _match
        _ignored _correct _approximate _prefix 

其他顺序当然也是可能的，甚至有用的：例如，`_all_matches`补全器适用于所有未在`avoid-completer`样式中列出的后续补全器，因此你可能有充分的理由将它进一步向下移动列表。

这是我在上面提到补全器列表之前所说的标签补全器的例子，通过这种方式补全器可以在不同的名称下查找。

      zstyle ':completion:*' completer _complete _approximate:-one \ 
        _complete:-extended _approximate:-four
      zstyle ':completion:*:approximate-one:*' max-errors 1
      zstyle ':completion:*:complete-extended:*' \ 
        matcher 'r:|[.,_-]=* r:|=*'
      zstyle ':completion:*:approximate-four:*' max-errors 4

这按顺序尝试以下内容。

1.  普通的，无附加功能的补全。
2.  允许一个错误的近似补全，如第二个样式所示。
3.  启用了扩展补全的普通补全，如第三个样式所示。抱歉，这在稍后谈论`matcher`样式之前将是一个黑盒子；现在，你只需相信我的话，这个样式允许方括号中的字符在前面有通配符，所以\``a-b`\可以补全为\``able-baker`\，等等。
4.  允许最多四个错误的近似补全，如最终样式所示。

这里是一个相当虚假的例子。你有一个包含以下内容的目录：

      foobar  fortified-badger  frightfully-barbaric

实际上，这并不虚假，因为我刚刚创建了一个。首先尝试\``echo foo<TAB>`\；不出所料，你得到\``foobar`\。现在尝试在\``echo`\后补全\``fo-b<TAB>`\：基本补全失败，它到达\`\_approximate:-one\'并发现它被允许一个错误，所以接受补全\``foobar`\再次。现在尝试\``fort-ba<TAB>`\。这次没有任何东西启动，直到第三个补全，它有效地允许它匹配\``fort*-ba*<TAB>`\，所以你看到\``fortified-badger`\（不，我自己从未见过一个，但它们是夜行性的，你知道）。最后，尝试\``fortfully-ba<TAB>`\；最后一个条目，允许最多四个错误，贴心地将\``or`\'纠正为\``righ`\'，你得到\``frightfully-barbaric`\。好吧，这个例子有点疯狂，但我想你可以看到这些功能很有用。如果这让你感觉更好，我试了四到五次才把这个样式弄对。

### 6.5.2：更改列表的格式：组等。

**`format`**\

如果你想知道补全列表中的补全来自哪里，可以使用此样式。最基本的用法是为任何补全上下文中的`descriptions`标签设置它。它接受一个字符串值，其中应出现\``%d`\'；这将被替换为正在补全内容的描述。例如，我使用：

      zstyle ':completion:*:descriptions' format 'Completing %d'

如果我输入`cd^D`，我会看到这样的列表（直到我定义`group-name`样式为止）：

      Completing external command
      Completing builtin command
      Completing shell function
      cd                cddbsubmit        cdp               cdrecord
      cdctrl            cdecl             cdparanoia        cdswap
      cdda2wav          cdmatch           cdparanoia-yaf
      cddaslave         cdmatch.newer     cdplay
      cddbslave         cdot              cdplayer_applet

顶部的描述与标签名称相关——通常有唯一的对应关系——但以更易读的形式；要获取标签名称，你需要使用`^Xh`。你无疑会看到不同的东西，但重点是列出的补全是外部命令（例如`cdplay`）、内置命令（`cd`）和shell函数（`cdmatch`，这恰好是旧式补全的遗留物，显示你多久清理一次函数目录）的混合，通常知道你拥有什么是相当方便的。

你可以在描述中使用一些提示转义，特别是那些打开或关闭突出显示模式（\``%S`\'，\``%s`\）、粗体文本（\``%B`\'，\``%b`\）和下划线文本（\``%U`\'，\``%u`\）的转义，使描述从补全列表中突出。

你可以为除`descriptions`之外的其他标签设置此样式，并且这样定义的格式将仅用于该标签的补全。

**`group-name`, `group-order`**\

在上面的`format`示例中，你可能想知道是否可以使不同类型的补全分别出现，连同描述一起。你可以使用*组*来做到这一点。它们也与标签相关，尽管你可以通过`group-name`样式定义组名，因此可以在任何上下文中为补全给出不同的名称。但是，为了开始，最容易给样式的值一个空字符串，这意味着组名只是标签的名称。换句话说，

      zstyle ':completion:*' group-name ''

为每个标签分配一个不同的组名。稍后，你可以通过更具体的模式来微调这个，如果你决定你想要各种标签具有相同的组名。如果没有定义组名，则使用的组称为\``-default-`\，所以这是在你发出上面的`zstyle`命令之前发生的事情；所有匹配都在该组中。

组的原因是：同一组中的匹配项显示在一起，不同组中的匹配项分别显示。因此，从前一个示例中使用了`format`和`group-name`样式的补全列表变为：

      Completing external command
      cdctrl            cddbsubmit        cdparanoia        cdrecord
      cdda2wav          cdecl             cdparanoia-yaf
      cddaslave         cdot              cdplay
      cddbslave         cdp               cdplayer_applet
      Completing builtin command
      cd
      Completing shell function
      cdmatch                 cdmatch.newer           cdswap

你可能会发现这更有帮助，或者你可能会觉得更混乱，这取决于我无法控制的深层心理因素。

如果（且仅当）你使用`group-name`，你也可以使用`group-order`。顾名思义，它决定了不同补全组显示的顺序。它有点像我在首次介绍标签时描述的`tag-order`：值只是一组按你想要看到的顺序排列的组名。手册中的示例与我刚才显示的列表相关：

      zstyle ':completion:*:-command-' group-order \ 
          builtins functions commands

\-\- 请记住，当命令名称而不是它们的参数被补全时，使用\``-command-`\上下文。不出所料，该列表现在变为：

      Completing builtin command
      cd
      Completing shell function
      cdmatch                 cdmatch.newer           cdswap
      Completing external command
      cdctrl            cddbsubmit        cdparanoia        cdrecord
      cdda2wav          cdecl             cdparanoia-yaf
      cddaslave         cdot              cdplay
      cddbslave         cdp               cdplayer_applet

如果你用`^Xh`调查可用的标签，你会看到还有其他标签，如别名，其顺序我们尚未定义。这些出现在你已定义顺序的标签之后，并以生成匹配的函数决定的某种顺序出现。

**`tag-order`**\

正如我已经说过的，我已经描述过了，但为了完整性再次出现。

**`verbose`, `auto-description`**\

这些是`format`的亲戚，因为它们向列表添加了有帮助的消息。如果`verbose`为真，生成匹配的函数可能会酌情决定显示更多关于它们的信息。最常见的案例是描述选项；标准函数`_describe`处理大量选项的描述，测试`verbose`样式，并将打印有关正在补全的选项的信息。

你还可以设置字符串样式`auto-description`；它对选项也很有用，在它们没有特殊描述但它们确实有一个后续参数的情况下，补全已经知道。然后，用于verbose打印的参数描述将作为\``%d`\'在`auto-describe`中可用，所以像手册推荐的\``specify: %d`\'这样的东西将记录选项本身。因此，如果一个命令接受\``-o <output-file>`\并且参数有描述\``output file`\，那么\``-o`\在作为可能的补全出现时将有描述\``specify: output file`\，如果它没有自己的描述。实际上，大多数标准补全函数识别的选项已经有它们自己的描述提供，这比大多数人可能需要的要更微妙。

**`list-colors`**\

这用于根据文件类型以不同颜色显示文件匹配列表。它基于`$LS_COLORS`环境变量的语法，由GNU版本的`ls`使用。你需要一个能够显示颜色的终端，如彩色xterm，并应确保加载了`zsh/complist`库（如果你使用`menu`样式设置的菜单选择，或使用此样式，它应该会自动加载）。但你可以明确确保：

      zmodload -i zsh/complist

`-i`在模块已加载时保持安静。要安装一组标准的默认颜色，你可以使用：

      zstyle ':completion:*' list-colors ''

\-\- 注意使用\``default`\标签\-\- 因为空字符串将值设置为默认值。

如果你对此不够满意，这里有一些更详细的说明。参数`$ZLS_COLORS`是`zsh/complist`使用的系统中最底层的部分。有一个简单的内置默认值，而将样式设置为空字符串相当于：

      ZLS_COLORS="no=00:fi=00:di=01;34:ln=01;36:\ 
      pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:\ 
      ex=01;32:lc=\e[:rm=m:tc=00:sp=00:ma=07:hi=00:du=00

它与`$LS_COLORS`具有基本相同的格式，并且实际上你可以通过使用与`ls`一起提供的`dircolors`命令获得一组更有用的值：

      ZLS_COLORS="no=00:fi=00:di=01;34:ln=01;36:\ 
      pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:\ 
      or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:\ 
      *.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:\ 
      *.z=01;31:*.Z=01;31:*.gz=01;31:*.deb=01;31:\ 
      *.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:\ 
      *.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:\ 
      *.mpg=01;37:*.avi=01;37:*.gl=01;37:*.dl=01;37:"

你应该查看`zsh/complist`模块的手册以获取详细信息，但特别注意添加了类型\``ma`\，它指定菜单选择中当前匹配的显示方式。默认情况下，它使用突出显示模式——与提示序列`%S`相同的效果，你可以用\``print -P %Sfoo`\显示。

但是，你需要直接定义样式，因为补全总是使用它来设置`$ZLS_COLORS`；否则它不知道它找到的值是来自用户还是来自某个样式的先前值。这采用以下格式：

      zstyle ':completion:*' list-colors "no=00" "fi=00" ...

你可以使用已经定义的`$LS_COLORS`：

      zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

（将参数分割为冒号上的数组）因为`$LS_COLORS`对`ls`仍然有用，即使不值得直接设置`$ZLS_COLORS`。这应该意味着GNU ls和zsh产生相似外观的列表。

允许一些特殊效果。你可以使用模式来告诉文件名如何匹配：这实际上是默认行为的一部分，例如\'*.tar=01;31\'强制tar文件变为红色。在这种情况下，你仅限于\``*`\后跟一个字符串。但是，有一种方法可以为任何匹配指定颜色，而不仅仅是文件，并且对于任何模式：使用`=<pat>=<col>`。这里是两种让作业在\``kill`\命令的进程列表中变为红色的方法。

      zstyle ':completion:*:*:kill:*' list-colors '=%*=01;31'

这使用了刚刚描述的方法；作业以\``%`\开头。

      zstyle ':completion:*:*:kill:*:jobs' list-colors 'no=01;31'

这使用标签而不是模式来匹配作业行。它有各种优势。因为你使用标签，所以更容易为所有使用作业的命令更改此设置，而不仅仅是kill——只需从字符串中省略\``kill`\。用其他方法不切实际，因为它会匹配太多你不想要的东西。你也不依赖于使用特定的模式。最后，如果你用\``format`\描述尝试它，你会看到那个描述也得到了颜色，因为它匹配了正确的标签。请注意使用\``no`\来指定这适用于普通匹配；文件类型的其他两个字母代码在这里没有用。

但是，你可以使用通用模式形式使用一个甚至更特殊的效果。通过在模式内使用\``(#b)`\打开\`反向引用\`，括号是活动的，括号匹配的位可以单独着色。你可以通过扩展颜色列表来做到这一点，每个代码前面都有一个\``=`\符号，额外的元素将用于为括号匹配的内容着色。这里是\``kill`\的另一个例子，它将进程号变为红色，但让其余部分保持原样。

      zstyle ':completion:*:*:kill:*:processes' list-colors \ 
        '=(#b) #([0-9]#)*=0=01;31'

象形文字是扩展的globbing模式。你应该注意，在样式内，`EXTENDED_GLOB`选项总是开启的——这是使\``#b`\生效所必需的。特别是，\``#`\表示\`前面位模式的零次或多次重复\`与扩展的glob模式；有关完整详细信息，请参阅globbing手册页。

**`ignored-patterns`**\

许多shell，包括zsh，都有一个参数`$fignore`，它给出了一个后缀列表；以这些结尾的文件名不会在补全中使用。典型值是：

      fignore=(.o \~ .dvi)

因此，正常的文件补全不会产生对象文件、EMACS备份文件或TeX DVI文件。

`ignored-patterns`样式是对此的扩展。它采用数组值，如`fignore`，但有各种差异。首先，这些值是模式，应该匹配要补全的*整个*值，包括前缀（如文件名的目录部分）以及后缀。其次，它们适用于*所有*补全，而不仅仅是文件，因为你可以使用样式机制来调整它以在任何你想要的地方应用，直到特定标签。

因此，你可以用以下内容替换上述`$fignore`的使用：

      zstyle ':completion:*:files' ignored-patterns '*?.o' '*?~' '*?.dvi'

用于标签\``files`\在补全上下文中。额外的\``?`\是因为`$fignore`小心只应用于真正的后缀，即字符串前面有内容，而\``?`\强制至少有一个字符存在。

实际上，这与`$fignore`不完全相同，因为除了你已经见过的目录标签之外，还有其他文件标签；`globbed-files`和`all-files`。前者是补全函数指定模式的情况，例如\``*.dvi`\用于`dvips`命令后面的文件。这些不使用此样式，因为模式已经足够指定。这遵循旧补全系统中`$fignore`的行为。另一个细微差别，如我在上面讨论`_ignored`补全器时所说，是你可以选择在正常补全失败时是否看到那些被忽略的文件，方法是在补全器列表中包含`_ignored`或不包含。

另一个标签`all-files`在`globbed-files`标签失败时应用，并说在这种情况下任何旧文件都足够好；你可以通过`tag-order`样式安排这种情况的发生。在这个例子中，

      zstyle ':completion:*:*:dvips:argument*' \ 
        tag-order globbed-files all-files

足以说明如果从模式中没有产生文件，你想看到所有文件；换句话说，如果目录中没有\``*.dvi`\文件。最后这个漫游的重点：由于`all-files`标签与`files`标签是分开的，在这种情况下你真的会看到所有文件（除了以\``.`\开头的文件，像往常一样）。你可能会发现这很有用，但你可以轻松地让`all-files`标签的行为与`files`标签相同：

      zstyle ':completion:*:(all-|)files' ignored-patterns '*?.o' '*?~' '*?.dvi'