------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [下一章](zshguide02.html)

------------------------------------------------------------------------

[]{#intro}[]{#l1}

# 第1章：简介

Z-Shell，简称'zsh'，是UNIX系统的命令解释器，用UNIX行话来说，就是' shell'，因为它包裹在你使用的命令周围。然而，zsh不仅仅是一个shell，它还是一个功能特别强大的shell——而且是免费的，并且在定期维护中——有很多交互特性，让你能够以最少的麻烦完成最大的工作。当然，要做到这一点，你需要知道shell能做什么以及如何做，这就是本指南的用途。

最基本的要点：我假设你可以访问UNIX系统，否则本指南的其余部分对你来说就没有多大用处了。你也可以通过安装Cygwin在Windows下使用zsh，它为程序提供了一个类似UNIX的环境——鉴于标准Windows命令解释器的弱点，这是件好事。有较旧版本的zsh移植到Windows上，可以在原生环境下运行，即不需要UNIX环境，尽管这些在某些方面行为略有不同，我不再进一步讨论。

我还假设你对UNIX有一些基本了解；你应该知道文件系统的工作原理，即'/home/users/pws/.zshrc'和'../file'的含义，以及一些基本命令，例如'ls'，你应该有使用'rm'意外完全删除错误文件等类似操作的经验。在像'rm file'这样的命令中，我经常提到'命令'(当然是'rm')和'参数'(命令后面由它使用的其他任何内容)，并将你一次输入的完整内容称为'命令行'。

你还需要zsh本身；如果你正在阅读这个文档，你可能已经有了它，但如果你没有，你或你的系统管理员应该阅读[附录A](zshguide08.html#appa)。现在，我们假设你正坐在一个已经运行着zsh的终端前。

现在来谈谈shell。登录后，你可能会看到一些提示符(屏幕上的一系列符号，表示你可以输入命令)，比如'$'或'%'，前面可能还有其他一些文本——稍后，我们将看到如何以有趣的方式更改这些文本。该提示符来自shell。输入'print hello'，然后用退格键删除'hello'并输入'goodbye'。现在按'Return'键(或'Enter'键，我从现在开始只说`<RET>`，同样`<TAB>`代表制表键，`<SPC>`代表空格键)；除非你的系统上有严重的恶作剧问题，否则你会看到'goodbye'，shell会返回另一个提示符。从你按`<RET>`开始到那时，你一直在与shell及其编辑器交互，称为'Z-Shell Line Editor'或简称'zle'；直到那时shell才去告诉'print'命令打印出一条消息。所以你可以看到shell的重要性。

然而，如果你所做的只是输入像那样的简单命令，为什么需要复杂的东西呢？在这种情况下，你不需要；但现实生活并非如此简单。在本指南的其余部分，我将描述如何在zsh的帮助下：

-   通过使用启动文件自定义你的工作环境，
-   编写你自己的命令来缩短任务并将内容存储在shell变量('参数')中，这样你就不用记住它们，
-   使用zle来最小化你必须做的输入量——在zsh中，你甚至可以通过这种方式编辑小文件，
-   使用zsh非常复杂的文件名生成(俗称'globbing')系统为特定命令如'mv'或'ls'选择要使用的文件，
-   告诉编辑器你与特定命令一起使用的参数类型，这样你只需要输入部分名称，它就会完成其余部分，使用zsh无与伦比的可编程补全系统，
-   使用最新版本的zsh提供的额外附加组件('模块')来做一些通常在shell中根本无法做的事情。

这只是一个小样本。由于有太多内容要说，本指南将重点介绍zsh做得最好的事情，特别是它拥有而其他shell没有的功能。下一章通过尝试解释如何按你想要的方式设置shell来给出一些基础知识。像本指南的其余部分一样，它不打算详尽无遗，对此你应该查阅shell手册。

有些其他事情你可能应该立即知道。首先，shell总是在运行，即使你输入的命令也在运行；shell只是挂起等待它完成：你可能从其他shell了解到通过在命令后放置'&'将命令放在**后台**，这意味着shell不会等待它们完成。即使命令在前台运行，shell也在那里，但这种情况下什么也不做。

其次，它不仅仅运行其他人的命令，它还有一些自己的命令，称为**内置命令**或简称**内置命令**，你甚至可以将自己的一系列shell指令作为**函数**添加；内置命令和函数总是在shell本身中运行。这很重要，因为不在shell本身中运行的东西无法影响它，因此无法更改参数、函数、别名以及我将讨论的所有其他内容。

[]{#l2}

## 1.1: 其他shell和其他指南

如果你想要对shell的工作原理、语法(即如何编写命令)以及如何编写脚本和函数有一个基本了解，你应该阅读有关这个主题的许多书籍之一。特别是，你会从描述Korn shell(ksh)的书中获得最多收获，因为zsh与之非常相似——如此相似以至于我值得在我们进行的过程中指出差异，因为它们可能会让ksh用户感到困惑。最新版本的zsh可以非常接近地模拟ksh(严格来说是1988版本的ksh，尽管越来越多地具有1993版本的功能)，虽然不完美，而且你观察得越仔细，就越不完美。然而，重要的是要意识到如果你只是启动任何旧的zsh，不能保证它会被设置成像ksh一样工作；除非你或你的系统管理员更改了一些设置，否则肯定不会。你可能不会立即看到这一点，但它会以微妙的方式影响shell。我稍后会更多地讨论模拟。

还有其他一些shell值得一提。所有UNIX shell的鼻祖是sh，现在被称为Bourne shell，但最初只是被称为' shell'。故事与ksh相似：zsh可以非常接近地模拟sh(比ksh更接近，因为sh要简单得多)，但通常你需要确保它被设置成这样做，然后你才能确定它会模拟sh。

你还可能遇到'Bourne-Again Shell'，bash。这是GNU项目编写的sh的免费增强版——但它并不总是沿着ksh的路线增强，因此在许多方面它与zsh非常不同。在一些类似UNIX的自由系统如Linux/GNU(这就是人们通常所说的Linux)上，命令sh实际上是bash，所以你应该格外小心当尝试确保在所谓的'sh'下运行的东西也会在zsh下运行。一些Linux系统还有另一个更简单的Bourne shell克隆版，ash；因为它更简单，所以它更像原始的Bourne shell。

一些更现代的操作系统谈论'POSIX shell'。这是标准化UNIX shell的一种尝试；它最像Korn shell，虽然有点令人困惑，但它通常只被称为sh，因为标准说它应该是。通常，这意味着你可以对你的sh更自由一些，它仍然会做你期望的事情。Zsh已经做出了一些努力来符合标准，但你必须告诉它——再说一遍，仅仅启动'zsh'不会有正确的设置。

还有另一个常见的shell家族，不幸的是，语法不兼容。这个家族的源头是C-Shell，csh，之所以这样称呼是因为它的语法看起来更像C编程语言。当唯一可用的其他shell是sh时，它变得很流行，因为csh有更好的交互功能，比如作业控制。然后它被增强为tcsh，它具有许多你也会在zsh中找到的交互功能，因此变得非常流行。尽管有这些共同功能，zsh的语法非常不同，所以你不应该尝试在zsh中使用csh/tcsh命令超出最简单的范围；但如果你是tcsh用户，你会发现你习惯的几乎所有功能在zsh中都有，而且还有更多。

[]{#l3}

## 1.2: zsh版本

在撰写本文时，最广泛使用的最新zsh版本是4.0.6。你通常会发现两套较旧的zsh版本。3.0系列，其中最新发布的是3.0.9，是一个稳定版本，自从zsh 3的第一个发布版本以来只有错误修复。3.1系列是测试版本，有很多新功能；其中最新的3.1.9与4.0.1没有太大区别；主要变化是shell现在已被宣布为稳定版本，因此像zsh 3一样，将有一组标记为4.0的错误修复和一组标记为4.1的新功能。由于4.0取代了所有zsh 3版本，我会尽量保持简单并谈论这个版本；但时不时地指出旧版本的不同之处会有所帮助。

zsh的一个显著特性是命令行参数的补全。该系统在3.1.6和3.1.7版本中发生了变化，使其更具可配置性，并且(只要你保持头脑清醒)稍微不那么晦涩。因此，我不会详细描述使用'compctl'命令的旧补全系统；在zsh FAQ中给出了非常简要的介绍。然而，旧系统仍然可用，但我们强烈建议新用户从新系统开始。请参见[第6章](zshguide06.html#comp)'补全，新旧对比'了解新式补全的详细信息。

4.0和4.1之间不会有大的区别，只是一些错误修复和一些进化变化，加上一些额外的模块。在[第7章](zshguide07.html#ragbag)中会有一些关于4.1新功能的说明，但你为4.0编写的任何东西在可预见的未来都不太可能过时。

[]{#l4}

## 1.3: 约定

我所说的大部分内容都是相对自成一体的(这意味着我使用的短语如"如前所述"和"如我稍后将讨论的"比真正的文体学家希望的更多，而且我提到其他章节的次数过多)，但在你跳进去之前，我应该提醒你注意一些要点。

我经常像你将它们写入文件中以供执行(一个"脚本"或一个"函数"，不同之处将在各处讨论)一样编写代码块：

      if [[ $ZSH_VERSION = 3.* ]]; then
        print This is a release of the third version of zsh.
      else
        print This is either very new or very old.
      fi

但有时我会显示你交互式地输入到shell中的内容，以及shell返回给你的内容：

      % print $ZSH_VERSION
      3.1.9
      % print $CPUTYPE
      i586

在这里，'%'显示shell为了告诉你它正在期待输入而显示的提示符(紧随其后的空格也是它的一部分)。实际上，你可能在百分号之前看到一些东西，比如机器名称或你的用户名，或者可能更花哨一些。我已将其简化到最低限度以避免混淆，并保留它作为提醒这是你输入的行。

如果你正在阅读本指南的电子版本，并且想要复制带有'%'的行到终端中执行，有一种巧妙的方法可以做到这一点，你甚至不需要先编辑该行：

      alias %=' '

然后，行首的%将被转换为无；空格只是表示后面可能有别名需要展开。所以'\% print $CPUTYPE'这行将忽略'%'并执行该行的其余部分。(我希望这是显而易见的，但你*自己的*提示符总是被忽略；这只是如果你从指南中复制提示符到shell中时的情况。)

zsh中有许多不同类型的对象，但最常见的之一是参数，我总是会在前面加上'$'符号显示，如'$ZSH_VERSION'，以提醒你它们是参数。你需要记住，当你设置或处理参数本身而不是它的值时，你要省略'$'。何时以及是否需要它应该在我们进行过程中变得更加清楚。

我要特别显示的其他对象是shell选项——关于shell如何工作的选择——我这样写：'SH_WORD_SPLIT'，'NO_NOMATCH'，'ZLE'。同样，这并不是全部故事，因为每当shell期望选项时，你可以用大写或小写书写，随意使用多少下划线；而且经常在代码块中我会使用最简单的形式：'shwordsplit'，'nonomatch'，'zle'。如果你有哲学思维，你可以认为这表达了编程和实际编程之间的类别差异，但实际上这只是我不一致。

你可能会觉得奇怪，我用三个连字符来表示破折号。这实际上是本指南印刷版本使用的约定，它是用LaTeX制作的。总有一天，我会把它变成一个宏，在其他版本中会正确显示；但同样，总有一天宇宙会终结。

[]{#l5}

## 1.4: 致谢

我感谢各种zsh用户的评论。特别是，我收到了Bart Schaefer、Sven 'Mr Completion' Wischnowsky和Oliver Kiddle的详细评论和更正。通常会加上任何剩余的错误都是我自己的，但这显而易见得可笑。我的意思是，谁写了这个？别在意了。

本文大部分内容是在Linux Mandrake(红帽的一个衍生版本)的一个或另一个版本上编写的，使用了常规的GNU和XFree86工具。由于所有这些都是免费的，这样说一声"谢谢"的礼物似乎很公平。它也比这台特定PC自带的操作系统工作得好多了。

------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [下一章](zshguide02.html)

------------------------------------------------------------------------