------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide02.html)
-   [下一章](zshguide04.html)

------------------------------------------------------------------------

[]{#syntax}[]{#l29}

# 第3章：处理基本shell语法

本章是对[第2章](zshguide02.html#init)中出现的大部分内容的更彻底检查；更具体地说，我假设你正坐在终端前，准备使用你在初始化文件中设置的功能，并希望了解足够的知识来启动它们。实际上，你可能会花大部分时间编辑命令行，特别是完成命令——这两项活动将在后面的章节中介绍。现在我要谈论的是命令以及使用它们时伴随的语法。这将让你编写shell函数和脚本来为你做更多的工作。

在接下来的内容中，经常有几段连续的段落涉及相当次要的功能。如果你发现你第一次就读完了所有这些内容，也许你需要多出去走走。大多数人可能会发现最好先浏览一下以了解主题内容，然后如果他们后来发现自己想了解更多关于shell命令和语法的某个特定方面时再回来。

语法的一个方面留给了[第5章](zshguide05.html#subst)：关于它有太多内容，如果你知道足够多以正确使用它，它可以非常有用，不能都挤在这里。主题是扩展，涵盖了许多东西，如参数扩展、globbing和历史扩展。你已经在[第2章](zshguide02.html#init)中遇到了这些的基础知识；但如果你想了解如何用globbing表达式精确地挑选特定文件，或者如何使单个参数扩展将长表达式简化为你需要的单词，你应该阅读那一章；它基本上是自包含的，所以你不必一定要知道本章的所有内容。

我们从任何命令行解释器中最基本的问题开始，运行命令。如你所知，你只需输入由空格分隔的单词，其中第一个单词是命令，其余的是它的参数。区分命令类型是很重要的。

[]{#l30}

## 3.1: 外部命令

外部命令是最容易的，因为它们与shell的交互最少——许多由shell本身提供的命令，如下一节所述，被内置到shell中，特别是为了避免这种困难。

因此主要问题是如何找到它们。这是通过参数`$path`和`$PATH`完成的，正如我在[第2章](zshguide02.html#init)中描述的，它们是联系在一起的，因为虽然第一个在shell内部更有用——作为一个数组，它的各个部分可以单独操作——第二个是由shell调用的其他命令使用的；在行话中，`$PATH`是"导出到环境"，这意味着由shell调用的其他命令可以看到它的值。

所以假设你的`$path`包含

      /home/pws/bin /usr/local/bin /bin /usr/bin

你尝试运行`ls`。Shell首先在`/home/pws/bin`中查找名为`ls`的命令，然后在`/usr/local/bin`中，然后在`/bin`中找到它，所以它执行`/bin/ls`。实际上，操作系统本身知道路径，如果你以正确的方式执行命令，shell严格来说是不需要的。

这里有一个细微之处。Shell试图记住命令的位置，所以下次可以快速找到它们。它将它们保存在一个所谓的"哈希表"中，你会在文档中到处看到"哈希"这个词：它只是意味着给定一个特定键时快速找到某个值的方法。在这种情况下，给定命令的名称，shell可以快速找到它的路径。你可以通过输入`hash`看到这个表，形式为`*key*`=`*value*`。

实际上，shell只在设置了选项`HASH_CMDS`时才这样做，默认情况下是设置的。正如你可能预期的，当它找到包含它正在寻找的命令的目录时，它会停止搜索。在选项`HASH_ALL`中还有额外的优化，默认情况下也是设置的：当shell扫描目录以查找命令时，它会将该目录中的所有其他命令添加到哈希表中。这是合理的，因为在大多数类UNIX操作系统上，在同一目录中读取大量文件是相当快的。

命令存储的方式还有其他后果。特别是，zsh在已经知道在哪里找到命令时不会寻找新命令。如果我在上面的例子中在`/usr/local/bin`中放置一个新的`ls`命令，zsh将继续使用`/bin/ls`（假设它已经被找到）。为了解决这个问题，有`rehash`命令，它实际上清空命令哈希表，所以从头开始查找命令。csh用户可能记得在使用新命令时经常需要输入`rehash`：在zsh中不那么糟糕，因为如果没有命令已经被哈希，或者现有的命令消失了，zsh会自动再次扫描路径；此外，如果`$path`被修改，zsh会自动执行`rehash`。所以在`$path`的头部某处添加新的重复命令是需要`rehash`的主要原因。

如果zsh还没有填满它的命令哈希表，因此不知道所有外部命令，可能发生的一件事是[上一章](zshguide02.html#init)中提到并在下面再次提到的`AUTO_CD`选项会认为你试图切换到一个与命令同名的特定目录。这是`AUTO_CD`的一个缺点。

从技术上讲，实际上命令哈希并不是那么明显需要；许多现代操作系统可以在没有它的情况下快速找到命令。在zsh的情况下，决定性的因素是命令完成这一非常常用的功能也需要相同的哈希表。如果你输入`compr<TAB>`，shell会将其完成为`compress`。只有当它有一个命令列表来完成时，它才能做到这一点，这就是哈希表。（在这种情况下，它不需要知道在哪里找到命令，只需要它的名称，但这只是多一点工作来存储它。）如果你跟随前面的段落，你会意识到zsh在你按`TAB`时并不一定知道*所有*可能的命令，因为它只在需要时才查找。为此，还有另一个选项`HASH_LIST_ALL`，默认情况下也是设置的，它会在你尝试完成命令时确保命令哈希表是满的。它只需要做一次（除非你修改`$path`），但这意味着第一次命令完成是慢的。如果未设置`HASH_LIST_ALL`，则命令完成不可用：shell可以重写为每次你尝试完成命令名称时都费力地搜索路径，但这似乎不值得。

`$PATH`从shell传递给从它调用的命令（严格来说，只有当变量被标记为导出时，通常如此——这在下面的`typeset`内置命令族中详细描述）也有后果。一些命令使用`$PATH`调用它们自己的子命令。如果你将其设置为不寻常的值，以至于某些标准命令找不到，那么即使找到了命令，它也可能无法正常运行，因为它正在搜索在传递给它的路径中找不到的东西。这可能导致一些奇怪和令人困惑的错误消息。

关于外部命令要记住的一件重要事情是，当它们运行时shell继续存在；它只是挂起不做任何事情，等待作业完成（尽管我们可以告诉它不要，正如我们将看到的）。命令被给予一个全新的环境来运行；其中的变化不会影响shell，它只是在命令运行后从停止的地方重新开始。所以如果你需要做一些改变shell状态的事情，外部命令是不够的。这让我们转向内置命令。

[]{#l31}

## 3.2: 内置命令

内置命令，简称内置命令，是shell本身的一部分命令。由于内置命令对于控制shell自己的行为是必要的，介绍它们实际上也是对shell中正在进行的相当多内容的介绍。因此，本章中原本会出现在其他地方的相当大一部分内容已经在这里积累，以这样或那样的方式。这确实使事情在某些地方有些棘手；数数我使用"微妙"这个词的次数，并为你的孙子们保留它。

我刚才描述了内置命令的一个原因，但还有一个更简单的：速度。为命令在开始时设置一个全新的环境，在这台计算机上运行的任何其他东西之间切换，然后在结束时再次销毁它是相当过分的，如果你只是想在屏幕上打印一条消息。所以有内置命令来做这种事情。

[]{#l32}

### 3.2.1: 用于打印的内置命令

命令`echo`和`print`是shell内置命令；它们只是显示你输入的内容，在shell移除了所有引号之后。这两个命令之间的区别实际上是历史性的：`echo`先出现，只处理一些简单选项；ksh提供了`print`，它有更复杂的选项，因此成为了一个不同的命令。在zsh中，这两个命令之间的区别仍然存在；如果你想要古怪的效果，你应该看`print`。注意通常还有一个名为`echo`的外部命令，它可能与zsh的不同；没有名为`print`的标准外部命令，但如果有人在你的系统上安装了一个，它很可能会发送一些内容到打印机，而不是屏幕。

一个特殊效果是`print -z`将参数放到编辑缓冲区堆栈上，这是shell维护的一个列表，其中包含你即将编辑的内容。试试：

      print -z print -z print This is a line

（看起来好像需要引用某些东西，但不需要）然后按三次回车。第一次导致第一个`print -z`之后的所有内容出现供你编辑，依此类推。

对于更有用的东西，你可以编写给你一行编辑的函数：

      fn() { print -z print The time now is $(date); }

现在当你输入`fn`时，带有日期的行会出现在命令行上供你编辑。选项`-s`有点相似；该行出现在历史列表中，所以如果你使用上箭头你会看到它，但它不会自动重新出现。

一些其他有用的选项，其中一些你已经见过，是

**`-r`**
:   不解释特殊字符序列如`\n`

**`-P`**
:   使用提示符中的`%`

**`-n`**
:   在末尾不放换行符，以防有更多输出跟随

**`-c`**
:   以列形式打印输出——这意味着`print -c *`的效果是某种穷人的`ls`，只是更快

**`-l`**
:   每个参数使用一行而不是一列，有时对于将列表放入文件中很有用，也对计算数组参数中每个元素的部分有用。

如果你不使用`-r`选项，有大量特殊字符序列。其中许多可能对你来说是熟悉的C语言。

**`\n`**
:   换行符

**`\t`**
:   制表符

**`\e` 或 `\E`**
:   转义字符

**`\a`**
:   响铃（警报），通常是令人厌恶的蜂鸣声的委婉说法

**`\b`**
:   向后移动一个字符。

**`\c`**
:   不打印换行符——像`-n`选项，但嵌入在字符串中。这种替代方法来自Berkeley UNIX。

**`\f`**
:   换页符，从终端被称为电传打字机的时代开始"前进到下一页"的短语，对你来说可能更熟悉的是`^L`

**`\r`**
:   回车符——当打印时，你在DOS文件中得到的讨厌的`^M`，但实际上与`print`一起使用相当有用，因为它会擦除到行首的所有内容。`-n`选项和字符串开头的`\r`组合可以给人一种持续变化的状态行的错觉。

**`\v`**
:   垂直制表符，我本人从未使用过（我刚才试了一下，它的行为像换行符，只是没有假设回车，但这取决于你的终端）。

实际上，你可以通过在反斜杠后指定一个数字来获得255个可能的字符中的任何字符，尽管你的终端可能不喜欢其中一些或全部高于127的字符。通常这由三个八进制字符组成，但你可以使用`\x`后的两个十六进制字符代替——所以`\n`、`\012`和`\x0a`都是换行符。`\`本身转义任何其他字符，即它们出现为自己，即使它们通常不会。

两点注意：首先，不要因为`n`是字母表的第十四位而感到困惑；打印`\016`（八进制的十四）对你没有任何好处。补救措施是，在你发现你的文本不可读之后（对于包括xterm的VT100类终端），打印`\017`。

其次，那些反斜杠可能会让你陷入真正的引用困难。通常命令行上的反斜杠转义下一个字符——这是与`print`的*不同*形式的转义——所以

      print \n

不会产生换行符，它只是打印出一个`n`。所以你需要引用那个。这意味着

      print \\

向引用传递一个反斜杠，以及

      print \\n

或

      print '\n'

打印换行符（后面跟着通常存在的额外换行符）。要打印一个真正的反斜杠，因此你需要

      print \\\\

实际上，如果后面没有其他东西，你可以用两个逃脱——`print`只是耸耸肩并输出它被给予的东西——但这不是一个好习惯。还有其他方法可以做到这一点：由于单引号引用任何东西，包括反斜杠（它们是使反斜杠表现得像正常字符的唯一方法），并且由于`-r`选项使print正常处理字符，

      print -r '\'

有相同的效果。但你需要记住反斜杠的两个引用级别。引号对`print`不特殊，所以

      print \'

足以打印引号。

**`echotc`**\

有一个叫做`echotc`的奇物，它以"termcap"功能作为参数。它现在存在于它自己的模块`zsh/termcap`中。

Termcap是现在相当过时的方式，用于给出在终端上执行各种标准操作所需的命令：移动光标，清除到行尾，打开突出显示模式等等。现在几乎到处都被"terminfo"取代了，这是一种完全不同的指定功能的方式，以及" curses"，这是一种更高级的在字符终端上操作对象的系统。这意味着你需要给`echotc`的参数可能相当难以获得；试试`termcap`手册页；如果有两个，它可能是第五节中给出代码的那个，即`man 5 zsh`或Solaris上的`man -s 5 zsh`。否则你将不得不在网上搜索。`zsh`手册没有给出列表的原因是shell只使用一些众所周知的序列，而有很多其他序列可以与`echotc`一起工作，因为序列由终端解释，而不是shell。

这部分给你一个味道：

      zmodload -i zsh/termcap
      echotc md
      echo -n bold
      echotc mr
      echo -n reverse
      echotc me
      echo

首先我们确保模块被加载到shell中；在一些较老的操作系统上，这只有在安装zsh时编译它才有效。`zmodload`的选项`-i`阻止shell在模块已经加载时抱怨。这是在shell函数中确保你有正确设施的明智方法，因为加载模块使其可用直到显式卸载。

你应该看到`bold`以粗体字符显示，而`reverse`以粗体反色显示。`md`功能打开粗体模式；`mr`打开反色视频；`me`关闭两种模式。典型的zsh方式是：

      print -P '%Bbold%Sreverse%b%s'

这应该显示相同的内容，但使用提示符转义——提示符是特殊字体的最常见用途。`%S`是因为zsh称反色为`突出显示`模式，因为它就是。 （在彩色xterm上，你可能会发现`bold`被解释为`蓝色`。）

如果你真的尝试，你可以用`echotc`做更多的事情。shell刚刚获得了一种打印terminfo序列的方法，可预测地称为`echoti`，尽管它只在需要terminfo编译zsh的系统上可用——当termcap代码实际上是terminfo的一部分时就会发生这种情况。关于这个的好消息是terminfo往往有较好的文档，所以你有很大的机会从`terminfo`手册页中找到你想要的功能。`echoti`命令存在于另一个可预测命名的模块`zsh/terminfo`中。

[]{#l33}

### 3.2.2: 仅为了速度的其他内置命令

只有少数其他内置命令是为了让事情更快。严格来说，测试可以归入此类，但正如我在上一章中解释的，有用的是将测试以这种形式处理

      if [[ $var1 = $var2 ]]; then
        print doing something
      fi

作为shell的特殊语法，以防`$var1`或`$var2`扩展为空，否则会混淆它。这个例子由下面描述的两个功能组成：测试本身，在双方括号之间，如果两个替换值是相同的字符串则为真，以及`if`构造，如果测试为真则运行中间的命令（这里只是`print`）。

内置命令`true`和`false`什么都不做，除了分别返回命令状态0或1。它们只是用作占位符：要永远运行一个循环——`while`也将在后面详细解释——你使用

      while true; do
        print doing something over and over
      done

因为测试总是成功。

`true`的同义词是`:`；它经常以这种形式使用，给出有副作用但不应该使用的参数——类似于

      : ${param:=value}

这是所有Bourne shell派生中的常见习语。在参数扩展中，如果`$param`之前为空，则给它赋值`value`，否则保持不变。由于这是参数扩展的唯一原因，你使用`:`来忽略参数。实际上，shell漫不经心地构建命令行——冒号，后跟`$param`的值，无论是否发生赋值——然后执行命令；只是碰巧`:`不理会给它的参数。如果你从ksh切换，你可能期望某些同义词像这样是别名，而不是内置命令本身，但在zsh中它们实际上是内置命令；shell没有预定义任何别名。（你仍然可以通过`disable`摆脱它们，如下所述。）

[]{#l34}

### 3.2.3: 改变shell状态的内置命令

内置命令的更常见用途是它们改变shell内部的某些内容，或报告关于shell中正在发生的事情的信息。关于外部命令有一件至关重要的事情要记住。这也适用于我们将在其他情况下遇到的shell"分叉"，字面上将自己分成两部分，其中分叉出的部分就像外部命令一样行为。在这两种情况下，命令都在不同的*进程*中，UNIX运行事物的基本单位。（实际上，即使Windows现在也知道进程，尽管它们相互交互的方式略有不同。）

至关重要的是，由shell启动的单独进程中的任何更改都不会影响shell本身。最常见的这种情况是当前目录——每个进程都有自己的当前目录。你可以通过启动一个新的zsh来看到这一点：

      % pwd               # 显示当前目录
      ~
      % zsh               # 启动一个新的shell，这是一个单独的进程
      % cd tmp
      % pwd               # 现在我在不同的目录中...
      ~/tmp
      % exit              # 离开新shell...
      % pwd               # 现在我回到原来的地方...
      ~

因此`cd`命令必须是shell内置命令，否则每次运行它时都会发生这种情况。

这里有一个更有用的例子。在命令周围加上括号要求shell为它启动一个不同的进程。当你特别*不*希望效果传播回来时，这很有用：

      (cd some-other-dir; run-some-command)

运行命令，但不会改变"真实"shell所在的目录，只会改变其分叉的"子shell"。因此，

      % pwd
      ~
      % (cd /; pwd)
      /
      % pwd
      ~

有一种更微妙的情况：

      cd some-other-dir | print Hello

记住，`|`（"管道"）将第一个命令的输出连接到下一个命令的输入——尽管在这个例子中实际上没有信息以这种方式传递。在zsh中，这样创建的"管道"的所有部分除了最后一部分都在不同的进程中运行。因此`cd`不会影响主shell。我将把它称为"父"shell，这是进程的标准UNIX术语；当你启动另一个命令或分叉一个子shell时，你正在创建"子进程"（没有意思要阴郁，子进程在这种情况下通常先死）。因此，正如你所猜测的，

      print Hello | cd some-other-dir

*确实*有改变目录的效果。注意其他shell以不同方式执行此操作；在zsh中它总是以这种方式工作是有保证的，因为许多人依赖它来设置参数，但许多shell将管道的*左*手部分作为在父shell中运行的部分。如果管道符号的两边都是某种外部命令，那么两者当然都会在子进程中运行。

还有其他改变shell状态的方法，例如声明特定类型的参数，或告诉它如何解释某些命令，当然还有改变选项。以下是最有用的，按大致逻辑的方式分组。

[]{#l35}

### 3.2.4: cd及其朋友

你现在不会惊讶地得知`cd`命令改变目录。有一个同义词`chdir`，据我所知没有人使用它。（它与系统调用同名，所以如果你一直在用C或Perl编程并忘记你现在使用的是shell，你可能会使用`chdir`。但这似乎有点牵强。）

`cd`和`chdir`内置了许多额外功能。首先，如果你省略了想要更改的目录，你将被带到你的主目录，尽管`cd ~`也不是很难输入。

接下来，命令`cd -`是特殊的：它带你到你上次所在的目录。如果你做一系列`cd`命令，只有紧接的前一个目录被记住；它们不会堆叠起来。

第三，有一种快捷方式可以在类似名称的目录之间切换。如果你输入`cd <old> <new>`，那么shell将查找当前目录中`<old>`字符串的第一次出现，并尝试将其替换为`<new>`。例如，

      % pwd
      ~/src/zsh-3.0.8/Src
      % cd 0.8 1.9
      ~/src/zsh-3.1.9/Src

`cd`命令实际上报告了新目录，就像它通常做的那样，如果它不是完全明显带你去的地方。

注意只有`<old>`的*第一次*匹配被采用。容易犯的错误是认为你可以从`/home/export1/pws/mydir1/something`改变到`/home/export1/pws/mydir2/something`用`cd 1 2`，但那个第一个`1`搞砸了它。可以说shell在这里可以更聪明。当然，`cd r1 r2`在这种情况下会起作用。

`cd`的朋友`pwd`（打印工作目录）告诉你当前的工作目录是什么；这些信息也可以在shell参数`$PWD`中获得，它是特殊的，并且在目录更改时自动更新。稍后，当你了解所有关于扩展的知识时，你会发现你可以用它来做技巧来引用其他目录。例如，`${PWD/old/new}`使用参数替换机制来引用不同的目录，其中`old`被`new`替换——这次`old`可以是模式，即包含通配符匹配的东西。所以如果你在上面的`zsh-3.0.8/Src`目录中，并想从`zsh-3.1.9/Src`目录复制一个文件，你有一个简写：

      cp ${PWD/0.8/1.9}/myfile.c .

**符号链接**\

Zsh试图跟踪跨符号链接的目录。如果你不熟悉这些，你可以把它们看作是表现得像指向另一个文件的指针的文件名（有点像Windows的快捷方式，尽管UNIX已经有了很长时间，而且它们工作得更好）。你像这样创建它们（`ln`不是内置命令，但用它制作符号链接现在非常标准）：

      ln -s existing-file-name name-of-link

例如

      ln -s /usr/bin/ln ln

在当前目录中创建一个名为`ln`的文件，它只是指向文件`/usr/bin/ln`。符号链接在表现得像原始文件一样方面非常出色；例如，你可以像运行`/usr/bin/ln`一样运行你刚刚创建的`ln`链接。它们在`ls -l`的长文件列表中显示不同，最后一列显示它们指向的文件。

你可以让它们指向任何类型的文件，包括目录，这就是为什么它们在这里被提及。假设你创建了一个从你的主目录到根目录的符号链接并切换到它：

      ln -s / ~/mylink
      cd ~/mylink

如果你不知道它是一个链接，你期望通过执行`cd ..`切换到父目录。然而，操作系统——它只有一组从`/`开始并向下延伸的目录，并且在跟随它们后忽略符号链接，它们真的只是指针——认为你在根目录`/`中。这可能会令人困惑。因此zsh试图跟踪*你*可能认为你在哪里，而不是系统认为的。如果你输入`pwd`，你会看到`/home/you/mylink`（无论你的主目录在哪里），而不是`/`；如果你输入`cd ..`，你会发现你自己回到你的主目录。

你可以通过设置选项`CHASE_LINKS`来关闭所有这些第二猜测；然后`cd ~/mydir; pwd`会显示你在`/`中，在那里改变到父目录没有效果；根目录的父目录是根目录，除了在某些稍微迷幻的网络文件系统上。这确实有优势：例如，`cd ~/mydir; ls ..`总是列出根目录，而不是你的主目录，无论选项设置如何，因为`ls`不知道你跟随的链接，只有zsh知道，并且它将`..`视为引用根目录。设置`CHASE_LINKS`允许`pwd`警告你系统认为你在哪里。

顺便给非UNIX专家（在上一次统计时，世界人口中超过99.9%）：我说的是"符号链接"而不是仅仅"链接"，因为还有其他叫做"硬链接"的链接。这就是`ln`在不使用`-s`选项时创建的。硬链接不是文件的指针，而是文件的替代名称。如果你做

      ln myfile othername
      ls -l

其中`myfile`已经存在，你无法区分`myfile`和`othername`哪个是原始的——系统也不关心。你可以删除任何一个，另一个将完全快乐地作为文件的名称。这很像重命名文件的工作方式，只是在这种情况下创建硬链接是为你完成的。硬链接有限制——你不能链接到目录，或者链接到另一个磁盘分区上的文件（如果你不知道什么是磁盘分区，你会看到这可能是一个限制）。此外，你通常想知道哪个是原始的，哪个是链接的——所以对于大多数用户来说，创建符号链接更有用。唯一的缺点是跟随指针稍微慢一点；如果你认为你能注意到差异，你绝对应该放慢一点。

与硬链接不同，符号链接的目标实际上不必存在，直到你尝试使用链接时才进行检查。最好的做法是在创建链接时运行`ls -lL`；`-L`部分告诉`ls`跟随链接，如果成功，你应该看到你的链接显示与它指向的文件具有完全相同的特征。如果它仍然显示为链接，那么就没有这样的文件。

既然我在谈论这个，我应该指出符号链接的一个小怪癖：链接到的文件名（第一个名称），如果它不是绝对路径（在任何`~`扩展后以`/`开头），相对于创建链接的目录进行处理——而不是运行`ln`时的当前目录。这里：

      ln -s ../mydir ~/links/otherdir

链接`otherdir`将引用*它自己的*父目录中的`mydir`，即`~/links`——而不是你运行命令时所在目录的父目录。更糟糕的是，第二个词，如果不是绝对路径，*是*相对于你运行命令的目录解释的。

**\$cdpath和AUTO_CD**\

我们还没有接近你可以在目录上做的魔法的尽头（事实上，我甚至还没有到达zsh特有的部分）。下一个技巧是`$cdpath`和`$CDPATH`。它们看起来很像你在上一章遇到的`$path`和`$PATH`，我在上一章中简要提到了它们：`$cdpath`是一个目录数组，而`$CDPATH`是一个冒号分隔的列表，行为上像标量变量一样。它们给出了你可能想要更改到的子目录的目录列表。如果你使用正常的cd命令（即以`cd `*dirname*的形式，并且*dirname*不以`/`或`~`开头，shell将查看`$cdpath`中的目录以找到包含子目录*dirname*的目录。如果`$cdpath`没有设置，如你所猜测的，它只是使用当前目录。

注意`$cdpath`总是按顺序搜索，你可以在其中放一个`.`来表示当前目录。如果你这样做，当前目录将总是在*那时*被搜索，不一定是首先，这可能不是你所期望的。例如，让我们设置一些目录：

      mkdir ~/crick ~/crick/dna
      mkdir ~/watson ~/watson/dna
      cdpath=(~/crick .)
      cd ~/watson
      cd dna

所以我移到了目录`~/watson`，其中包含子目录`dna`，并执行了`cd dna`。但由于`$cdpath`，shell将首先在`~/crick`中查找，并在那里找到`dna`，并将你带到那个自我复制的目录的副本，而不是`~/watson`中的那个。大多数人把`.`放在他们的`cdpath`的开头，原因就在这里。然而，至少`cd`会警告你——如果你尝试了，你会看到在这样的情况下，它会打印出它选择的目录的名称。

实际上，如果你的目录中根本没有`.`，shell将总是首先在那里查找；除了将`cd`变成函数外，没有方法使`cd`永远不会更改为当前目录的子目录。一些shell不这样做；它们使用`$cdpath`中的目录，仅此而已。

还有另一个简写，这次是zsh特有的：我在上一章提到的选项`AUTO_CD`。这样没有参数的命令如果真的是目录将带你到那个目录。通常这是完美的——否则你只会得到一个"命令未找到"的消息，你不妨利用这个选项。只是偶尔，目录的名称与命令、内置命令或外部命令或shell函数的名称冲突，然后可能会有一些混淆：zsh总是会选择它知道的命令，但在某些情况下它不知道，正如我上面描述的。

我在上一章没有说的是`AUTO_CD`尊重`$cdpath`；实际上，它真的是这样实现的：单独的*dirname*表现得尽可能像`cd` *dirname*，而不会把shell的内部搞得一团糟。

**目录堆栈**\

zsh从C-shell家族继承的一个非常有用的功能（传统的Korn shell没有它）是目录堆栈。这是你最近去过的一系列目录的列表。如果你使用`pushd`命令而不是`cd`，例如`pushd` *dirname*，那么你所在的目录将保存在这个列表中，你将被带到*dirname*，使用`$CDPATH`就像`cd`一样。然后当你输入`popd`时，你将被带回到你原来的地方。列表可以像你想要的那样长；你可以`pushd`任意数量的目录，每个`popd`将带你通过列表回到（这就是计算机术语中所谓的"堆栈"或更准确地说是"后进先出"堆栈的运行方式，因此称为"目录堆栈"）。

你可以看到列表——总是以当前目录开始——用`dirs`命令。例如：

      cd ~
      pushd ~/src
      pushd ~/zsh
      dirs

显示

      ~/zsh ~/src ~

下一个`popd`将带你回到`~/src`。如果你这样做，你会看到`pushd`在进行时自动报告`dirs`给出的列表；你可以用选项`PUSHD_SILENT`关闭它，在这种情况下你将不得不依靠显式输入`dirs`。

实际上，这种用途的很大一部分不是来自使用简单的`pushd`和`popd`组合，而是来自另外两个功能。首先，`pushd`单独使用会交换堆栈顶部的两个目录。其次，带有一个数字参数的`pushd`，前面是`+`或`-`，可以带你到列表中的其他目录之一。命令`dirs -v`告诉你需要的数字；`0`是当前目录。所以如果你得到，

      0       ~/zsh
      1       ~/src
      2       ~

那么`pushd +2`带你到`~`。（这里需要一点暂停相信我没有使用`AUTO_CD`并输入`..`。）如果你使用`-`，它从列表的另一端计数；`-0`（向有文化的人道歉）是最后一项，即在这种情况下与`~`相同。有些人习惯于`-`和`+`参数以相反的方式行为；选项`PUSHD_MINUS`就是为此而存在的。

除了`PUSHD_SILENT`和`PUSHD_MINUS`，还有一些其他相关的选项。设置`PUSHD_IGNORE_DUPS`意味着如果你`pushd`到一个已经在列表某处的目录，重复条目将被悄悄删除。这对于大多数人类操作很有用——然而，如果你在函数或脚本中使用`pushd`来记住以前的目录以供将来匹配的`popd`，这可能是危险的，你可能希望在函数内部局部关闭它。

`AUTO_PUSHD`意味着任何目录更改命令，包括自动cd，都被视为带有目标目录作为参数的`pushd`命令。使用它可以使命令堆栈变得非常长，并且有一个参数`$DIRSTACKSIZE`，你可以设置它来指定最大长度。当超过这个长度时，最旧的条目（在`dirs -v`列表中编号最高的）会自动删除。除非明确设置，否则没有限制。

最后的`pushd`选项是`PUSHD_TO_HOME`。这使得单独的`pushd`表现得像单独的`cd`一样，因为它带你到你的主目录，而不是交换顶部的两个目录。通常一系列`pushd`命令的工作方式与一系列`cd -`命令非常相似，总是带你到你之前的目录，明显的区别是`cd -`不咨询目录堆栈，它只是自动记住前一个目录，因此如果只是使用`cd -`而不是`pushd`，它会混淆`pushd`。

关于`pushd`还有一个剩余的微妙之处，那就是当你通过类似`pushd +2`的东西将特定目录带到前面时，列表的其余部分会发生什么。通常列表只是循环，所以+3和+4的目录现在就在新列表头的后面，而它前面的两个目录被移到了末尾。如果之前的列表是：

      dir1  dir2  dir3  dir4

那么在`pushd +2`之后你会得到

      dir3  dir4  dir1 dir2

这种行为在zsh的生命周期中发生了变化，我们中的一些人更喜欢旧行为，其中那一个目录被拉到前面，其余的只是填补了空缺：

      # 旧行为
      dir3  dir1  dir2  dir4

所以过了一段时间你会在列表前部得到一个"最佳集"。如果你也喜欢这种行为（我觉得我需要写一些群论论文才能喜欢新行为），有一个函数`pushd`随源代码提供，虽然它足够短可以在这里重复——这是以zsh方式自动加载的形式：

      # pushd函数模拟旧的zsh行为。
      # 使用这个，pushd +/-n将选中的元素
      # 提升到堆栈顶部而不是循环
      # 堆栈。

      emulate -R zsh
      setopt localoptions

      if [[ ARGC -eq 1 && "$1" == [+-]<-> ]] then
              setopt pushdignoredups
              builtin pushd ~$1
      else
              builtin pushd "$@"
      fi

`&&`是一个逻辑"与"，要求两个测试都为真。测试是函数恰好有一个参数，并且它具有`+`或`-`后跟任何数字的形式（`<->`是匹配任何数字的特殊zsh模式，是像`<1-100>`这样匹配1到100之间任何数字的扩展形式）。

**引用其他目录**\

Zsh有两种允许你引用特定目录的方式。它们的共同点是都以`~`开头（在zsh的非常旧版本中，第二种形式实际上使用了`=`，但当前的方式更合乎逻辑）。

你肯定知道，因为我已经大量使用了它，一个单独的`~`或后面跟着`/`指的是你自己的主目录。这种扩展——同样来自C-shell，尽管在这种情况下Korn shell也有——是`~name`可以指系统上任何用户的主目录。所以如果你的用户名是`pws`，那么`~`和`~pws`是同一个目录。

Zsh对此有一个扩展；你实际上可以命名你自己的目录。这在[第2章](zshguide02.html#init)中描述过，关于提示符，因为那是主要用途：

      host% PS1='%~? '
      ~? cd zsh/Src
      ~/zsh/Src? zsrc=$PWD
      ~/zsh/Src? echo ~zsrc
      /home/pws/zsh/Src
      ~zsrc?

查阅那一章以了解强制参数被识别为命名目录的方法。

有一种更复杂的方法可以直接做到这一点：

      hash -d zsrc=~/zsh/Src

在提示符中像以前一样使`~zsrc`出现，在这种情况下没有参数`$zsrc`。这是纯粹主义者的方式（尽管很少有zsh用户是纯粹主义者）。你可以猜到`unhash -d zsrc`做什么；这也适用于通过参数命名的目录，但保留参数本身。

可以有一个与用户同名的命名目录。在这种情况下`~name`指的是你明确定义的目录，并且没有简单的方法在不删除你定义的名称的情况下获取`name`的主目录。

如果你在`cd`类命令或`AUTO_CD`中使用命名目录，你可以设置选项`CDABLEVARS`，它允许你省略前导`~`；`cd zsrc`用这个选项会带你到`~zsrc`。这个名称是历史的产物，现在是一个误称；它真的是命名目录，而不是参数（即变量）。

引用目录的第二种方式是使用数字而不是名称：数字指的是目录堆栈中的目录。所以如果`dirs -v`给你

      0       ~zsf
      1       ~src

那么`~+1`和`~-0`（不是很数学，但如果你仔细想想是合乎逻辑的）指的是`~src`。在这种情况下，与pushd参数不同，你可以省略`+`并使用`~1`。选项`PUSHD_MINUS`是受尊重的。你会看到这在上面的`pushd`函数中使用了：技巧是`~+3`，例如，指的是与`pushd +3`相同的元素，因此`pushd ~+3`将该目录推到列表的前面。然而，我们设置了`PUSHD_IGNORE_DUPS`，所以旧位置的值也被删除了，给我们想要的效果，即简单地将目录拉到前面而没有技巧循环。

[]{#l36}

### 3.2.5: 命令控制和信息命令

存在各种内置命令来控制你访问命令的方式，并显示有关可以运行的命令的信息。

前两个严格来说是"预命令修饰符"而不是命令：这意味着它们放在命令行前面并修改其行为，而不是作为命令本身。如果你在命令行前放`command`，命令词（下一个词）将被视为外部命令的名称，无论它通常如何被解释；同样，如果你在前面放`builtin`，shell将尝试将命令作为内置命令运行。通常，shell函数优先于内置命令，内置命令优先于外部命令。所以，例如，如果你的打印机控制系统有命令`enable`（许多System V版本都有），它与我即将谈论的内置命令冲突，你可以运行`command enable lp`来启用打印机；否则，将运行内置的enable。同样，如果你已经将`cd`定义为函数，但这次想要调用普通的内置`cd`，你可以说`builtin cd mydir`。

`command`的一个常见用法是在同名的shell函数内部。有时你想通过在普通命令周围粘贴一些额外的东西来增强它，然后调用该命令，所以你编写一个同名的shell函数。要在shell函数内部调用命令本身，你使用`command`。以下工作，虽然它显然不是所有的有用，因为它现在：

      ls() {
        command ls "$[@]"
      }

所以当你运行`ls`时，它调用函数，函数调用真正的`ls`命令，传递给你给它的参数。

你可以通过`disable`和`enable`命令获得对shell将运行的命令的更持久的控制。第一个通常采用内置参数；每个这样的内置将不会被shell识别，直到你给它一个`enable`命令。所以如果你想要能够运行外部`enable`命令并且不太关心内置版本，`disable enable`（如果这令人困惑，抱歉）会起作用。哈，你在想，你不能运行`enable enable`。这是正确的：在过去的某个时候，`builtin enable enable`会起作用，但目前不会；这可能会改变，如果我记得改变它。你可以只用`disable`列出所有禁用的内置——大多数做这种操作的内置都是这样工作的。

你可以通过给出不同的选项来操作其他命令集：别名用`-a`选项，函数用`-f`，保留字用`-r`。前两个你可能知道，我会谈到它们，但"保留字"需要描述。它们基本上是具有特殊语法意义的内置命令，包括一些符号如`{`和`[[`。它们优先于除别名之外的所有内容——实际上，由于它们在语法上是特殊的，shell需要非常早地知道它找到了一个保留字，它不能等到它试图执行命令时。例如，如果shell找到`[[`，它需要知道直到`]]`的所有内容都必须被视为测试而不是普通命令参数。因此，你通常不会想要禁用保留字，因为shell不会正常工作。这样做的最明显原因是与某些没有保留字的其他shell兼容。你可以用以下方式获得完整列表：

      whence -wm '*' | grep reserved

我将在下面解释，因为我将要谈到`whence`。

此外，我倾向于发现如果我想摆脱别名或函数，我使用`unalias`和`unfunction`命令来永久摆脱它们，因为我总是有原始定义存储在某处，所以这两个选项可能也不那么有用。禁用内置命令绝对是四个可能性中最有用的。

必须以不同方式操作外部命令。上面给出的类型由shell内部处理，所以它只需要记住调用什么代码。对于外部命令，问题是如何找到它们。我上面提到了`rehash`，但没有告诉你`hash`命令（你已经看到它带有`-d`选项）可以用来告诉shell如何找到外部命令：

      hash foo=/path/to/foo

使`foo`使用显示的路径执行命令（甚至不必以`foo`结尾）。这有点像别名——大多数人可能会用别名来做，实际上——虽然快一点，但你不太可能注意到差异。你可以用`unhash`删除它。这里有一个陷阱，如果路径被重新哈希，无论是通过调用`rehash`还是当你修改`$path`时，整个哈希表都会被清空，包括你以这种方式放入的任何内容；所以这不是很实用。

在所有这些中间，能够找出shell认为特定命令名称做什么是有用的。命令`whence`告诉你这个；它也以稍微不同的选项存在于其他名称下，主要是为了与其他shell兼容。我只坚持使用`whence`。

它的标准输出实际上并不特别有趣。如果它是shell内部以某种方式知道的命令，它会被回显回来，如果是别名则扩展；如果是外部命令则打印完整路径，显示它来自哪里；如果它不被识别，命令返回状态1并且不打印任何内容。

你可以通过`-v`或`-c`选项让它更有用，这些选项更详细；第一个打印出信息消息，而第二个打印出任何被询问的函数的定义（这也是使用`which`而不是`whence`的效果）。一个非常有用的选项是`-m`，它将任何参数作为模式处理，使用通常的zsh模式格式，换句话说，与用于匹配文件的模式相同。因此

      whence -vm "*"

打印出shell知道的每个命令，以及它对它的看法。

注意`*`周围的引号——你必须记住这些在任何模式不用来在命令行上生成文件名，而是需要传递给命令进行解释的地方。如果这看起来是一个相当微妙的区别，想想如果你运行会发生什么

      # 哦。最好不要在家里尝试这个。
      # (更好的是，不要在工作时这样做。)
      whence -vm *

在一个有`foo`和（猜猜看）`bar`文件的目录中。shell在第一次查看命令行时还没有决定要运行哪个命令；它只是看到`*`并扩展行到

      whence -vm foo bar

这不是你的意思。

还有几个其他值得提到的技巧：`-p`使shell在你的路径中搜索它们，即使名称匹配为其他东西（比如，shell函数）。所以如果你定义了`ls`作为函数，

      which -p ls

仍将告诉`command ls`会找到什么。另外，选项`-a`搜索所有命令；在同一个例子中，这将显示你`ls`命令和`ls`函数，而`whence`通常只会显示函数，因为那是将要运行的那个。`-a`选项还显示如果它在你的路径中找到多个外部命令。最后，选项`-w`很有用，因为它用一个单词标识命令的类型：`alias`、`builtin`、`command`、`function`、`hashed`、`reserved`或`none`。大多数这些是显而易见的，其中`command`是普通的外部命令；`hashed`是已经用`hash`内置命令明确给出路径的外部命令，`none`表示它根本没有被识别为命令。现在你知道我们如何提取上面的保留字了。

`whence`的近亲是`functions`，当然适用于shell函数；它通常列出作为参数给出的所有函数的定义，但它的亲戚（其中`autoload`是一个）执行各种其他技巧，将在下面关于shell函数的部分中描述。小心`function`，没有`s`，这是完全不同的，不像`command`或`builtin`——它实际上是一个用于*定义*函数的关键字。

[]{#l37}

### 3.2.6: 参数控制

有各种内置命令用于控制shell的参数。你已经知道如何设置和使用参数，但当你查看细节时，它要复杂得多。

**局部参数**\

操作参数行为的主要命令是`typeset`。它最简单的用法是声明一个参数；你只需给它一个参数名称列表，这些将被创建为标量参数。你可以通过赋值创建参数，但`typeset`的主要点是，如果参数以这种方式在函数内部创建，参数将在函数结束时恢复到其原始值，或者如果它之前不存在则被删除——换句话说，它具有像大多数普通编程语言中的变量一样的"局部作用域"。实际上，用行话来说，它具有"动态"而不是"语法"作用域，这意味着在当前函数中调用的任何函数中都可以看到相同的参数；这与C或FORTRAN不同，在C或FORTRAN中，任何调用的函数或子程序都不会看到在父函数中声明的变量。

以下使这更加具体。

      var='Original value'
      subfn() {
        print $var
      }
      fn() {
        print $var
        typeset var='Value in function'
        print $var
        subfn
      }
      fn
      print $var

这段代码打印出

      Original value
      Value in function
      Value in function
      Original value

代码的前三个部分只是定义了参数`$var`，以及两个函数，`subfn`和`fn`。然后我们调用`fn`。它做的第一件事是打印出`$var`，这给出`Original value`，因为我们没有改变原始定义。然而，接下来的`typeset`做到了这一点；如你所见，我们可以在typeset期间赋值给参数。因此当我们再次打印出`$var`时，我们得到`Value in function`。然后调用`subfn`，它打印出与`fn`中相同的值，因为我们没有改变它——这就是C或FORTRAN的不同之处，它们不会识别变量，因为没有在该函数中声明。最后，`fn`退出并且原始值被恢复，由最终的`print`打印出来。

注意值变了两次：首先在`typeset`，然后在`fn`结束时。在任何时候`$var`的值将是这两个值中的一个。

虽然你可以在`typeset`语句中进行赋值，但你不能赋值给数组（我在上一章已经说过）：

      typeset var=(Doesn\'t work\!)

因为带有括号的语法是特殊的；只有当行只包含赋值时它才起作用。然而，如果你尝试将数组赋值给标量，或者反之亦然，shell不会抱怨；它只是默默地转换类型：

      typeset var='scalar value'
      var=(array value)

我在typeset语句中放入赋值以强调它创建标量，但实际上在函数中设置数组的通常方法是

      typeset var
      var=()

这创建了一个空标量，然后将其转换为空数组。最近版本的shell有`typeset -a var`来一次性完成这个操作——但你*仍然*不能在同一语句中赋值。

还有一些与`typeset`及其类似命令只是普通命令的事实相关的陷阱。考虑这个：

      % typeset var=`echo two words`
      % print $var
      two

`words`怎么了？答案是反引号替换，在未引用时会分割单词。所以`typeset`语句等同于

      % typeset var=two words

有两种方法可以绕过这个问题；首先，使用普通赋值：

      % typeset var
      % var=`echo two words`

这可以告诉是标量赋值，因此知道不分割单词，或者引用反引号，

      % typeset var="`echo two words`"

我们还没有谈论过三种重要类型；这两种只能用`typeset`或我将列出的类似内置命令创建。它们是整数类型、浮点类型和关联数组类型。

**数值参数**\

用`typeset -i`或`integer`创建整数，这是另一种说同样事情的方法。它们用于算术，shell可以如下进行：

      integer i
      (( i = 3 * 2 + 1 ))

双括号包围一个完整的算术表达式：它的行为就像被引用了一样。内部的表达式可以是你可能习惯的其他编程语言中的算术的任何东西。需要注意的一点是，参数不需要在前面加`$`，即使在取其值时也是如此：

      integer i j=12
      (( i = 3 * ( j + 4 ) ** 2 ))

这里，`j`将被12替换，`$i`得到值768（十六的平方乘以三）。你可能不熟悉的一件事是`**`，它是FORTRAN和Perl中的"的幂"操作符。注意，可以在双括号内使用括号——实际上，你甚至可以做

      (( i = (3 * ( j + 4 )) ** 2 ))

shell不会混淆，因为它知道内部的任何括号必须成对出现（直到你用你的buggy代码故意混淆它）。

你当然会正常使用`print $i`来看给`$i`赋了什么值，正如你所期望的那样，它以十进制数字的形式打印出来。然而，`typeset`允许你为打印指定另一个基数。如果你做

      typeset -i 16 i
      print $i

在最后一次计算后，你应该看到`16#900`，这意味着十六进制中的900。`-i 16`选项对`$i`的唯一效果就是在打印时以这种形式出现。你也可以使用这种基数表示法来输入数字：

      (( i = 16#ff * 2#10 ))

这意味着255（十六进制中的`ff`）乘以2（二进制中的`10`）。shell也理解C表示法，所以`16#ff`可以表示为`0xff`。

浮点变量非常相似。你可以用`typeset -F`或`typeset -E`声明它们。两者之间的唯一区别，同样，是在输出上；`-F`使用定点表示法，而`-E`使用科学（助记：指数）表示法。内置`float`等同于`typeset -E`（因为Korn shell这样做，这就是为什么）。浮点表达式也以你可能习惯的其他编程语言的方式工作：

      typeset -E e
      typeset -F f
      (( e = 32/3, f = 32.0/3.0 ))
      print $e $f

打印

      1.000000000e+01 10.6666666667

各种要点：`,`可以分隔不同的表达式，就像在C中一样，所以`e`和`f`赋值是分别执行的。`e`赋值实际上是一个整数除法，因为32和3都不是浮点数，必须包含一个点。这意味着执行了整数除法，产生10，只有在最后才转换为浮点数。再次，这正是成熟语言的工作方式，所以诅咒是没有用的。`f`赋值是一个完整的浮点表演。在版本`3.1.7`之前，浮点参数不可用。

虽然这实际上是后面章节的问题，但有一个你可以加载的浮点函数库（实际上这只是链接系统数学库的一种方式）。通常的咒语是`zmodload zsh/mathfunc`；你的系统上可能没有"动态加载"库，这意味着这可能不起作用。如果可以，你可以做这样的事情

      (( pi = 4.0 * atan(1.0) ))

大致上，出现在大多数系统数学库中的所有函数（见`math`手册页）在zsh中都可用。

像所有用`typeset`或其表亲创建的其他参数一样，整数和浮点参数对函数是局部的。你可能想知道如何创建一个全局参数（即在函数内部和外部都有效的参数），该参数具有整数或浮点值。shell最近添加了一个功能（在版本3.1.6中），允许这样做：在`typeset`中使用标志`-g`以及任何其他标志。例如，

      fn() {
        typeset -Fg f
        (( f = 42.75 ))
      }
      fn
      print $f

如果你尝试，你会看到`$f`的值已经超出了函数的范围。`g`显然代表全局，尽管它并不那么简单：

      fn() {
        typeset -Fg f
      }
      outerfn() {
        typeset f='scalar value'
        fn
        print $f
      }
      outerfn

函数`outerfn`为`f`创建了一个局部标量值；这是`fn`看到的。所以它并不是真正操作一个"全局"值，它只是没有为`fn`的作用域创建一个新的值。错误信息来自于它试图在更改类型时保留`$f`的值，而该值不是一个适当的浮点表达式。错误信息，

      fn: bad math expression: operator expected at `value'

出现是因为对数值参数的赋值总是进行算术求值。操作`scalar value`，它找到了`scalar`并假设这是一个参数，然后寻找像`+`这样的操作符；相反它找到了`value`。如果你想试验，把字符串改为`scalar + value`并设置`value=42`，或其他，然后重试。这有点令人困惑（这是间接说我被搞糊涂了），但与zsh通常处理参数的方式一致。

实际上，在某种程度上你不需要使用整数和浮点参数。任何时候zsh需要数值表达式，它都会强制标量为正确的值，任何时候它产生数值表达式并将其赋值给标量，它会将结果转换为字符串。所以

      typeset num=3            # 这是字符串`3`。
      (( num = num + 1 ))      # 但这无论如何都有效
                               # ($num仍然是一个字符串)。

如果你有一个参数有时是数字，有时是字符串，这是有用的，因为zsh会为你做所有的转换工作。然而，如果你总是想要一个数字，这可能会令人困惑，因为zsh不能为你猜测；加上它在来回转换时效率稍高；加上你在这样做时会失去精度，因为如果数字存储为字符串而不是内部数值表示，你得到的就是你得到的（尽管zsh在隐式转换为字符串时倾向于给你很多小数位）。无论如何，我建议如果你知道一个参数必须是整数或浮点值，你应该声明它为这样的值。

有一个内置命令叫做`let`来处理数学表达式，但由于

      let "num = num + 1"

等同于

      (( num = num + 1 ))

第二种形式更容易记忆，你可能不需要使用它。如果你这样做，记住（不像BASIC）每个数学表达式应该作为引号中的一个参数出现。

**关联数组**\

剩下的一种主要参数类型是关联数组；如果你使用Perl，你可能称它为"哈希"，但我们倾向于不这样做，因为这真的只是描述了它的实现方式而不是它做什么。（好吧，它做的事情是哈希东西。现在闭嘴。）

这些必须通过typeset语句声明——没有其他办法。有一些相当奇特的内置命令为你生成一个填充的关联数组，但告诉zsh你想要你自己的关联数组的唯一方法是

      typeset -A assoc

创建`$assoc`。至于它做什么，最好用例子来说明：

      typeset -A assoc
      assoc=(one eins two zwei three drei)
      print ${assoc[two]}

打印出`zwei`。所以它的工作方式有点像普通数组，但普通数组中出现在方括号内的数字*下标*被字符串*键*替换，在这种情况下是`two`。数组赋值有点欺骗性；`values`实际上是一对对，`one`是值`eins`的键，依此类推。如果列表中有奇数个元素，shell会抱怨。这可能也让你想起Perl。你可以一次赋值一个值：

      assoc[four]=vier

也可以取消设置一个键/值对：

      unset 'assoc[one]'

其中引号阻止方括号在命令行上被解释为模式。

扩展被推迟了，但你可能想了解返回你放入内容的方法。如果你做

      print $assoc

你只看到值——这与普通数组完全相同，其中不显示下标1、2、3等。注意它们是随机顺序的——这是与普通数组的另一个主要区别；关联数组没有排序概念，除非你显式排序。

但这里的键可能同样有趣。所以有：

      print ${(k)assoc}
      print ${(kv)assoc}

给出（如果你已经完成了上面的所有命令）：

      four two three
      four vier two zwei three drei

打印出键而不是值，以及键和值对，就像你输入它们一样。你可以看到，虽然对的顺序不明显，但每次都是一样的。从这个例子你可以算出如何将关联数组复制到另一个数组中：

      typeset -A newass
      newass=(${(kv)assoc})

其中`(kv)`很重要——以及赋值前的`typeset`，否则`$newass`会是一个坏的普通数组。你也可以证明`${(v)assoc}`做了你可能期望的事情。还有很多其他技巧，但它们大多与[第5章](zshguide05.html#subst)中描述的聪明参数扩展类型相关。

**其他typeset和类型技巧**\

`typeset`的变体有一些，上面零星提到。你可以用任何一种做任何你不能用`typeset`做的事情——这并不总是如此；我们试图改进选项的正交性。它们在默认设置的选项和允许的附加选项上有所不同。这里有一个列表：`declare`、`export`、`float`、`integer`、`local`、`readonly`。我不会混淆你详细描述所有这些；参见手册。

如果有一个例外，那就是`export`，它不仅标记一个参数导出，而且默认打开`-g`标志，所以该参数对函数不是局部的；换句话说，它等同于`typeset -gx`。然而，一个遗留下来的是`typeset -x`表现得像`export`，换句话说，默认打开`-g`标志。你可以通过取消设置选项`GLOBAL_EXPORT`来修复这个问题——该选项只存在兼容性；逻辑上它应该总是取消设置。这部分是因为在旧时代你不能导出局部参数，所以`typeset -x`要么打开`-g`要么关闭`-x`；这在3.1.9版本中得到了修复，（例如）`local -x`创建一个导出到环境的局部参数；当函数退出时，参数本身和环境中的值都将被恢复。内置`local`本质上是`typeset`的一种形式，它放弃了`-g`标志及其所有工作。

另一个已经消失的旧限制是，你不能使特殊参数，特别是`$PATH`，对函数局部；你只是修改了原始参数。现在如果你说`typeset PATH`，事情按你可能期望的方式发生，`$PATH`有其通常的效果，并且在函数退出时恢复到旧值。由于`$PATH`仍然是特殊的，你应该确保在函数中调用外部命令之前给它分配一些东西，否则它将是空的，找不到命令。可能你特别不希望你制作的局部参数具有特殊属性；3.1.7及以后版本允许typeset标志`-h`隐藏该参数的特殊性，所以在`typeset -h PATH`中，`PATH`在包含函数的持续时间内是一个普通变量。在内部，与之前设置的值相同将继续用于查找命令，但它不会被导出。

`typeset`的第二个主要用途是为参数设置属性。在这种情况下，它可以对现有参数进行操作，以及创建新参数。例如，

      typeset -r msg='This is an important message.'

为参数`msg`设置只读标志(-r)。如果参数不存在，它将按照通常的作用域规则创建；但如果它在当前作用域级别存在，它将被设为只读，并分配给它的值，这意味着你不能设置该参数的特定副本。出于显而易见的原因，通常在首次声明只读参数时分配一个值。这里是一个现实检查它如何影响作用域：

       msg='This is an ordinary parameter'
       fn() {
         typeset msg='This is a local ordinary parameter'
         print $msg
         typeset -r msg='This is a local readonly parameter'
         print $msg
         msg='Watch me cause an error.'
       }
       fn
       print $msg
       msg='This version of the parameter'\ 
       ' can still be overwritten'
       print $msg

输出

      This is a local ordinary parameter
      This is a local readonly parameter
      fn:5: read-only variable: msg
      This is an ordinary parameter
      This version of the parameter can still be overwritten

不幸的是，在最近这个代码有一个bug——实际上三十秒前：`fn`中的第二个`typeset`错误地在尝试设置新值*之前*将只读标志添加到现有的`msg`，这是错误的且与创建新局部参数时发生的情况不一致。也许令人放心的是shell也会对局部参数感到困惑。（我一点也不觉得安心，因为`typeset`是我倾向于修复bug的代码部分之一，但也许你这样做。）

无论如何，当bug被修复时，你应该得到显示的输出，因为第一个typeset创建了一个局部变量，第二个typeset使其只读，所以最终赋值导致了错误。然后函数中的`$msg`超出了作用域，普通的参数，没有只读限制，再次可见。

我在上一章提到了另一个特殊的typeset选项：

      typeset -T TEXINPUTS texinputs

以与`$PATH`和`$path`工作相同的方式将标量`$TEXINPUTS`和数组`$texinputs`联系起来。这是一次性的；它是`typeset`在命令行上恰好取两个参数名称的唯一时间。`typeset`的所有其他用途都取一个参数列表，任何给定的标志都应用于这些参数。参见手册了解其余标志，尽管大多数更有趣的已经讨论过了。

你需要知道的关于标志的另一件事是，你可以使用`+`符号来关闭相应的属性。所以

      typeset +r msg

允许你再次设置`$msg`。从版本`4.1`开始，你将无法为特殊参数关闭只读属性；这是因为有太多的混淆范围，包括试图在代码中设置常量字符串。例如，`$ZSH_VERSION`总是打印一个固定的字符串；试图改变那是徒劳的。

`typeset`的最终用途是列出参数。如果你只输入`typeset`，你会得到一个完整的参数列表及其值。从3.1.7开始，你可以为参数打开`-H`标志，这意味着在你这样做时隐藏其值。这对于一些更庞大的参数很有用，特别是特殊参数，我将在[第7章](zshguide07.html#ragbag)中关于模块的部分谈论，它们往往会淹没`typeset`产生的显示。

你也可以列出特定类型的参数，通过列出你想要了解的标志。例如，

      typeset -r

列出所有只读参数。你可能期望`typeset +r`列出*不*具有该属性的参数，但实际上它列出相同的参数但不显示其值。`typeset +`以这种方式列出所有参数。

了解参数的另一种好方法是使用特殊扩展`${(t)`*param*`}`，例如

      print ${(t)PATH}

打印`scalar-export-special`：`$PATH`是一个标量参数，带有`-x`标志设置，并且对shell有特殊意义。实际上，`special`意味着比这更多：它意味着获取和设置参数的内部代码以某种方式行为，对参数本身或shell中的其他地方有副作用。还有其他参数，如`$HISTFILE`，被shell使用，但以正常方式获取和设置——它们只是在shell查看值时才特殊；毕竟，任何旧的shell函数也可以这样做。与此形成对比的是`$PATH`，它有所有那些与哈希命令相关的附加设备需要在设置时处理，如我上面讨论的，我希望你能看到区别。

**读入参数**\

顾名思义，`read`内置命令与`print`相反（shell中没有`write`命令，尽管通常有一个名为该名称的外部命令向另一个用户发送消息），但读取，与打印不同，需要shell中的某些东西改变以获取值，所以与`print`不同，`read`被迫是一个内置命令。不可避免地，值被读入一个参数。通常它们取自标准输入，通常是终端（即使你在运行脚本，除非你重定向了输入）。所以最简单的情况只是

      read param

如果你输入一行并按回车，它将被放入`$param`中，不包括最后的换行符。

`read`内置命令实际上对输入进行了一些处理。它通常会剥离从读入行中初始或最终的空白（空格或制表符），尽管中间的任何空白都会保留。你可以通过列出要分配给它们的参数来读取一组由空白分隔的值；最后一个参数获取行的其余部分而不进行分割。通常最容易直接读入一个数组：

      % read -A array
            this is a line typed in now, \ 
          by me,    in this   space
      % print ${array[1]} ${array[12]}
      this space

（我假设你使用的是原生zsh数组格式，而不是用`KSH_ARRAYS`设置的格式，并将继续假设这一点。）

当你想读取某些内容时，能够打印提示符是有用的。你可以用`print -n`做到这一点，但有一个简写：

      % read line'?Please enter a line: '
      Please enter a line: some words
      % print $line
      some words

注意引号包围`?`以防止它在命令行上被视为模式的一部分。如果你愿意，你可以从`line`的开头引用整个表达式；我只是这样写，因为我知道参数名称不需要引用，因为它们不能有奇怪的字符。这几乎是合乎逻辑的。

`read`的另一个有用技巧是读取单个字符；`-k`选项可以做到这一点，实际上你可以在`k`后面立即粘贴一个数字来指定要读取的数字。更容易的是，`-q`选项读取单个字符，如果它是`y`或`Y`则返回状态0，否则返回状态1；因此你可以读取是/否问题的答案而根本不需要使用参数。注意，然而，如果你不提供参数，回复无论如何都会分配给`$REPLY`如果它是标量——如`-q`的情况——或`$reply`如果它是数组——即如果你指定`-A`但没有参数名称。这些是shell使用的更多非特殊参数的例子——它设置`$REPLY`或`$reply`，但只是以你设置它们的相同方式；没有副作用。

像`print`一样，`read`有一个`-r`标志用于原始模式。然而，这对`read`只有一个效果：没有它，行尾的`\`指定下一行是当前行的延续（你可以在终端上输入时这样做）。有了它，`\`不会被特殊处理。

最后，关于单词分割的一个更复杂的说明。我说过，当你读取到许多参数或数组时，单词在空白处分割。实际上，shell在`$IFS`参数中找到的任何字符上分割单词，`$IFS`代表"输入字段分隔符"。默认情况下——在绝大多数使用中——它包含空格、制表符、换行符和空字符（字符零：如果你知道这些通常用于标记字符串的结尾，你可能会惊讶shell将它们作为普通字符处理，但它确实如此，尽管打印它们通常不显示任何内容）。然而，你可以将它设置为任何字符串：输入

      fn() {
        local IFS=:
        read -A array
        print -l $array
      }
      fn

并输入

    one word:two words:three words:four

shell将向你显示它读取的数组的内容，每行一个"单词"：

      one word
      two words
      three words
      four

你会看到香蕉，呃，单词（为三十岁以上的人开的玩笑）被视为由冒号分隔，而不是由空白分隔。使`$IFS`局部在旧版本的zsh中不起作用，就像其他特殊参数一样；你必须保存并恢复它。

zsh中的`read`命令不允许你进行行编辑，一些shell可以。为此，你应该使用`vared`命令，它运行行编辑器来编辑参数，带有`-c`选项，允许`vared`创建新参数。它还接受`-p`选项来指定提示符，所以上面的一个例子可以重写为

      vared -c -p 'Please enter a line: ' line

这工作得像read但有完整的编辑支持。如果你给`-h`选项（历史），你甚至可以从前一个命令行检索值。然而，它没有read的所有格式选项，尽管当读取数组时（使用`-a`选项与`-c`一起如果创建新数组），它将执行分割。

**控制参数的其他内置命令**\

处理参数的其余内置命令可以更快地处理。

内置命令`set`只是设置作为参数传递给函数或脚本的特殊参数，你通过`$*`或`$@`或`$<number>`（Bourne-like格式）或通过`$argv`（csh-like格式）访问，无论如何设置它们被称为"位置参数"：

      % set a whole load of words
      % print $1
      a
      % print $*
      a whole load of words
      % print $argv[2,-2]
      whole load of

这就像你在一个函数中，并用参数`a whole load of words`调用了函数。实际上，set也可以用来设置shell选项，要么作为标志，例如`set -x`，要么作为`-o`后的单词，例如`set -o xtrace`与前面的例子相同。通常使用`setopt`更容易，结果是你在以`-`开头设置参数时需要小心。在真正的参数前放`--`可以解决这个问题。

`set`的另一个用途是通过

      set -A any_array words to assign to any_array

设置任何数组，这等同于（也是标准Korn shell版本）

      any_array=(words to assign to any_array)

在某些情况下，`set`版本更有用，如果数组的名称本身来自参数：

      arrname=myarray
      set -A $arrname words to assign

在其他形式中没有简单等价物；普通赋值的左手边不会扩展参数：

      # 不起作用；语法错误
      $arrname=(words to assign)

这在旧版本的zsh中起作用，但这在非标准方面。下面描述的`eval`命令给出了另一种解决方法。

接下来是`shift`，它只是将数组向上移动一个元素，删除原始的第一个元素。没有数组名称，它对位置参数进行操作。你也可以给它一个数字来移动，而不是一个，在数组名称之前。

      shift array

等同于

      array=(${array[2,-1]})

（几乎——我将在扩展章节中留下细微差别）它选取数组的第二个到最后一个元素并将它们重新分配给原始数组。注意，再一次，`shift`使用*名称*操作数组，而不是*值*，所以`$`不应该出现在前面，否则你会得到类似于我为`set -A`展示的技巧。

最后，`unset`取消设置一个参数，我已经向你展示了如何取消设置关联数组的键/值对。这里有一个细节要提到。通常，`unset`只是让命名的参数从地球上消失。然而，如果你在函数中调用`unset`，它的幽灵仍然存在，因为它记住任何你以相同名称创建的参数将按照原始参数的作用域进行作用域。因此：

      var='global value'
      fn() {
        typeset var='local value'
        unset var
        var='what about this?'
      }
      fn
      print $var

最终语句打印`global value`：即使`$var`的本地副本被取消设置，shell记住它是本地的，所以函数中的第二个`$var`也是本地的，其值在函数结束时消失。

[]{#l38}

### 3.2.7: 历史控制命令

访问shell命令历史的最简单方法是直接编辑它。第二简单的方法是使用`!`-历史机制。其他操作历史的方法基于`fc`内置命令，它可能曾经代表什么（根据Oliver Kiddle的说法，"fix command"，这和任何事情一样好）。我在上一章谈了很多关于它的事情，我真的没有更多的要添加。只需注意其他两个基于它的命令是`history`和`r`。

[]{#l39}

### 3.2.8: 作业控制和进程控制

C-shell的主要贡献之一是作业控制。你需要了解前台和后台任务，我再次在上一章中介绍了它们以及控制它们的选项。这里是相关内置命令的介绍。

你以两种方式启动后台作业。首先，直接地，通过在它后面放一个`&`：

      sleep 10 &

其次，通过以正常方式启动它（即在前台），然后输入`^Z`，并使用`bg`命令将其放入后台。在输入`^Z`和`bg`之间，作业仍然存在，但没有运行；它被"挂起"或"停止"（系统使用不同的描述来描述同一件事），等待你决定对它做什么。无论哪种情况，作业都会继续运行而无需shell等待。如果这样启动，它仍会尝试从或写入终端；你需要在启动时使用shell的重定向功能来改变这一点，在作业已经开始后你无能为力。

顺便说一句，`sleep`不是内置命令。奇怪的是，你可以用`^Z`挂起内置命令或命令序列（如shell函数），尽管由于shell必须继续执行你的命令以及被挂起，它只能做它能做的事情——分叉，所以被挂起的命令被放入后台。可能你只会很少这样做。据我所知，没有其他shell有这个功能。

如果作业需要从终端读取，它会停止。你会看到这样的消息：

      [1]  + 1348 suspended (tty input)  jobname and arguments

这意味着作业被挂起，就像你刚刚输入了`^Z`一样。你需要将作业带到前台，如下所述，这样你才能输入一些东西。

顺便说一下，挂起命令的键可能不是`^Z`；通常是，但可以改变。运行`stty -a`并查看` susp =`后面列出的内容——可能是，但不一定是`^Z`。所以如果你想使用另一个字符——它必须是单个字符；这在终端接口深处处理，不在shell中——你可以运行

      stty susp '^]'

或任何其他。你会从`stty`输出中注意到，各种其他作业控制字符可以类似地改变。`stty`命令是外部的，其输出和输入格式在不同系统上可能有很大差异。

你可以用`fg`将命令带回前台。这对于临时停止你正在做的事情以便做其他事情很有用。如今你会在另一个窗口中这样做；在旧时代当人们从简单终端登录时，这甚至更有用。一个典型的例子是

      more file                        # 查看文件
      ^Z                               # 挂起
      [1] + 8592 suspended  more file  # 打印的消息
      ...                              # 做其他事情
      fg %1                            # 恢复`more'

`%`是引用作业的通常方式。其后的数字是在挂起消息中出现的方括号中的数字；我不知道为什么shell不在那里也使用`%`符号。你也看到它与后台作业的`continued`消息一起出现，再次在告诉你后台作业已完成的`done`消息中出现。`%`可以采用其他形式；最常见的形式是跟在命令名称后面，如本例中的`%more`。`%+`和`%-`形式分别指最近和第二最近的作业——`suspended`消息中的`+`是在告诉你`more`作业可以这样引用。

大多数作业控制命令实际上会假设你在不给参数时谈论的是`%+`，所以假设我没有在后台启动任何其他命令，我可以在上面的命令序列末尾只放`fg`。这实际上两全其美：`fg`是使用`%`符号引用作业时的默认操作，所以只输入`%1`而不带命令名称也会起作用。

你可以用`jobs`命令来提醒自己正在发生什么。它看起来像一系列以方括号中数字开头的消息；通常作业要么是`running`要么是`suspended`。这会告诉你需要的数字。

你可以对作业做的另一件有用的事是告诉shell忘记它。这只有在它已经在后台运行时才真正有用；然后你可以用作业标识符运行`disown`。这对于你想要在注销后继续运行的作业，以及有自己窗口的作业（你可以直接控制）很有用。对于被遗弃的作业，shell在你注销时不会警告你它们仍然存在。你实际上可以在启动时通过在行尾放`&|`或`&!`而不是简单的`&`来遗弃后台作业。注意，如果作业在你遗弃它时被挂起，它将保持遗弃状态；这相当无意义，所以你可能应该先在它上面运行`bg`。

接下来你最可能想对作业做的事是杀死它，或者在它已经在后台时暂停它而你不能只输入`^Z`。这就是`kill`内置命令的用武之地。这比上面提到的内置命令有更多内容。首先，你可以用其他不是从当前shell启动的进程使用`kill`。在这种情况下，你会使用一个数字来标识它，没有`%`——这就是其他情况中`%`存在的原因。当然，你需要找到数字；通常的方法是使用`ps`命令，它不是内置命令但在所有类UNIX系统上都出现。作为一个愚蠢的例子，这里我启动了一个不做什么的被遗弃进程，查找它，然后杀死它：

      % sleep 60 &|
      % ps -f
      UID        PID  PPID  C STIME TTY          TIME CMD
      pws        623   614  0 22:12 pts/0    00:00:00 zsh
      pws       8613   623  0 23:12 pts/0    00:00:00 sleep 60
      pws       8615   623  0 23:12 pts/0    00:00:00 ps -f
      % kill 8613
      % ps -f
      UID        PID  PPID  C STIME TTY          TIME CMD
      pws        623   614  0 22:12 pts/0    00:00:00 zsh
      pws       8616   623  0 23:12 pts/0    00:00:00 ps -f

第二次我看时，进程已经消失了。注意在通常的忧郁的UNIX方式中，shell没有费心告诉你进程已被杀死；然而，如果它未能发送信号，它会报告错误。发送信号是shell关心的全部；shell不会警告你如果进程决定在被告知时不想死，所以检查仍然是个好主意。

有时你想等待一个进程退出；`wait`内置命令可以做到这一点，像`kill`一样，它可以接受进程号以及作业号。然而，这有点欺骗性——你实际上不能等待一个不是直接从shell启动的进程。实际上，等待机制与UNIX处理进程的方式紧密相关；除非它的父进程等待它，否则进程会变成"僵尸"并挂在那里，直到系统的养父，"init"进程（总是进程号1）等待它。这都是有点巴洛克式的，但对于shell用户来说，wait只是意味着你可以挂起直到你启动的某件事完成。实际上，这就是前台进程的工作方式：shell实际上使用内部版本的`wait`来挂起直到作业退出。（好吧，实际上那是个谎言；系统会从它正在做的事情中唤醒它来告诉它一个子进程已经完成，所以它所要做的就是打盹等待。）

此外，即使作业控制没有运行，你也可以等待一个进程。作业控制，基本上任何涉及那些`%`的东西，只有在你坐在终端前摆弄命令时才有用；当你运行脚本时，它不操作。然后shell在如何控制其作业方面有更少的自由，但它仍然可以等待后台进程，并且如果它知道其数字，它仍然可以对其使用`kill`。为此，shell将最后一个在后台启动的进程的ID存储在参数`$!`中；可能有一个很好的理由使用`!`，但我不知道是什么。无论作业控制如何，这都会发生。

**信号**\

`kill`命令可以做的远不止杀死一个进程。这是默认操作，这就是命令有这个名字的原因。但它真正做的是向进程发送一个"信号"。信号是与另一个进程通信的最简单方式；实际上，如果你没有为进程读取来自你的消息做出特别安排，这是唯一简单的方式。信号名称写成`SIGINT`、`SIGTSTP`、`SIGKILL`；要向进程发送特定信号，你删除`SIG`，在前面加一个连字符，并将其用作`kill`的第一个参数，例如：

      kill -KILL 8613

你已经知道的一些事情实际上正是在这样做。当你输入`^C`来停止一个进程时，你实际上是在向它发送一个`SIGINT`用于"中断"，就像你做了

      kill -INT 8613

`kill`通常发送的信号不是，正如你可能猜到的，`SIGKILL`，而是`SIGTERM`用于"终止"；`SIGKILL`更强，因为进程不能阻止该信号，就像它可以阻止许多信号一样（我们稍后会看到shell如何做到这一点）。这对熟悉的人来说是熟悉的。