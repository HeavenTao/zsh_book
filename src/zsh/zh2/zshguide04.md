------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide03.html)
-   [下一章](zshguide05.html)

------------------------------------------------------------------------

[]{#zle}[]{#l75}

# 第4章：Z-Shell 行编辑器

zsh行编辑器可能是你开始输入命令时最先使用的shell部分。即使是像sh这样的最基本shell，也提供某种编辑功能，尽管在这种情况下可能只是系统本身做的事情——输入字符、删除最后一个字符、删除整行。如今你可能使用的大多数shell都提供更多功能。使用zsh，你甚至可以使用shell函数扩展编辑器命令集。

[]{#l76}

## 4.1: 介绍zle

zsh行编辑器通常缩写为`zle`。通常它会为自己启动任何交互式shell；除非你决定需要改变其行为，否则你不需要做任何特别的事情。如果一切看起来正常并且你对zle如何启动不感兴趣，请跳到下一小节。

如今，zle存在于其自己的可加载模块`zsh/zle`中，这节省了在shell非交互式时拥有编辑器的所有开销。然而，通常你不需要担心这一点；我将在[第7章](zshguide07.html#ragbag)中更多地谈论模块，但shell知道何时需要zle并自动为你提供它。通常该模块位于类似`/usr/local/lib/zsh/4.0.4/zsh/zle.so`的目录中，其中`4.0.4`是shell的版本号，与参数`$ZSH_VERSION`的值相同，除后缀`.so`外的所有内容都是模块名称。后缀可能是`.sl`（HP-UX）或`.dll`（Cygwin），但`.so`是最常见的形式。它有所不同，因为zsh对动态可加载库或UNIX术语中的"共享对象"保持与操作系统的相同约定。

如果shell安装得很糟糕，有时你会看到错误消息，说它或像`bindkey`这样的命令无法加载。这意味着shell在模块加载路径数组`$module_path`中找不到`zsh/zle`。那么你需要向系统管理员抱怨。如果你刚刚编译了zsh并遇到这个问题，这是因为你必须在运行shell之前安装模块，即使shell本身没有安装。你可以通过说`make install.modules`来做到这一点。然后编译的zsh应该从它所在的地方运行。

注意，与bash的行编辑器readline不同，readline是一个完全独立的库，zle是shell的组成部分。因此你通过在`.zshrc`中粘贴命令来配置它——因为它只对交互式shell有用，只有`/etc/zshrc`和`.zshrc`对此目的才有意义。

如果你使用info查看zsh手册，无论是使用该名称的命令还是在Emacs中使用`\C-h i`（我发现这是最方便的方式）：zle的条目叫做"Zsh Line Editor"，全称，而不是仅仅"Zle"。当你在其中时，顺便找找"Shell Builtin Commands"（不是"Builtins"）。

[]{#l77}

### 4.1.1: 简单事实

与任何晚于`ed`的编辑器一样，你可以在行中移动并使用各种"按键"更改它，换句话说，你一次输入的一组或多组键。例如，向后移动一个单词的按键是（也许）`ESC b`。这意味着你首先按escape键；还没有发生任何事情。然后你按`b`，光标立即跳回单词的开头。（我稍后会更多地谈论zle认为什么是"单词"——它不一定是shell其余部分认为的单词。）

如果你立即介绍shell描述按键的方式，可能会有帮助；这样当你需要输入它们时，你可以直接复制进去。escape键是`\e`，所以那个按键会是`\eb`。其他常见按键包括按住控制键（可能在键盘左下角）并同时输入另一个键。指示控制键的最简单方法就是在前面加上`^`；例如`^x^x`意味着按住控制键，并按两次`x`，控制键仍然按住。它与`^X^X`具有完全相同的效果。（你可能会发现每次这样做时，它会带你到行首，然后回到你原来的位置。）

我已经引入了"也许"这个词来试图避免撒谎。这是因为实际上zle有两种操作模式，一种（默认）像Emacs，另一种像vi。如果你不知道这两个古老的UNIX编辑器中的任何一个，我建议你坚持使用Emacs模式，因为它倾向于较少干扰你正在做的事情，而且完成也更容易一些。完成是zle行为的一个分支，在[第6章](zshguide06.html#comp)中有描述（你会注意到，它比这一章长）。

如果你通常使用vi，你可能有一个或两个环境变量`$EDITOR`或`$VISUAL`设置为`vi`。（如果你使用`vim`代替，或者任何恰好包含`vi`的编辑器如`elvis`，它的工作方式也是一样的。）在这种情况下，zle将启动其`vi`模式，其中按键序列相当不同。这就是为什么你可能发现`\eb`没有做我说的，即使你没有尝试配置zle。你可以通过在`.zshrc`中放入

      bindkey -e

或

      bindkey -v

来使zle总是使用emacs或vi模式。这只是`bindkey`的许多用途之一。

如果你不熟悉"bind"这个词的这种用法，它只是意味着"使按键执行特定的编辑器命令"。命令有冗长的名字，用连字符分隔，这些名字相当清楚地描述了它们做什么，比如`backward-delete-char`。通常对应于可打印字符的普通键被绑定到`self-insert`，这是一种奇怪的说法，意思是它们做你期望的事并显示你输入的字符。然而，你实际上可以将它们绑定到其他东西。在vi命令模式中，这是完全正常的。

实际上，如果你使用窗口系统，你可能想说`bindkey -me`，它绑定了一整套"元"键。在X Windows中，你键盘上的一个键，可能是`ALT`，可能被指定为"元"键，它有类似于控制键的特殊效果。用元键按下的绑定描述得有点像它们在Emacs中的描述，`\M-b`。（你可以类似地指定控制键，实际上，像`\C-x`，但`^x`更短。）使用`bindkey`的`-m`选项告诉zsh，无论它在哪里绑定像`\eb`这样的转义序列，它也应该绑定相应的元序列，如`\M-b`。Emacs总是将这些联系在一起，但zsh不——你可以单独重新绑定它们。如果你想将两个序列都绑定到新命令，你必须显式地绑定它们。

但你需要小心使用`bindkey -m`；shell无法判断你是输入了一个设置了最高位的字符，还是执行一个命令。随着UTF-8字符编码变得越来越流行，这可能会变得更糟，因为非ASCII字符由一系列设置了最高位的字节组成。

如果你对绑定功能键感兴趣，你可能已经发现它们发送的键序列显然没有意义；请参见[下面的部分](zshguide04.html#fkeys)了解更多信息。这将介绍名为`zkbd`的函数，它可以使过程不那么痛苦。该函数还有助于"元"和"ALT"键。

[]{#l78}

### 4.1.2: Vi模式

出于各种原因，我将专注于Emacs模式：首先，因为我自己使用它；其次，因为使用vi模式的最可能原因是你已经熟悉vi并且不需要被告知它是如何工作的；第三，因为大多数命令在这两种模式下是相同的，只是绑定不同；最后，因为如果你*不*已经知道vi，你很可能会发现vi编辑模式相当反直觉且难以使用。

然而，这里有一些关于它的评论只是为了摆脱它。像真正的vi编辑器一样，有两种基本模式，插入模式（你输入文本）和命令模式（你输入字符的相同按键被绑定到编辑命令而不是插入字符）。与真正的vi不同，行编辑器在你编辑的每个新命令上都从插入模式开始。这意味着你通常可以简单地输入一行直到结尾的"return"，完全忘记你在vi模式中。

要进入命令模式，你按"escape"，再次就像正常的vi一样。此时你处于vi命令的魔法世界中，输入普通字符可以产生任何效果。然而，绑定类似于正常的vi，所以`h`和`l`向左和向右移动。当你想要插入更多文本时，你可以使用任何允许你这样做的正常vi命令，如`i`（`vi-insert`）或`a`（`vi-add-next`）。

除了单独的命令和插入模式以及完全不同的键绑定集之外，Emacs模式和vi模式之间没有基本区别。你可以在vi模式的两个模式中绑定键——它们在插入模式下*不必*对应于`self-insert`。下面，我将描述"键映射"，这是对所有键将做什么的完整描述集（听起来不如实际那么令人印象深刻，因为许多键可能被设置为`undefined-key`，这意味着它们不做任何有用的事情），你将看到如何在这两种模式下改变行为。

[]{#l79}

## 4.2: 基本编辑

如果你知道Emacs或vi，你很快就会发现如何做简单的命令，如移动光标、在历史列表中上下移动、删除和复制单词。如果你不知道，你应该阅读`zshzle`手册页以获得对其功能的简洁描述。这里是Emacs模式的摘要。

[]{#l80}

### 4.2.1: 移动

你可以使用光标键在行上向前和向后移动。光标键产生按键序列有各种不同的约定。你可能天真地期望，比如说，光标右键发送类似"光标右"的信号给应用程序。不幸的是，在ASCII字符集中没有这样的字符，因此像zsh这样读取输入作为字符字符串的程序必须被给予任意的字符字符串。（对于理解其他形式输入的程序，如窗口系统，这是不同的。）

光标键最常见的两种约定是上键发送`\e[A`，其他三个键发送`B`、`C`和`D`在末尾，以及将`[`替换为`O`（大写字母`O`）的约定。在旧版本的zsh中，唯一支持的约定是前两个中的第一个。第二个和任何其他约定完全不被支持，你必须自己绑定键。这通过如下方式完成：

      bindkey "\eOA" up-line-or-history
      bindkey "\eOB" down-line-or-history
      bindkey "\eOC" forward-char
      bindkey "\eOD" backward-char

shell现在更加努力，并且只要你的系统有关于你终端的正确信息（zsh使用一个叫做"termcap"的旧系统，这已经被另一个叫做"terminfo"的系统所取代），你应该很幸运。如果shell认为你的键太奇怪——特别是，如果它想要绑定功能的按键序列已经被zsh定义——你仍然必须手动完成。上面的列表应该作为模板。

除了光标键，传统的Emacs键也可用：`^b`和`^f`用于向后和向前，`^p`和`^n`用于上一行和下一行，所以即使光标键不起作用，你也可以继续。

移动更长的距离通过`\eb`和`\ef`向后或向前移动一个单词（或者，如你所见，`\M-b`和`\M-f`），以及`^a`和`^e`用于行的开头和结尾。这几乎涵盖了你最常使用的那些。

[]{#l81}

### 4.2.2: 删除

对于删除，退格键或删除键将向后删除。由于PC键盘中央键盘部分左上角的键是"退格"，它是字符`^h`，而在传统的UNIX键盘上它是"删除"，字符127，通常写成`^?`（zsh也理解），所以关于这些键存在一场永恒的战斗。当你处于系统的原始行编辑模式时，如sh（除非你的sh实际上是bash），只有其中一个被"绑定"，尽管它实际上不是键绑定，而是系统终端驱动程序进行的转换，通常是错误的。因此你经常发现系统在屏幕上打印`^h`，而你想要它删除。你可以使用

      stty erase '^h'

改变键，但zsh保护你免受所有这些困扰——`^h`（退格）和`^?`（删除）都会向后删除一个字符。顺便说一句，请注意zsh不理解任何按键序列的智能名称——如果你尝试绑定一个叫做`backspace`的键，zsh会将命令绑定到该字符序列，而不是该名称的键。请参见关于`bindkey -s`的注释，了解什么时候这甚至可能是有用的。

为了进一步混淆，PC键盘上101键或102键键盘上光标键上方那组6个键中标记为"删除"的键是完全不同的，可能不发送这两个序列中的任何一个。在我的键盘上，它发送序列`\e[3~`。我发现将它绑定为删除下一个字符很方便，这是它在PC世界中的传统角色，我这样做：

      bindkey '\e[3~' delete-char

然而，传统的*Emacs*删除下一个字符的方式是使用`^d`，zsh默认为你绑定它。如果你查看绑定，你可以通过不给bindkey一个要绑定的编辑器命令来做到这一点，

      % bindkey '^d'
      delete-char-or-list

你会看到它并不*完全*如我所建议的那样。`-or-list`部分用于完成，你将在下一章了解它。我所知道的第一个有这种奇怪组合的shell是tcsh。

既然我喜欢混淆，我可能也应该指出，通常`^d`有另一个用途，即告诉终端驱动程序你已经到达文件的末尾。在磁盘上的文件的情况下，系统自己知道这一点，但如果你提供一串字符流，告诉它的唯一方法是发送一个特殊字符。默认通常是`^d`。你会注意到如果你在行首输入`^d`，你会看到消息

      zsh: use 'exit' to exit.

这是因为zsh在那个位置将`^d`识别为文件结束。默认情况下，shell会警告你；你可以通过设置选项`IGNORE_EOF`来关闭它。你可以告诉系统你不想以这种方式发送文件结束，使用`stty`，再次：以下在Linux中是等价的，但你的系统可能需要其中一个或另一个：

      stty eof '^-'
      stty eof undef

记住`stty`不是shell的一部分；它是控制系统终端驱动程序状态的一种方式。这意味着只要终端或终端窗口仍然连接，它就会持续存在，即使你启动一个新的shell或退出一个不是登录shell的shell。

顺便说一下，如果你需要通过数字引用一个字符，最简单的方法可能是使用语法`\x??`，其中`??`是该键的两个十六进制数字。在删除的情况下，它是`\x7f`。你可以通过以下方式确认：

      % bindkey '\x7f'
      "^?" backward-delete-char

[]{#l82}

### 4.2.3: 更多删除

你可以通过`\ed`删除下一个单词，通过`\e^h`或`\e^?`（转义后跟向后删除）删除前一个单词。`^u`通常删除光标前后的整行——这不像Emacs，其中`^u`引入数字参数，如我将在下一小节中描述的。然而，它像终端驱动程序本身提供的另一个原始编辑命令一样，这个命令被`stty`称为`kill`。在zsh之外最常见的是用于删除你的密码当你登录时，当你知道你输入错误但看不到你输入了多少！@？*！字符，并且可能不能依赖终端同意哪个`^h`或`^?`会删除单个字符。

严格来说，上一段中的所有按键都执行"杀死"（zsh术语，不要与`stty`的"杀死"混淆），而不是"删除"（或删除，正如我们在有动词和名词区分时所说的）。区别与Emacs中的相同——"杀死"的文本被保存以供稍后"拉回"到其他地方，你用`^y`键这样做，而"删除"的文本如`^?`和`^d`永远消失了。这是每个不是在Emacs下长大的人都称之为"剪切"和"粘贴"的东西（尽管由于Emacs可以追溯到七十年代，可能是每个人都是错的）。另一个从Emacs借用的功能是，如果你进行多次"杀死"而中间没有其他编辑，被杀死的文本会连接在一起，你可以一次性拉回所有内容。当我谈论点和标记时（另一个Emacs想法），我会说得更多。

实际上，即使是删除的文本也不会永远消失：zsh有一个类似Emacs的编辑历史，你可以撤销行上的先前命令。这通常绑定到`^xu`和`^x^u`，还有一个较短的绑定，被描述得相当混乱为`^_`——令人困惑，因为在我使用过的所有非完全间隔的键盘上，你实际上通过按住控制键并按`/`键来生成该序列。Zsh默认不使用`^z`，如果你习惯了Windows，这是`undo`的另一个合适的绑定。

Zsh在一个方面胜过Emacs——它还有`redo`，默认不绑定。这意味着如果你撤销过多，你可以通过重复使用`redo`命令来放回你刚刚撤销的内容。

[]{#l83}

## 4.3: 高级编辑

[]{#l84}

### 4.3.1: 控制zle的选项

与完成不同，`zle`没有很多与之相关的选项；大多数控制是通过键绑定和内置命令完成的。只有两个真正有用；两者都控制蜂鸣声。选项`beep`可以被取消设置以告诉shell在错误时从不发出声音；选项`histbeep`可以被取消设置以仅在尝试在第一个历史条目之前向后或在最后一个历史条目之后向前时禁用蜂鸣声。

不太有用的选项是`zle`和`singlelinezle`。前者控制zle是否处于活动状态，不太有用，因为它通常在你需要时自动开启，换句话说是在交互式shell中，而在你不需要时关闭。但是，通过`[[ -o zle ]]`进行测试有时是有用的；这让你的函数在交互式shell中做一些更聪明的事情。

选项`singlelinezle`将编辑限制为一行；如果它变得太长，它将被截断，并在缺失位的地方打印一个`$`。它只存在于与ksh的兼容性和作为终端完全搞砸时的安全措施，尽管即使在这种情况下，zsh也会尝试猜测它需要的所有东西是否可用。

影响zle的其他函数包括历史函数。这些在[第2章](zshguide02.html#init)中描述过；一旦你设置了它，通过zle搜索历史基本上与使用`!`历史命令相同。

[]{#l85}

### 4.3.2: 迷你缓冲区和扩展命令

"迷你缓冲区"是另一个Emacs概念；它是出现在命令行下方的提示符，用于输入编辑器本身需要的编辑。通常，它来来去去随它高兴，你不需要考虑它。最常见的用途是输入文本进行搜索，以及输入未绑定到字符串的命令。这是另一个Emacs功能：`\ex`提示你输入命令的名称。幸运的是，由于名称往往相当长，可以使用完成。因此输入`\echo foo<ESC>xba<TAB>w<TAB>`\'

最终得到：

      % echo foo
      execute: backward-word

然后按回车键执行该函数，将你带到`foo`的开头；你可能能够想到更简单的方法来做这件事。这确实提供了一种运行你不经常使用的命令的方法。

（我希望我的符号不会太令人困惑。当我显示你按下的单个字符时，我写成`<TAB>`，以使其与周围文本区分开来。然而，当我没有显示输入文本时，我会将其写成`\t`，这是你输入字符到要绑定的键序列或要打印的字符串时的方式。）

迷你缓冲区只处理非常有限的一组编辑命令。输入它不理解的命令通常会退出你试图用迷你缓冲区做的事情，然后执行按键。然而，在这种特定情况下，它不会让你退出，直到你完成输入命令；你唯一的其他选择是中止。通常的zle中止字符是`^g`，`send-break`。这与更剧烈的`^c`不同，后者向shell本身发送中断信号。然而，在zle中它们通常具有相同的效果。（你会注意到`^c`实际上被绑定到`undefined-key`，换句话说，zle不认为它做任何事情。然而，终端驱动程序可能使其发送中断，而zle确实对此作出响应。）

另一个对稀有命令有用的特性是`where-is`。惊喜！它默认不绑定，所以输入`<ESC>xwhere-is`是运行它的方式。然后你在`Where is:`提示符下输入另一个编辑器命令，shell会告诉你绑定到它的按键序列（如果有的话）。你也可以简单地在`bindkey`的输出上使用`grep`，它在没有参数时列出所有绑定。

[]{#l86}

### 4.3.3: 前缀（数字）参数

许多命令可以通过给它们一个数字前缀或数字参数来重复。例如，在一行长文本的末尾，输入`<ESC>4<ESC>b`。单独的`<ESC>b`会带你向后一个单词。`<ESC>4`传递数字四，它向后移动四个单词。一般来说，只要重复命令有意义，这就行得通。它也适用于`self-insert`，只是重复插入字符。如果它不起作用，前缀参数将被忽略。

你可以通过重复`\e`和其后的数字或`-`来构建长或负参数；例如，`<ESC>-<ESC>1<ESC>0`指定负十。从命令到命令，负数的用处各不相同，但它们通常从向后切换到向前或类似：`<ESC>-<ESC>4<ESC>\f`是执行与`<ESC>4<ESC>b`相同操作的无意义方式。

shell还有Emacs的`universal-argument`功能，但它默认不绑定——在Emacs中它是`\C-u`，但正如我们所见，它已经被使用了。这是所有这些转义的替代方案。如果你将命令绑定到一个按键（否则作为快捷方式是完全无意义的），然后输入那个键，然后一个可选的减号后跟任何数字被记住作为前缀。下一个不是这些的按键然后作为命令执行，带有在`universal-argument`后输入的数字形成的前缀。

例如，在我的键盘上，F12键发送键序列`\e[[24~`——请参见下文了解如何找出功能键发送的内容。因此我使用

      bindkey '\e[[24~' universal-argument

然后如果我按字符`F12`、`4`、`0`、`a`，一行四十个`a`被插入到命令行上。我并不是声称这个例子特别有用。

[]{#l87}

### 4.3.4: 单词、区域和标记

单词在zsh中的处理方式与大多数编辑器中略有不同。首先，Emacs模式和vi模式对单词的考虑有所不同。也就是说，默认情况下在这些模式中绑定的函数有所不同；你可以通过重新绑定键在任一模式中使用相同的函数。

在vi和Emacs模式中，无论你是向前还是向后移动多个单词，或者删除或杀死它们，关于单词的相同逻辑都适用；杀死时删除的文本量与光标在另一种情况下移动的量相同。

在vi模式中，单词基本上与vi认为的单词相同：一连串的字母数字字符连同下划线——基本上，可以在标识符中出现的字符，实际上zsh内部就是这样识别vi"单词字符"的。然而，关于vi的逐字行为有一个小的奇异性，你可以很容易地看到，如果你输入`/a/filename/path/`，用`ESC`离开插入模式，并使用`w`或`b`在上面向前或向后跳过单词。它在移动单词中的字符和分隔符`/`中的字符之间交替。

然而，在Emacs中，它是以一种略有不同的方式完成的。vi的"单词字符"总是被认为是单词的一部分，但有一个参数`$WORDCHARS`，它给出一个字符串，其中的字符*也*是单词的一部分。这可能与你预期的相反；鉴于字母数字总是单词的一部分，你可能期望有一个参数来添加你*不*希望成为单词一部分的字符。但事实并非如此。

与vi不同，跳过一个单词总是意味着跳到单词开头的单词字符。在跳过非单词字符时不会使用额外的"回合"。

`$WORDCHARS`的默认值是

      *?_-.[]~=/&;!#$%^(){}<>

即几乎所有的东西和厨房水槽。因此，通常你会想要删除你不希望被认为是单词部分的字符；`-`、`/`和`.`是特别可能的可能性。如果你想删除个别字符，你可以用一些模式匹配技巧来做到这一点（下一章）：

      % WORDCHARS=${WORDCHARS//[&.;]}
      % print $WORDCHARS
      *?_-[]~=/!#$%^(){}<>

显示操作已经从`$WORDCHARS`中删除了那三个字符，即`&`、`.`和`;`。`//`表示全局替换：方括号中的任何字符都被替换为空。

许多其他行编辑器，甚至那些像`readline`一样具有Emacs绑定的编辑器，表现得好像只有标识符字符是单词的一部分，即好像`$WORDCHARS`是空的。这在zle shell函数中非常容易做到。zsh的最新版本提供函数`bash-forward-word`、`bash-kill-word`和一组其他类似的函数，供你绑定到键上以获得该行为。

通过编写函数也可以实现其他行为；例如，你可以通过使用更多替换技巧跳过真正的shell单词（即单个命令参数），或者你可以只考虑空格分隔的单词（尽管这与通过添加`"`'\@ `到`$WORDCHARS`得到的结果相差不远）。

[]{#l88}

### 4.3.5: 区域和标记

Emacs中的另一个有用概念是区域和标记。在Emacs术语中，"点"是光标所在的位置，"标记"是你要稍后返回的地方留下的标记。设置标记在当前点的命令是`^@`，就像在Emacs中一样，这是一个象形文字，通常意味着按住控制键并按下空格键。在某些系统上，如带有著名非UNIX窗口系统提供的有限版`telnet`，你无法发送这个序列，你需要将不同的序列绑定到`set-mark-command`。一种可能性是`\e `（转义后跟空格），就像在MicroEMACS中一样。（某些X Windows配置也不允许`^@`在xterm中工作，尽管这通常是可修复的。）

继续用Emacs语言，点和标记之间的区域简单地描述为"区域"。在zsh中，你不能像在窗口系统下直接运行的编辑器那样高亮显示它，所以找到区域末端的最简单方法是用`^x^x`，`exchange-point-and-mark`，我在前面提到过——默认情况下，标记留在行的开头，因此你看到了上面的行为。

各种编辑命令——通常那些名称中包含`region`的命令——都在这个上操作。最常见的是那些杀死或复制区域的命令。令人烦恼的是，`kill-region`没有绑定——在Emacs中，它是`^w`，但zsh遵循将它绑定到`backward-kill-word`的传统，即使这也作为传统的Emacs绑定`\e^?`可用。所以重新绑定它可能是有用的。要复制区域，通常的绑定`\ew`有效。

然后你用`^y`在另一点"拉回"复制或杀死的文本。shell实现了"杀死环"功能，这意味着如果你执行拉回，然后重复输入`<ESC>y`（`yank-pop`），shell会循环回到以前杀死或复制的文本，所以你拥有的不仅仅是最后一个。

[]{#l89}

## 4.4: 历史和搜索

Zle可以访问shell历史中保存的行，如[第2章](zshguide02.html#init)中"设置历史"中所述。基本上有三种检索历史片段的方法：逐行向后移动、搜索匹配的行和从历史中提取单个单词。实际上，前两者非常相似，还有混合命令可以让你逐步后退但仍只匹配特定的行。

[]{#l90}

### 4.4.1: 在历史中移动

最简单的行为是你从正常的光标键绑定中得到的，`up-line-or-history`和`down-line-or-history`。如果你在适合单行的文本中（这可能是一个延续行，即它在行首有`$PS2`形式的新提示符），这会用历史中前一行或后一行替换整个行。历史不是循环的，它有开始和结束。开始是shell仍然记住的第一行（即`$HISTSIZE`行前，考虑到你设置的任何特殊历史选项的效果，这些选项会移除不需要的行）；结束是你正在输入的行。你可以使用`\e<`和`\e>`去历史中的第一行和最后一行。

最后一句话听起来微不足道但实际上不是。输入`echo This is the last line`，用上箭头后退几行，然后回到最后，你会明白我的意思——shell已经记住了你正在输入的行，即使它还没有被输入，所以你可以上下滚动历史并仍然回到它。

当然，你可以编辑任何早期的历史行，然后按`return`使它们被执行——这就是能够滚动回历史的全部意义。也许不那么明显的是，shell也会记住你对这些行所做的更改，直到你按`return`。

例如，在新的shell提示符下输入`echo this is the last line`，但不要按return。现在按一次上箭头，编辑前一行使其说`echo this is the previous line`。如果你上下滚动，你会看到shell保留了这两行。当你决定使用哪一行并按return时，该行被执行并添加到历史的末尾，历史中以前行的任何更改都被遗忘。

有时你不希望将新行添加到历史中，而是逐个重新执行一整系列早期命令。这可以通过`^o`，`accept-line-and-down-history`完成。当你在历史中的行上按`^o`时，该行被执行，历史中的下一行被显示。所以你只需要继续按它来继续执行命令。

还有两个类似的命令我不太常用，`infer-next-history`，绑定到`^x^n`，和`accept-and-infer-next-history`，默认未绑定。"推断"下一个历史意味着shell查看当前行中的内容，无论其来源如何——例如，你可能只是输入了它——并在历史中寻找匹配的行；"推断"的下一行是该行的下一行。在第一种情况下，你只会看到那一行；在第二种情况下，当前行首先被执行，然后你被显示推断的行。如果你发现这是自切片面包以来最好的东西，请随意给我发封信。

关于历史的一个小困惑是，有时很难记住你在其中的确切位置，例如，如果你正在编辑一行并且必须滚动回来查找其他东西。在这种情况下，`\e>`是你的朋友，因为它带你到最后行。此外，每当你按return时，你都被保证在历史的末尾，即使你在历史中某个靠后的地方编辑一行，不像某些其他系统（尽管`accept-line-and-down-history`可以模拟那些）。所以通常不太难保持不混淆你在编辑什么。

[]{#l91}

### 4.4.2: 在历史中搜索

Zsh有你期望用于搜索历史的命令，即你按搜索键然后输入要搜索的单词。然而，它也有其他功能，可能更多地被zsh社区使用，其中搜索基于当前行的某些特征，特别是第一个单词或光标位置之前的行。这些通常使你能够更快地向后搜索，因为你不需要告诉shell你在寻找什么。

**普通搜索**\

标准搜索命令，我指的是你可能从普通文本编辑器（如果Emacs或vi可以这样称呼）中最熟悉的那些，旨在让Emacs和vi用户感到宾至如归。

在Emacs模式中，你有增量搜索：`^r`向后搜索——这通常是你想要的，因为你通常从末尾开始——和`^s`向前搜索。注意`^s`是另一个经常被终端驱动程序拦截的按键序列；在这种情况下，它通常会冻结到终端的输出，直到你输入`^q`来重新打开它。如果你不喜欢这个，你可以使用`stty stop`和`stty start`来改变字符，或者简单地`unsetopt flowcontrol`来完全关闭该功能。然而，绑定到`^s`的命令，`history-incremental-search-forward`，也绑定到`^xs`，所以你可以使用那个代替。

就像在Emacs中一样，对于你输入的每个字符，增量搜索会带你到最近匹配所有字符的历史条目，直到匹配失败。在任何时候输入搜索按键都会带你到缓冲区中字符的下一个匹配。

在vi命令模式中，默认可用的按键序列是熟悉的`/`和`?`。然而，与vi有一些不同。首先，是`/`向后搜索——这是你最常使用的。其次，你不能搜索正则表达式（模式）；唯一的例外是行首的字符`^`锚定搜索到行首。其他一切都只是普通字符串。

另外两个标准vi搜索按键序列也存在：`n`搜索当前字符串的下一个匹配，`N`做同样的事情但反转搜索方向。

**搜索第一个单词**\

下一种搜索可能是最常用的，但只在Emacs模式中绑定：`\ep`和`\en`向前或向后搜索下一个具有与当前行相同第一个单词的历史行。所以通常为了重用命令，你只需输入命令名称本身，然后按`\ep`直到出现你想要的命令行。这些命令简单地称为`history-search-backward`和`history-search-forward`；名称并没有很好地描述功能。

**前缀搜索**\

最后，你可以向后搜索一行，该行从光标位置开始的整个起点与当前行相同。这比`history-search-`*direction*给你更多的控制。相应的命令，`history-beginning-search-backward`和`history-beginning-search-forward`，默认未绑定。我发现将它们绑定到`^xp`和`^xn`很有用，因为这类似于初始单词搜索：

      bindkey '^xp' history-beginning-search-backward
      bindkey '^xn' history-beginning-search-forward

**基于函数的其他搜索命令**\

搜索命令是通过编写shell函数最常自定义的类型之一。最新版本的shell提供了一些；看看`zshcontrib`手册页的ZLE部分。你应该在你的`$fpath`中的某个地方找到这些函数，通常是

      /usr/local/share/zsh/$ZSH_VERSION/functions

或该目录的子目录`Zle`，取决于你的zsh版本是如何安装的。如果shell是预安装的，最可能的位置是

      /usr/share/zsh/$ZSH_VERSION/functions/Zle

这些应该指导你编写自己的函数。

需要注意的一点是，当从函数调用时，`history-search-`*direction*和`history-incremental-search-`*direction*可以接受一个字符串参数，指定要搜索的内容。在第一种情况下，这只是单次搜索，而在第二种情况下，你保持在增量搜索中，字符串用于启动缓冲区，所以你可以编辑它。我稍后会更多地谈论编写zle函数，但从用户定义的编辑函数调用搜索命令就像这样简单：

      zle history-search-backward search-string

你可以测试返回状态以查看搜索是否成功。

[]{#l92}

### 4.4.3: 从历史中提取单词

有时你不想编辑以前的行，而只是想从其中提取一个单词到当前行。如果单词是行上的最后一个，并且行在历史中不是很靠后，这特别容易：只需反复按`\e.`，shell将循环浏览前几行上的最后一个单词。你可以给它一个前缀参数来选择从你上次选择单词的行的上一行的第*N*个单词。从描述中你可以看出，这有点复杂；4.1版的shell可能会提供一个稍微更灵活的版本。

虽然严格来说这与历史无关，但你可以用`copy-prev-word`复制当前行上的前一个单词，由于某种原因它绑定到`\e^_`，转义后跟（可能）控制和斜杠。我将其重新绑定到`\e=`（在某些版本的ksh中，该键序列被等效于`list-choices`的函数占用）。这复制由空格分隔的单词，但你可以使用`copy-prev-shell-word`来复制shell会看到的前一个完整参数。这默认未绑定，因为它比另一个更新，但它可以说更有用。

有时你想从历史中完成一个单词；这可以通过下一章中描述的完成系统来实现。

[]{#l93}

## 4.5: 绑定键和处理键映射

在绑定键的标题下有两个主题要涵盖：首先，如何绑定键本身，其次，键映射以及如何使用它们。操作键绑定和键映射都是通过`bindkey`命令完成的。第一个主题更直接有用，所以我将从它开始。

[]{#l94}

### 4.5.1: 简单键绑定

你已经看到了`bindkey`的基本用法，将编辑命令链接到特定的按键序列。你已经看到了命名键的简写，其中`\e`是转义，`^x`是按住控制键时按下的字符`x`。我甚至说了关于"元"键绑定的一些话。

现在让我更详细地介绍一下。当你绑定一个键序列时，你用`bindkey` *key-sequence* *editor-command*，*key-sequence*可以由你喜欢的任意多个字符组成。甚至（在很大程度上）如果一些初始的键序列已经被绑定也不重要。例如，你可以做，

      bindkey '\eA' backward-word
      bindkey '\eAA' beginning-of-line

在这里，我将遵循shell文档，将`\eA`称为`\eAA`的前缀。

这引入了两点。首先，注意`\eA`的绑定与`\ea`不同；你会看到后者仍然执行`accept-and-hold`（在Emacs模式下），这意味着它执行当前行，然后将其返回给你编辑——对于做很多相当相似的任务很有用。同时，`\eA`带你回到一个单词。

这种大小写敏感性只适用于本身就是完整键的字母字符，不适用于按住控制键的字符——`^x`和`^X`是相同的。（你可能发现，在窗口系统下运行Emacs时，有办法分别绑定两者，因为窗口系统可以告诉Emacs是否按住shift键与其他键一起；如果你使用普通终端，情况就没那么简单了。）

如果你输入了这两个`bindkey`命令，你可能会注意到`\eA`生效前有一个短暂停顿。那是因为它在等待你是否输入另一个`A`。如果你在暂停期间输入额外的`A`，你会被带到行首而不是。那个暂停是shell决定是否单独执行前缀的方式。

它等待的时间是可配置的，由参数`$KEYTIMEOUT`给出，这是以百分之秒为单位的延迟。默认是40，即十分之四秒。它的使用通常取决于个人偏好；如果你打字不够快，你可能想要增加它，但代价是在等待前缀被执行时有更长的延迟。如果你在非常慢的链接上远程编辑机器，你也可能需要增加它，以便能够使具有这样前缀的完整键序列工作。

然而，只有当前缀本身被单独绑定时，shell才会有这种模棱两可的行为；如果初始键或键不单独意味着任何东西，它会一直等你输入一个完整的绑定序列。这远比正常情况多。单独绑定前缀的常见例子是在vi插入模式中，其中`<ESC>`带你回到命令模式，而可能有其他以`\e`开头的绑定，如光标键。我们将在下面看到如何删除它们，如果你觉得它们冒犯了你的vi纯洁感。（不要笑，vi用户很奇怪。）

注意，如果整个序列最终没有绑定，shell将在读取一个不再是前缀的完整键序列后立即中止。例如，如果你输入`\e[`，很可能shell在等待更多，但如果你添加`/`，它可能会决定你很愚蠢并中止。你输入的下一个键然后开始一个新的序列。

[]{#l95}

### 4.5.2: 删除键绑定

如果你想删除一个键绑定，你可以简单地将其绑定到其他东西。几乎所有的`bindkey`和`zle`命令的使用在这样的情况下都很聪明地移除死木。然而，你也可以使用`bindkey -r` *key-sequence*来显式删除绑定。你也可以简单地将序列绑定到命令`undefined-key`；这有完全相同的效果——甚至一直到修剪任何长序列的绑定。例如，假设你绑定`\e\C-x\C-x`到一个命令，然后绑定到`undefined-key`。所有关于`\e\C-x\C-x`曾经绑定的记忆都被移除；`\e\C-x`将不再被标记为前缀键，除非你有其他带有该前缀的绑定。

你可以通过添加`-p`选项删除所有以给定前缀开头的绑定。手册中给出的例子，

      bindkey -rpM viins '\e'

（除了它使用等效形式`^[`）是最有用的之一，因为它将删除你输入`\e`进入vi命令模式后的烦人延迟。延迟在那里是因为光标键通常也以`\e`开头，shell在等待你是否实际输入了其中一个。所以如果你可以在vi插入模式中不用光标键，你可能想要考虑这个。

注意，前缀本身的任何绑定都不会被删除。在这个例子中，`\e`保持绑定，因为它在`viins`键映射中，可能绑定到`vi-cmd-mode`。

所有这样的操作都特定于一个特定的键映射。你需要用不同的`-M` *...* 选项参数重复它们，以在其他键映射中产生相同的效果。

[]{#l96}

### 4.5.3: 功能键等等

[]{#fkeys}

通常可以绑定键盘上的功能键，包括特别命名的键如"Home"和"Page Up"。这在很大程度上取决于你的窗口系统或终端驱动程序如何处理它们，但如今在设置良好的系统上，几乎总是允许功能键向终端发送一串字符。要绑定键，你需要找出那个字符串是什么。

幸运的是，你通常会得到帮助，因为字符串的第一个字符是"有趣的"，即做了一些除插入字符以外的事情。所以有一个技巧可以找出序列是什么。在shell窗口中，按`^v`（如果你使用vi绑定，你需要在插入模式下），然后是相关功能键。你可能会看到像`^[OP`这样的字符串——这是我从F1键得到的。我的`.zshrc`中的一个注释表明我过去得到`\e[11~`，所以要做好准备，即使像我一样，你使用标准的xterm终端模拟器，也会有所不同。对这个Linux/GNU/XFree86系统上的终端模拟器进行快速调查表明，这两种可能性是最受欢迎的。

你甚至可能能够通过按住shift或control键（当然在按`^v`之后）得到不同的序列。在我的键盘上，结合F1和shift给我`^[O2P`，control给我`^[O5P`，两者都给我`^[O6P`。再次，你的系统可能会做完全不同的事情。

如果你将光标移回那个`^[`，你会发现它是一个字符——你可以将光标定位在`^`上，但不能定位在`[`上。这是zsh插入真正的、活的转义字符到行中的方式。实际上，如果你输入

      bindkey '

然后`^v`，功能键，和其他单引号，你有一个完美的方式在命令行上绑定键。Zsh通常对你的不可打印字符的使用相当放松；它们可能不会在你的终端上正确显示，但shell能够处理所有单字节字符。然而，它还不支持那些长于单字节的字符。

你也可以在你的`.zshrc`中做同样的事情；shell会处理输入中的奇怪字符而不会抱怨。你也可以使用两个字符`^[`，这只是输入转义键的另一种方式。然而，合乎规范的做法是将其转换为`\e`。例如，

      bindkey '\e[OP'  where-is           # F1
      bindkey '\e[O2P' universal-argument # shift F1

等等。使用这个，你可以给"Home"、"End"等赋予合理的含义。注意窗口系统避免前缀问题的明智方式——任何额外字符都在最终字符之前插入，所以shell可以很容易地判断序列何时完成，而无需等待看是否有更多跟随。

有一个与zsh一起提供的名为`zkbd`的实用程序，可以通过为你找出和记住定义来帮助所有这些。你可能只需通过自动加载它并运行它来使用它，因为它通常与其他函数一起安装。它应该是相当自解释的，否则请查阅`zshcontrib`手册。

如果你使用X Windows并且受过足够教育，你可以修改你的`.Xdefaults`文件来调整终端模拟器如何解释键。例如，以下将退格键变成xterm通常操作模式基础的"VT100小部件"中的删除键：

      *VT100.Translations: #override \ 
      <Key>BackSpace: string(0x7F)

显示这个的部分原因是，与zsh的键绑定系统相比，它使zsh的键绑定系统看起来非常流畅。然而，在这个级别上进行调整让你对键修饰符（shift、alt、meta、control，如果你幸运甚至可能还有super和hyper）的使用有非常大的控制权。这远超出了本指南的范围——我说这话，正如你现在可能意识到的，是为了掩盖我对它了解不多。不过，这里还有Oliver Kiddle的另一个例子；它使用control与左光标键发送转义序列：插入

      Ctrl<Key>Left: string(0x1b) string("[159q") \n\

到上面例子的中间——这显示了如何处理多个定义。现代xterm已经发送特殊的转义序列，你可以像我描述的那样调查和绑定。

[]{#l97}

### 4.5.4: 绑定字符串而不是命令

通过给`bindkey`选项`-s`，可以将任意字符串分配给键序列而不是编辑器命令。其中一个好处是字符串中的字符被zle重新解释，所以它们可以包含活动的键序列。在过去的日子里，这经常被用作宏的基本形式，将编辑器命令串在一起。例如，以下是通过重复Emacs模式绑定向后移动两个单词的简单方法。我再次使用我的F1绑定；你的可能完全不同。

      bindkey -s '\e[OP' '\eb\eb'

将键序列绑定到包含自身的另一个字符串是不明智的。

这种方法有一个明显的缺点，如果有人来重新绑定`\eb`，那么F1也会停止工作。如今，这类任务可以通过编写用户定义的小部件更灵活和清晰地完成，这将在后面的部分中描述。因此这种绑定正在逐渐过时。然而，它们确实提供了快速快捷方式。来自Oliver Kiddle的两个例子：

      bindkey -s '^[[072q' '^V^I'                       # Ctrl-Tab
      bindkey -s "\C-x\C-z" "\eqsuspend\n"

你也可以很容易地做一些你能用全局别名做的事情。

记住"普通"字符也可以重新绑定；它们只是碰巧有一个绑定，使它们直接插入。作为一个特别无意义的例子，考虑：

      bindkey -s secret 'Oh no!'

如果你足够快地输入`secret`，字母会被吞掉，取而代之的是`Oh no!`出现。如果你在中间任何地方暂停足够长的时间，单词就会像平常一样被插入。那是因为它的所有部分都可以被解释为它们自己的前缀，所以`$KEYTIMEOUT`适用于每一个中间阶段。不那么无意义的是，你可以用它来定义缩写。

[]{#l98}

### 4.5.5: 键映射

到目前为止，我所说的关于键映射的只是有三个标准的，一个用于Emacs模式，两个用于vi模式，以及`\bindkey -e`\和`\bindkey -v`\选择Emacs或vi插入模式绑定。没有简单的方法选择vi命令模式绑定，因为那通常不是直接可用的，而是通过`vi-cmd-mode`命令进入的，通常绑定到`\e`，在vi插入模式中。（有一个`\bindkey -a`\，但它不选择键映射供正常使用；它等同于，但不如`\bindkey -M vicmd`\清楚。）

大多数键映射的处理是通过`bindkey`完成的。键映射有短名称，`emacs`、`viins`和`vicmd`，用于与`bindkey`一起使用。还有一个键映射`.safe`，你通常不需要，但它永远不会改变，所以可以在你的实验完全搞砸了每一个其他键映射时使用。它只有`self-insert`（大多数键）和`accept-line`（`^j`和`^m`）的绑定，但这足以输入命令。

这些名称在两个地方最有用。首先，你可以使用`\bindkey -M` *键映射*\来定义特定映射中的键：

      bindkey -M vicmd "\e[OA" up-line-or-history

在`vicmd`模式中绑定常用的上光标键，无论当前设置了哪个键映射。实际上，任何理解`-M`选项的shell版本可能已经绑定了它。

其次，你可以强制zle使用特定的键映射。这是以一种稍微不明显的方式完成的：zle总是使用键映射`main`作为当前键映射（除了在vi命令模式下关闭时，这有点特别处理）。要使用你自己的，你需要用`\bindkey -A`\使`main`成为那个的别名。这个顺序与`ln`中的顺序相同：你想要引用的现有键映射先来，然后是你想要作为它的别名的东西，在这种情况下是`main`。这意味着

      bindkey -A emacs main

与

      bindkey -e

有相同的效果，但更明确，如果有点巴洛克式。不要将`vicmd`链接到main，因为那样你就不能使用`viins`，这是不好的。注意，`\bindkey -M emacs`\没有这个效果；它只是列出`emacs`键映射中的绑定。

你也可以创建自己的键映射。最简单的方法是复制现有的键映射，比如

      bindkey -N mymap emacs

这创建（或替换）`mymap`并用`emacs`的绑定初始化它。现在你可以像使用`emacs`一样使用`mymap`。每个绑定都是完全独立的。如果你完成了键映射，你可以用`\bindkey -D keymap`\删除它，尽管你最好先确保它没有链接到`main`。

你可以省略`emacs`来创建一个空的键映射；如果你的键映射只在某些特殊地方使用，并且你想要对进入其中的内容有完全控制，这可能是合适的。目前shell不太擅长让你只在某些地方应用你自己的键映射，然而。

你可能会遇到用于特殊情况的各种其他键映射。如果你列出所有键映射，这是通过`\bindkey -l`\完成的，你可能会看到`listscroll`和`menuselect`。这些由新的完成系统使用，所以如果它不活跃，你可能看不到它们。它们驻留在模块`zsh/complist`中。[第6章](zshguide06.html#comp)中将有关于它们效果的更多信息；`listscroll`允许你在超过终端窗口的完成列表中上下移动，而`menuselect`允许你从显示的列表中交互式地选择项目。你可以像任何其他键映射一样在其中绑定键。

[]{#l99}

## 4.6: 高级编辑

（在物理学中，"高级波"是一个假设的波，它在时间上向后移动。不幸的是，尽管它对满足截止日期很有用，但这不是我所说的"高级编辑"。）

这里有一些超越普通shell命令行编辑的东西。虽然到目前为止它们在shell中并不广泛，但我每天都使用它们，所以它们不仅仅适用于研究生级别的zsh学者。

[]{#l100}

### 4.6.1: 多行编辑

所有类似Bourne的shell都允许你编辑延续行；也就是说，如果shell能够确定你还没有完成输入，它会向你显示一个由`$PS2`给出的新提示符，并允许你从上一行停下的地方继续。在zsh中，你甚至可以看到shell在等待什么。例如，输入`array=`(`first`然后`return`。shell正在等待数组的最终括号，并向你打印`array>`，除非你改变了`$PS2`。你可以继续向数组添加元素，直到你关闭括号。

从csh派生的shell在延续行方面不太满意；历史上，这是因为它们试图一次性评估所有内容，如果无法做到这一点就会变得困惑。原始的csh没有特别复杂的解析器。这一次，zsh没有匹配csh行为的选项；你只需要习惯在zsh中事情是如何工作的想法。

zsh比其他shell改进的地方是，你不仅限于编辑单个延续行；你实际上可以在屏幕上编辑整个块，就像在全屏编辑器中一样——尽管你不能滚动到你正在编辑的块之外，这没有意义。

最简单的方法是在你输入换行符之前按escape。实际上，你可以在任何时候这样做，即使到目前为止的行是完整的。例如，

      % print This is line one<ESC><RET>
      print This is line two

其中行末的那些尖括号意味着你输入escape，然后按return。什么也没发生，也没有新的提示符；你只是继续输入。按return，这次不转义，两行都会被执行。注意这里没有隐含的反斜杠，或任何类似的东西；当zsh读取整个内容时，那个转义的回车变成了真正的回车，就像shell从脚本中读取它一样。

这是有效的，因为`\e\r`实际上绑定到命令`self-insert-unmeta`，意思是"插入你刚刚输入的字符，去掉转义或最高位"——换句话说，一个文字回车。你会得到完全相同的效果，通过输入`^v^j`，因为`^v`同样转义了`^j`（换行），就像它对任何其他字符一样。

（仅对终极好奇者：为什么这里换行而不是回车——"输入"键——如你所期望的？那是一个相当怪异的故事。事实证明，由于主要是历史原因，UNIX终端驱动程序喜欢交换换行和回车，所以当你输入回车（由该键和`^m`发送，这与`\r`表示的字符相同）时，它输出为换行（在大多数键盘上，只由`^j`发送，这与`\n`表示的字符相同）。正是换行字符是你在行末"看到"的那个字符（因为它就是行的末尾）。然而，`^v`看穿了这一点，如果你在它后面输入`^m`，它会插入一个文字`^m`，它看起来就像一个`^m`，因为这就是zsh输出它的方式。所以这就是为什么那不起作用。实际上，`self-insert-unmeta`也会看到`^m`，因为当你去掉`\e`时你会得到它，但它有一些额外的代码让UNIX用户感到宾至如归，并表现得像它是换行一样。通常，`^j`和`^m`以相同的方式处理（`accept-line`），但文字字符有不同的行为。如果你现在非常困惑，只要感谢我没有告诉你关于输出换行时发生的额外扭曲。）

它可能还不太有用，因为你所做的只是错过了一个新的提示符。让它变得有用的是，你现在可以在两行（或多行）之间使用光标键上下移动。我假设你没有重新绑定光标键，你的终端不是一个不支持光标上移的哑终端，并且选项`singlelinezle`没有生效——如果生效了，就取消它，你会在以后感激的。

所以例如，输入

      % if [[ true = false ]]; then<ESC><RET>
        print Fuzzy logic rules<ESC><RET>
      fi

其中我在第二行用空格缩进了，因为我在`if`里面通常这样做。这里没有延续提示符，只有原始的`$PS1`；这不是印刷错误。现在，在按return之前，向上移动两行，并将`false`编辑为`true`。你可以看到这有多有用。在命令行输入函数可能是更典型的例子。

假设你已经通过正常方式用`$PS2`经历了几个延续行？你不能在那时回滚，即使块还没有被编辑。有一个神奇的方法可以将所有那些延续行变成一个单一的块：编辑器命令`push-line-or-edit`。如果你不在延续行上，它就像正常的`push-line`命令一样行动，但为了当前目的，当你在延续行上时使用它。你被呈现了一个从（重绘的）提示符到结束的无缝文本块，你可以作为一个整体编辑。将`push-line-or-edit`绑定到`push-line`而不是`^q`或`\eq`（在Emacs模式中，我将假设，像往常一样）是相当合理的。但要小心`^q`——如果设置了选项`flowcontrol`，它很可能会被终端驱动程序吞掉而不会到达shell，这与我上面提到的`^s`有同样的问题。

[]{#l101}

### 4.6.2: 内置vared和函数zed

我在[第3章](zshguide03.html#syntax)中提到了`vared`命令；它使用正常的行编辑器编辑变量，通常是你不想完全输入的长变量如`$path`，尽管你需要记住*不要*在前面放`$`，否则shell会在运行`vared`之前替换它。然而，由于这只是像任何其他输入一样的文本片段，这也可以有多行，你以相同的方式输入——由于shell参数可以包含任何内容，你有一个相当通用的编辑器。shell函数`zed`随shell提供，允许你使用所有现在熟悉的命令编辑文件。由于编辑文件时你不期望回车把你踢出编辑器，只是插入新行，zed将回车重新绑定到`self-insert-unmeta`（这里的`-unmeta`只是为了获得将回车变成换行的交换行为）。要保存和退出，你可以输入`^j`，或者，如果你的终端对那个做了什么奇怪的事情，你也可以使用`^x^w`，这是设计成看起来像Emacs写文件的方式。

如果你查看`zed`，你会看到它有一些铃铛和口哨——例如，`zed -f`允许你编辑函数——但将文件读入参数、编辑参数并将参数写回文件的代码极其简单；所有困难的编辑代码已经在`vared`中处理了。实际上，`zed`本质上是一个完全通用的编辑器，尽管它在长文件上很快变得低效，特别是如果它们大于单个屏幕；正如你所期望的，zle被编写来有效地处理短文本块。

如果可以使用特殊的键映射只在vared中应用键绑定，那可能很好。有一天可能会发生这种情况。

顺便说一句，注意你可以用vared编辑数组，它会合理地处理不同元素。通常，空格分隔元素；当它向你呈现包含空格的元素的数组时，vared会在前面加上反斜杠以显示它不是分隔符。你可以自己用反斜杠插入带引号的空格。只有空格字符需要这种引用，只有反斜杠有效。

例如，

      array=('one word' 'two or more words')
      vared array

向你呈现`one\ word two\ or\ more\ words`。如果你添加` and\ some\ more.`，按return，然后输入`print -l $array`以每行显示一个元素，你会看到

      one word
      two or more words
      and some more.

一些旧版本的shell在元素内的空格方面不太小心。

[]{#l102}

### 4.6.3: 缓冲区堆栈

现在将解释`push-line-or-edit`的神秘其他用途。让我们坚持使用`push-line`，实际上，因为我已经处理了`-or-edit`部分。

输入

      print I was just in the directory

（没有换行）。哦，亲爱的，你刚才在哪个目录？你不想打断文本流来找出来。按`\eq`；你一直在输入的行消失了——但不用担心，它没有消失。现在输入

      dirs

两件事发生：当然，那最后一行被执行，显示目录堆栈上的目录列表（你使用`pushd`和`popd`），但你之前去掉的行也重新出现了，所以你可以继续编辑它。

你可能不会立即意识到这有多有用，但我在写上一段时用了好几次。例如，我在zle源代码和我保存本指南的目录之间交替目录，我开始输入`grep`命令之前意识到我在错误的目录中。我需要做的就是输入`\eq`，然后`pushd`，把我放到我想要的地方，然后完成`grep`。

"缓冲区堆栈"，这是这种机制的行话，可以深入到你喜欢的程度。它是一个后进先出（LIFO）堆栈，所以最近输入的`\eq`推入的行将首先重新出现，然后是按相反顺序的旧数字。你甚至可以从函数中显式地填充缓冲区堆栈——不一定是zle函数，尽管那也有效——用`print -z` *command-line*。

如果你愿意，你可以显式地从堆栈中拉出一些东西，通过输入`\eg`，但这与清除当前行并按return有相同的效果。当然，你可以多次推送相同的行：如果你需要在执行之前做一整系列的事情，只需在行弹回时再次按`\eq`。

我撒了一点小谎，为了避免混淆。关于多行缓冲区的`push-line-or-edit`的聪明之处也扩展到这种情况。如果你在多行缓冲区上做正常的`push-line`，只有当前单行被推送；推送整个堆的命令是`push-input`。但如果你绑定了`push-line-or-edit`，你可以忘记区别，因为它会为你做这件事。如果你一直在注意，你可以计算出以下序列（假设`\eq`已重新绑定到`push-line-or-edit`）：

      % if [[ no = yes ]]; then
      then> print<ESC>q<ESC>q

第一个`\eq`将两行变成一个单一的缓冲区，然后第二个将整个堆推入缓冲区堆栈。这节省了很多思考绑定的麻烦。因此我建议Emacs模式用户在他们的`.zshrc`中添加

      bindkey '\eq' push-line-or-edit

并忘记区别。

[]{#l103}

## 4.7: 扩展zle

我们现在来到zle的最新和最灵活的部分，使用shell函数创建任意复杂的编辑命令的能力。这是由Andrew Main（"Zefram"）在zsh 3.1中引入的，所以在所有zsh 4版本中都是标准的，尽管工作仍在继续。

[]{#l104}

### 4.7.1: 小部件

如果你不是以英语为母语，首先，恭喜你已经走到这一步。其次，你可能只将"widget"视为应用于实现某些计算想法的对象的技术术语，比如在窗口系统中实现文本编辑的东西，例如。然而，对大多数英语使用者来说，"widget"是一个幽默的词，用来指代一个对象，有点像"whatyoumacallit"或"thingummybob"，比如"那个能一键打开箔纸并取出软木塞的聪明小玩意"。zsh的使用在我看来总是更接近于第二个非技术版本，但我可能因为我所知道的由Zefram引入的内部对象叫做"thingy"而有偏见，我不会再提到它，因为你不需要知道。

无论如何，"widget"本质上是我到目前为止称之为编辑器命令的东西，你可以将其绑定到键序列的东西。使用更精确的术语的原因是，一旦你有了shell函数飞来飞去，"命令"这个词就变得毫无希望地不具体，因为函数充满了命令，这些命令可能是也可能不是widget。所以我对使用这个词不道歉。

所以现在我们引入第二种widget：一种不是由内置到shell中的代码处理，而是由用户编写的函数处理的widget。它们是完全等价的；bindkey和公司不在乎它是哪一种。创建widget你需要做的就是

      zle -N widget-name function-name

然后*widget-name*可以在`bindkey`或`execute-named-cmd`中使用，函数*function-name*将被执行。如果`widget-name`和`function-name`相同，这通常是最简单的事情，你只需要其中一个。

你可以通过使用`zle -l`列出现有的widget，尽管通常`zle -lL`是更好的选择，因为输出格式与你用来定义widget的形式相同。如果你看到很多`zle -C` widget，暂时忽略它们；它们是完成widget，以不同的方式处理，并在[第6章](zshguide06.html#comp)中描述。

现在你需要知道函数中应该放什么。

[]{#l105}

### 4.7.2: 执行其他widget

在实现widget的函数内部你可以做的最简单的事情是调用现有的函数。所以，

      my-widget() {
        zle backward-word
      }
      zle -N my-widget

创建一个叫做`my-widget`的widget，它在每个方面（除了速度）都像内置widget `backward-word`一样表现。你甚至可以给它一个前缀参数，这个参数会被传递下去；`\e3`然后无论你将widget绑定到什么（或`\exmy-widget`）将向后移动三个单词。

假设你想传递你自己的前缀参数给`backward-word`，而不是用户输入的？或者假设你想考虑前缀参数，但对它做一些不同的事情？两者都是可能的。

让我们取第一个。你可以为这个命令单独提供一个前缀参数，通过在widget名称后放置`-n` *参数*（注意这不是大多数选项放置的地方）。

      my-widget() {
        zle backward-word -n 2
      }

这总是向后移动两个单词，覆盖用户给出的任何数字参数。（顺便说一句，你可以重新定义函数而不告诉zle，通过重新定义函数；zle只是调用在widget运行时定义的任何函数。）如果你在名称后只放置`-N`，它将取消用户给出的任何前缀，而不引入新的前缀。

前缀处理的另一部分——拦截用户指定的前缀并可能修改它——引入了用户定义widget最重要的部分之一。Zle提供各种参数，可以读取并且经常写入以改变编辑器的行为，甚至正在编辑的文本。在这种情况下，参数是`$PREFIX`。例如，

      my-widget() {
        zle backward-word -n $(( ${NUMERIC:-1} * 2 ))
      }

这使用算术替换为`backward-word`提供一个参数，它是用户给出的两倍。注意`${NUMERIC:-1}`符号，这很重要：大多数时候，你根本不会给命令一个数字参数，在这种情况下，zle自然地将`$NUMERIC`视为未设置。这会搞砸算术替换。

顺便说一句，如果你在shell函数中犯了错误，你看不到它；除非你用`setopt nobeep`关闭了它，否则你会只听到哔哔声。这样的函数的输出被丢弃，因为它会搞乱显示。所以你应该在将函数变成widget之前做任何基本调试，例如，在前面粘贴一个`print`并直接运行它——你不能从编辑器外部执行widget。

以下也有效：

      my-widget() {
        (( NUMERIC = ${NUMERIC:-1} * 2 ))
        zle backward-word
      }

因为你可以直接改变`$NUMERIC`，除非被`-n`参数覆盖，否则它被函数中调用的任何widget使用。如果你在函数中调用了更多widget——你可以调用任意数量——同样的参数将适用于所有没有显式`-n`或`-N`的widget。

一些widget允许你指定非数字参数。目前这些主要是搜索函数，你可以给它们一个显式的搜索字符串。然而，通常你希望每次指定一个新的搜索字符串。我能看到的最有用的使用这个的方法是为增量搜索命令提供一个初始参数。稍后，我将向你展示如何以类似于Emacs模式的`^r`绑定`history-incremental-search-backwards`的方式读入字符。

[]{#l106}

### 4.7.3: 一些特殊的内置widget及其用途

你可能想在zle函数中对编辑器做一些事情，如果直接从zle执行这些事情就不会有用。一个是像普通widget一样导致错误。你可以用`zle beep`做到这一点。然而，这不会自动在那一点停止你的函数；由你来从它返回。

可以通过`zle -N`声明来重新定义内置widget，只需声明它并定义相应的函数。从现在开始，所有引用该widget的现有绑定将导致运行你的widget而不是内置的。这是因为zle在运行时实际上不关心widget做什么。你可以通过使用`bindkey`定义一个键序列来调用一个未定义的widget，如`any-old-string`来看到这一点。直到你实际按下键序列，shell才抱怨。

然而，有时你想要确保调用内置widget，即使行为已被重新定义。你可以通过在widget名称前放置`.`来做到这一点；`zle .up-line-or-history`总是调用通常称为`up-line-or-history`的内置widget，即使后者已被重新定义。一个用途是重新绑定`accept-line`以在zle即将将行传递给shell时做某事，但仍接受该行：你编写自己的widget `accept-line`，确保它在完成前调用`zle .accept-line`，然后使用`zle -N accept-line`。这里有一个微不足道但并非完全愚蠢的例子：

      accept-line() {
        print -n "\e]2;Executing $BUFFER\a"
        zle .accept-line
      }
      zle -N accept-line

现在每次你按下return执行命令时，该`print`命令将首先执行。如所写，它将`Executing`和命令行的内容（见下文）放入xterm窗口的标题中，假设它理解通常的xterm转义序列。实际上，这个特定的例子通常由特殊shell函数（不是zle函数）`preexec`处理，它被传递一个即将执行的命令行作为参数而不是在`$BUFFER`中。重新绑定`accept-line`似乎有一个副作用，即在某些情况下，return键在迷你缓冲区中停止工作。

请注意，要撤销return执行你的新widget的事实，你需要将`accept-line`别名为`.accept-line`：

      zle -A .accept-line accept-line

如果你难以记住顺序，就像zsh和UNIX中大多数别名或重命名命令一样，包括`ln`和`bindkey -A`，现有的命令，你想要保留其属性的那个，先来，而它的新名称后到。同样，就像这些命令一样，如果行上的第二个名称当前意味着其他东西也没关系；那将被新含义替换。之后，你不需要担心你自己的`accept-line` widget；zle处理删除不再被引用的widget的细节。然而，函数仍然存在，因为就shell的其余部分而言，它只是一个普通的shell函数，你需要`unfunction`来删除它。

但是，请记住，不要通过明显的命令删除重新定义内部widget的基本widget

      # 不要这样做！
      zle -D accept-line

这会使return键除了抱怨没有这样的widget之外没有任何效果。如果你陷入真正的麻烦，`\ex.accept-line`应该有效，因为你可以使用`.`-widgets在任何可以使用任何其他widget的地方使用它们，除了它们会重新定义或删除`.` widget。使用上面的`\zle -A`命令和`.`-widgets的扩展命令形式`.accept-line`恢复正常。如果你尝试重新定义或删除`.` widget，zle会告诉你它是受保护的。然而，你可以以这种方式删除任何其他widget，即使它仍然绑定到键序列；如果你输入该序列，你会看到一个错误。

关于`accept-line`需要注意的一点是，行不会立即传递给zsh，只有当你的函数退出时才会。这在你思考时是相当明显的；zle是从主shell调用的，如果你自己的zle widget还没有完成执行，主shell还没有得到控制权。但这确实意味着，例如，如果你在调用`accept-line`或`.accept-line`后修改命令行，这些更改会反映在传递给shell的行中：

      # 也不要这样做！
      accept-line() {
        zle .accept-line
        BUFFER='Ha ha!'
      }

这总是向主shell返回字符串`Ha ha!`。除非你正在构建一个萨缪尔·贝克特shell以在巴黎艺术画廊展示，否则这并不是特别有用。

[]{#l107}

### 4.7.4: 特殊参数：普通文本

shell使各种参数可用于轻松操作命令行。你已经看到了`$NUMERIC`。你可能想知道如果你有自己的名为`$NUMERIC`的参数会发生什么；毕竟，它是一个相当简单的名称。好消息是你不需要担心；当shell运行zle函数时，它只是隐藏任何现有的参数出现，并使其特殊参数可用。然后当它退出时，原始参数被重新启用。所以你只需要担心在zle widget内部时不要使用这些特殊参数做其他事情。

有四个特别常见的zle参数。

首先，有三种引用命令行上文本的方式：`$BUFFER`是作为字符串的整行，`$LBUFFER`是光标位置左侧的行，`$RBUFFER`是光标右侧的行，包括光标下的字符，因此分割总是在下一个插入字符将要放置的地方。任何或所有这些都可能是空的，`$BUFFER`总是`$LBUFFER$RBUFFER`字符串。

与这些相对应的是`$CURSOR`，它是光标位置，1是第一个字符。如果你知道shell如何处理参数替换中的子字符串，你将能够看到`$LBUFFER`是`$BUFFER[1,$CURSOR-1]`，而`$RBUFFER`是`$BUFFER[$CURSOR,-1]`（除非你使用`KSH_ARRAYS`选项来兼容ksh的索引——这不建议用于实现zle或完成widget，因为它会导致与shell一起提供的widget混淆）。

这些真正有用的是它们是可修改的。如果你修改`$LBUFFER`或`$RBUFFER`，那么`$BUFFER`和`$CURSOR`将被适当地修改；延长或缩短`$LBUFFER`会增加或减少`$CURSOR`。如果你修改`$BUFFER`，你可能需要自己设置`$CURSOR`，因为shell不能确定光标应该在哪里。如果你改变`$CURSOR`，字符将在`$LBUFFER`和`$RBUFFER`之间移动，但`$BUFFER`将保持不变。

这使得基本移动和删除命令等任务变得极其简单，通常只是模式匹配的问题。然而，绝对值得了解zsh更复杂的模式匹配和参数替换功能，这些将在下一章中描述。例如，如果你以

      emulate -L zsh
      setopt extendedglob
      LBUFFER=${LBUFFER%%[^[:blank:]]##}

开始一个widget函数，那么`$LBUFFER`包含光标左侧的行，去掉了光标右侧的所有非空白字符（通常是除空格或制表符以外的任何字符）。

这个函数使用参数替换功能`${`*param*`%%`*pattern*`}`，它从`$`*param*的末尾删除*pattern*的最长匹配。`emulate -L zsh`确保shell选项为函数适当设置，并使所有选项设置本地化，`setopt extendedglob`打开扩展模式匹配功能；正是这使得模式中出现的序列`##`意味着"前一个模式元素的至少一次重复"。前一个模式元素是"任何非空白字符"。因此，所有非空白字符的出现都从`$LBUFFER`的末尾删除。

如果你想将光标移到这些字符上，你可以稍微调整函数：

      emulate -L zsh
      setopt extendedglob
      chars=${(M)LBUFFER%%[^[:blank:]]##}
      (( CURSOR -= ${#chars} ))

参数替换的开头出现了`(M)`字符串。这是zsh独特的参数标志系统的一部分；这意味着"插入替换的匹配部分"。换句话说，不是返回`$LBUFFER`去掉了末尾的非空白字符，替换返回那些它本来会剥离的非常字符。跳过它们现在是一个简单的问题，即将`$CURSOR`减少该字符串的长度。

你会发现如果你尝试这些例子，它们可能不会完全如你所愿。特别是，它们不会处理正常面向单词的函数处理的任何空白字符。然而，你现在有足够的信息自己添加测试。

如果你变得更复杂，那么你可以添加对`$NUMERIC`的处理。记住，除非用户明确给出，否则它不会设置，所以由你来在那种情况下将其视为1。

[]{#l108}

### 4.7.5: 其他特殊参数

你可能想要做的事情的很大一部分可以用我们已经遇到的参数来完成。以下是一些关于如何使用一些其他可用参数的提示。一如既往，要获得更少提示的完整列表，请参阅手册。

`$KEYS`告诉你用于调用widget的键；它是一个原始字符的字符串，而不是`bindkey`格式。换句话说，如果它是一个单键（可能包括控制键或元键），`$KEYS`将只包含一个字符。所以你可以改变widget对不同键的行为。这里是一个非常（非常）简单的像`self-insert`的函数：

      LBUFFER=$LBUFFER$KEYS

注意这在`\ex`扩展命令处理方面不太有效；你只会得到行末的`^m`。你需要确保任何使用`$KEYS`的widget都被合理地绑定。这也不处理数字参数来重复字符；这是一个相当简单的练习（特别是考虑到zsh的`repeat`循环）来添加它。

`$WIDGET`和`$LASTWIDGET`告诉你当前正在执行的widget的名称和之前的widget。这些在第一次听时似乎不太有用。然而，你可以将`$WIDGET`与这样一个事实一起使用：widget不需要与其定义函数具有相同的名称。你可以定义

      zle -N this-widget function
      zle -N that-widget function

并在`function`内部测试`$WIDGET`以查看它是否包含`this-widget`或`that-widget`。如果这些有很多共享代码，这将是一个相当大的简化，而无需编写额外的函数。

`$LASTWIDGET`倾向于用于稍微不同的目的：检查上一个执行的命令是否与当前命令相同，或者可能只是与它友好。以下是编辑的`up-line-or-beginning-search`函数的亮点，这是为`4.1`添加到shell分发中的函数的一种`up-line-or-search`和`history-beginning-search-backward`的交叉。如果缓冲区中有前一行，它会在它们之间移动；否则如果这是调用此函数的序列中的第一个，它会记住光标位置并向后查找具有相同文本的行，从开始到该点，并将光标放在行的末尾；否则如果刚刚执行了相同的widget，它使用旧的光标位置在历史中搜索另一个匹配项。

      if [[ $LBUFFER == *$'\n'* ]]; then
        zle .up-line-or-history
        __searching=''
      else
        if [[ $LASTWIDGET = $__searching ]]; then
          CURSOR=$__savecursor
        else
          __savecursor=$CURSOR
        fi
        __searching=$WIDGET
        zle .history-beginning-search-backward
        zle .end-of-line
      fi

我们测试`$__searching`而不是直接测试`$WIDGET`来能够判断我们何时在移动行而不是搜索。`$__savecursor`给出了向后搜索的位置，之后我们将光标放在行的末尾。以`__`开头的参数不是函数的局部变量，因为我们需要从上一次执行中测试它们，所以它们前面有下划线以试图将它们与其他可能存在的参数区分开来。

你会看到分发中提供的函数的实际版本比这更复杂一些；一方面，它使用用户设置的样式来决定其行为。样式在[第6章](zshguide06.html#comp)中描述用于完成widget，但你可以以完全相同的方式在zle函数中使用它们。

`up-line-or-beginning-search`的完整版本使用了另一个参数`$PREBUFFER`。这包含任何已经被`zle`吸收但你不能再编辑的文本——换句话说，在shell用`$PS2`提示剩余部分之前读取的文本。测试`[[ -n $PREBUFFER ]]`因此有效地测试你是否在`$PS2`。你可以使用它来实现类似`push-line-or-edit`的行为。

[]{#l109}

### 4.7.6: 读取键和使用迷你缓冲区

现在和然后你想让编辑器在中间有用户输入的情况下执行一系列操作。这通常由两个命令的组合完成。

首先，你可能需要在迷你缓冲区中提示用户，就像`\ex`一样。你可以用`zle -R`做到这一点。它的基本功能是重新显示命令行，刷新到目前为止你在函数中所做的所有更改，但你可以给它一个字符串参数，该参数出现在迷你缓冲区中，就在命令行下方。你可以在此之后给它一个其他字符串的列表，这些字符串以类似于可能完成列表的方式出现，但在这种情况下对zle没有特殊意义。

要从用户那里获取输入，你可以使用`read -k`，它读取单个键（不是序列；不进行查找）。此命令在shell中始终可用，但在这种情况下，它由zle本身处理。键作为原始字节返回。算术求值的两个功能对于处理这个键很有用：`#key`返回`$key`第一个字符的ASCII码，而`##`*key*返回*key*的ASCII码，这是`bindkey`能理解的形式。例如，

      read -k key
      if (( #key == ##\C-g )); then
         ...

进行算术求值的使用。左边的形式将`$key`中的第一个字符转换为数字，右边的形式将文字bindkey风格的字符串`\C-g`转换为数字（ASCII 7，因为1到26只是`\C-a`到`\C-z`）。不要将这些形式中的任何一种与`$#key`混淆，后者是参数中字符串的长度，在这种情况下几乎肯定是1个单字节；这种形式在算术替换内部和外部都有效，其他形式只在内部有效。推荐使用`(( ... ))`形式进行算术替换，只要可能；你可以用基本的`[[ ... ]]`形式来做，因为`-eq`和类似的测试将两边视为算术，尽管你可能需要额外的引用；然而，我所知道的唯一好的理由是避免在同一复杂测试中使用两种类型的条件语法。

这些技巧只有在相当复杂的函数中才真正有用。例如，看看zsh源分发中提供的函数`incremental-complete-word`。如果使用`\#\\C-g`而不是`##\C-g`的形式，这个函数不会增加清晰度；它做同样的事情，但双反斜杠非常令人困惑，这就是为什么引入了另一种形式。

[]{#l110}

### 4.7.7: 示例

**transpose-words-about-point**\

这个函数是`transpose-words`的一个变体。它有各种各样的扭曲。首先，所涉及的单词总是空格分隔的，既不是shell单词也不是`$WORDCHARS`意义上的单词。这使它变得相当可预测。

其次，即使光标下的字符不是空白字符，它也会在当前点（因此得名）转置单词。我发现这很有用，因为我总是输入像`function_name`这样的复合词，然后发现我应该输入的是`name_function`。现在我只需将光标定位在下划线上并执行这个widget。

      emulate -L zsh
      setopt extendedglob

      local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

      pat1=${LBUFFER%%(#b)([^[:blank:]]##)([[:blank:]]#)}
      word1=$match[1]
      ws1=$match[2]

      match=()
      pat2=${RBUFFER##(#b)(?[[:blank:]]#)([^[:blank:]]##)}
      ws2=$match[1]
      word2=$match[2]

      if [[ -n $word1 && -n $word2 ]]; then
        LBUFFER="$pat1$word2$ws1"
        RBUFFER="$ws2$word1$pat2"
      else
        zle beep
      fi

这里的唯一聪明之处是模式匹配。它大量使用了扩展globbing功能的"反向引用"，这在所有形式的模式匹配中使用，包括在这种情况下，参数替换。这将在下一章中完全描述。要寻找的关键是`(#b)`，它激活反向引用如果选项`EXTENDED_GLOB`被打开，跟随它的括号标记出你想要引用的部分，以及对`$match`数组元素的引用，这些元素存储这些部分。shell还设置`$mbegin`和`$mend`来给出这些匹配的开始和结束位置，这就是为什么这些参数被设为局部变量；我们希望从函数外部看不到它们，即使我们实际上没有使用它们。

你可能还需要知道`#`字符：一个模式后的`#`意味着"零次或多次重复"，两个意味着"一次或多次重复"。最后，字符类中的`[:blank:]`指的是任何空白字符；当被否定时，如在字符类`[^[:blank:]]`中，它意味着任何非空白字符。有了`#`，我们匹配一系列空白或非空白字符。鉴于这一点，你可以算出其余部分。

这里有一个更复杂的版本。如果你觉得前一个版本很难理解，你可能不想太仔细地看这个。

      emulate -L zsh
      setopt extendedglob

      local wordstyle blankpat wordpat1 wordpat2
      local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

      zstyle -s ':zle:transpose-words-about-point' word-style wordstyle

      case $wordstyle in
        (shell) local bufwords
                # 这将行分割成shell理解的单词。
                bufwords=(${(z)LBUFFER})
                wordpat1="${(q)bufwords[-1]}"
                # 取RBUFFER的子字符串跳过第一个字符，
                # 这是光标下的字符。
                bufwords=(${(z)RBUFFER[2,-1]})
                wordpat2="${(q)bufwords[1]}"
                blankpat='[[:blank:]]#'
                ;;
        (space) blankpat='[[:blank:]]#'
                wordpat1='[^[:blank:]]##'
                wordpat2=$wordpat1
                ;;
        (*) local wc=$WORDCHARS
            if [[ $wc = (#b)(?*)-(*) ]]; then
              # 我们需要将任何`-`带到前面以避免混淆
              # 字符类...我们用`]`逃脱，因为在zsh中
              # 如果被引用，这不是模式字符。
              wc=-$match[1]$match[2]
            fi
            # 空白是任何不在由字母数字和$wc中的字符组成的字符类中的东西。
            # 引用$wc中必要的地方，因为我们不希望这些
            # 字符稍后被视为模式字符。
            blankpat="[^${(q)wc}a-zA-Z0-9]#"
            # 而单词字符是任何其他东西。
            wordpat1="[${(q)wc}a-zA-Z0-9]##"
            wordpat2=$wordpat1
            ;;
      esac

      # eval使参数中的特殊字符活跃起来。
      # 特别是，我们需要周围的`['成为"真实的"。
      # 这就是为什么我们在`shell`选项中引用了wordpats，在
      # 这一点上它们必须被视为文字字符串。
      eval pat1='${LBUFFER%%(#b)('${wordpat1}')('${blankpat}')}'
      word1=$match[1]
      ws1=$match[2]

      match=()
      eval pat2='${RBUFFER##(#b)(?'${blankpat}')('${wordpat2}')}'
      ws2=$match[1]
      word2=$match[2]

      if [[ -n $word1 && -n $word2 ]]; then
        LBUFFER="$pat1$word2$ws1"
        RBUFFER="$ws2$word1$pat2"
      else
        zle beep
      fi

添加的是使用样式来定义shell如何找到"单词"的能力。默认情况下，单词与shell通常认为的单词相同；这是由case语句的分支处理的，该分支使用`$WORDCHARS`和一些额外的技巧来获得匹配被认为是单词部分的字符集的模式。我们使用了`eval`，因为它允许我们在参数的某些部分使特殊字符活跃，而在其他部分引用。

这引入了两种类型的参数扩展标志：
`${(q)`*param*`}`添加反斜杠以引用`$`*param*中的特殊字符，这样当参数在`eval`后出现时，结果就是原始字符串。`${(z)`*param*`}`将参数分割，就像它是一个shell命令行被分割成命令和单词一样，所以结果是一个数组；`z`代表zsh分割或随你喜好叫zplitting。

如果你设置

      zstyle ':zle:*' word-style space

你会回到原始函数的行为。

最后，如果你在那个`zstyle`命令中将`space`替换为`shell`，你将得到单词，因为它们在shell内的正常使用中被分割；例如尝试

      echo execute the widget 'between these' 'two quoted expressions'

整个引用的表达式将被转置。你可能会发现，如果你在引用表达式中间这样做，你不会得到合理的结果；那是因为`(z)`-splitting不知道如何处理它左右的不完整引号。某些版本的shell有一个错误（在4.0.5中已修复），即无法正确分割的表达式，因为引号不完整，在末尾有额外的空格字符。

**insert-numeric**\

这里有一个widget，它允许你插入一个ASCII字符，你