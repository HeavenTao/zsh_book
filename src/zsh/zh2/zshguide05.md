------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide04.html)
-   [下一章](zshguide06.html)

------------------------------------------------------------------------

[]{#subst}[]{#l111}

# 第5章：替换

本章将特别吸引那些对以下事实感到兴奋的人：

      print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}

打印出数组`$array`的最长元素。然而，对于构成人口绝大多数的其余部分来说，在我们到达那个阶段之前，应该有很多有用的东西。无论如何，应该立即显而易见为什么没有混淆zsh代码竞赛。

对于那些不写很多函数而大部分时间在shell提示符下的人来说，本章最有用的部分可能是章节末尾关于文件名生成（即globbing）的部分。这将教你如何避免在想要为命令选择文件时浪费时间使用`find`等工具。

[]{#l112}

## 5.1: 引用

我在本指南中一直使用某种引号，但我从未深入细节。是时候谈谈了，因为使用引号是控制shell各种替换效果的重要部分。以下是基本的引用类型。

[]{#l113}

### 5.1.1: 反斜杠

关于反斜杠的主要一点是它们真的很琐碎。你可以用反斜杠引用任何字符，即使它在未引用时没有任何意义；所以如果最坏的情况发生，你可以拿任何旧字符串，无论它包含什么——随机的引号集合、反斜杠、不可打印字符——用反斜杠引用每个字符，shell会将其视为普通字符串：

      print \T\h\i\s\ \i\s\ \*\p\o\i\n\t\l\e\s\s\*\ \ 
          \-\ \b\u\t\ \v\a\l\i\d\!

记住，这也意味着你需要额外一层引用来将`\n`等传递给`print`。

然而，zsh有一种更简单的方法来确保在需要时所有内容都用反斜杠引用。这是一种特殊的参数替换形式，只是你可以通过在括号中提供标志来做的许多技巧之一：

      % read string
      This is a *string* with various `special' characters
      % print -r -- ${(q)string}
      This\ is\ a\ \*string\*\ with\ various\ \`special\'\ characters

`read`内置命令没有对你输入的内容做任何处理，所以`$string`只包含这些字符。`print`的`-r`标志告诉它以原始方式打印后面的内容，这里是特殊部分：`${(q)string}`告诉shell输出参数，在需要的地方加上反斜杠以防止特殊字符被解释。所有参数标志都是zsh特有的；没有其他shell有它们。

这个标志在那里不是很有用，因为zsh通常（记住`GLOB_SUBST`选项？）不会对替换中的字符做任何特殊处理。它*非常*有用的地方是如果你要重新评估替换中的文本但仍然希望它被视为普通字符串。所以在上面之后，

      % eval print -r -- ${(q)string}
      This is a *string* with various `special' characters

你得到了你开始时的内容，因为在命令行的`eval`中，`(q)`标志放入的反斜杠意味着该值被视为普通字符串。

你也可以去除参数中的引号；`(Q)`标志可以做到这一点。它不关心使用的是反斜杠还是单引号或双引号，它以shell解析器的方式处理它们。你只有在参数以某种方式在其值中获得引号时才需要这个。发生这种情况的一种方式是如果你试图读取包含shell命令的文件，为此还有另一个技巧：`(z)`标志以与行被读入并且比如说被分配给数组时相同的方式将行分割成数组。这里有一个例子：

      % cat file
      print 'a quoted string' and\ another\ argument
      % read -r line <file
      % for word in ${(z)line}; do
      for> print -r "quoted:    $word"
      for> print -r "unquoted:  ${(Q)word}"
      for> done
      quoted:    print
      unquoted:  print
      quoted:    'a quoted string'
      unquoted:  a quoted string
      quoted:    and\ another\ argument
      unquoted:  and another argument

你会注意到`(z)`不会从读入的单词中删除任何引号，但`(Q)`标志会。注意`read`和`print`的`-r`标志：第一个防止反斜杠被`read`吸收，第二个防止它们被`print`吸收。恐怕反斜杠可能有点麻烦。

[]{#l114}

### 5.1.2: 单引号

你不能用单引号引用的唯一东西是另一个单引号。然而，有一个选项`RC_QUOTES`，其中单引号字符串内的两个单引号变成一个。显然`RC`指的是在plan9中出现的shell `rc`；这似乎是那些一些人会狂热地为之激动而我们其他人无法完全理解为什么的程序之一。Zsh用户可能会同情。（这被Oliver Kiddle和Bart Schaefer纠正了，我错误地猜测`RC`代表递归，尽管你无论如何都可以这样认为。对于`RC_EXPAND_PARAM`来说，这并不真正适用，因为它确实来自`rc` shell，如果你查看源代码，你会发现一个叫做`plan9`的变量，它被测试以查看该选项是否生效。）

你可能还记得BASIC中的类似情况，尽管在那种情况下是双引号——在zsh中，它只适用于单引号，原因不明。所以，

      print -r 'A ''quoted'' string'

通常会给你输出`A quoted string`，但设置了该选项后它会打印`A 'quoted' string`。`print`的`-r`选项在这里不做任何事情，我只是为了表明我没有隐藏任何东西。这通常是一个有用且无害的选项，因为引号内有两个引号在一起没有其他好的理由。

引用单引号的标准方法是结束引号，插入一个带反斜杠的单引号，然后重新开始引号：

      print -r 'A '\''quoted'\'' string'

这不受选项设置的影响，因为反斜杠后的引号总是被视为普通可打印字符。你*永远*不能做的是使用反斜杠作为在单引号内引用字符的方式；它们只是被视为普通字符。

你可以通过使`q`在引号标志中出现总共四次的相当荒谬的方式强制参数用单引号而不是反斜杠引用。我想不出你为什么要这样做，除了这样会将换行符变成`\n`，因此结果将适合在单行（可能相当长）上。加上你会得到用转义序列替换有趣字符。

[]{#l115}

### 5.1.3: POSIX引号

有一种单引号的相对形式，它使用语法`$'`来引入一个引用字符串，用`'`来结束它；我称它们为`POSIX引号`，因为它们出现在POSIX标准中，我不知道还有什么别的叫法；`字符串引号`是一种可能性，但听起来有点模糊（你还引用什么别的？）与单引号的区别在于它们理解与print内置命令相同的反斜杠序列。因此你可以方便地使用`\n`表示换行，`\e`表示转义，`\xFF`表示十六进制的任意字符，等等，用于任何命令：

      % cat <<<$'Line\tone\nLine\ttwo'
      Line    one
      Line    two

记住`here string`符号`<<<`，它为命令提供标准输入。因此输出准确地显示了引用字符串是如何被解释的。这与

      % print 'Line\tone\n\Line\ttwo'
      Line    one
      Line    two

相同，但在后一种情况下，解释是在`print`内部完成的，这并不总是方便。POSIX引号目前使用得相当少。

这是一个提到shell完全`八位清洁`的好地方，这意味着你可以在字符串中的任何地方使用256个可能字符中的任何一个。例如，`$'foo\000bar'`中嵌入了一个ASCII NUL（这不是误印——官方上，ASCII非打印字符有两到三个字母的缩写）。通常这会终止一个字符串，但shell在内部使用它时会解决这个问题；然而，当你试图将其作为参数传递给外部程序时，所有赌注都无效。几乎可以肯定，在这种情况下，第一个NUL会导致程序认为字符串已经结束，因为没有关于参数长度的信息被传递下去，shell对此无能为力。因此，例如：

      % echo $'foo\000bar'
      foobar
      % /bin/echo $'foo\000bar'
      foo

shell的`echo`知道shell的8位约定，并打印出NUL，终端不显示它，然后是字符串的其余部分。外部版本的`echo`不知道比到达NUL时停止更好。

嵌入NUL有实际用途：例如，一些版本的`find`和`xargs`会在它们的输入和输出（与命令行参数不同）之间放置或接受NUL而不是换行，如果输入或输出可能包含活动换行，这要安全得多。使用`$'\000'`允许shell非常舒适地适应这些。如果你想试试这个，相应的选项是`find`的`-print0`（用NUL终止符而不是换行打印）和`xargs`的`-0`（读取输入假设NUL终止符）。

在旧版本的shell中，像ISO 8859字体中发现的非英语字符集中的字符可能会导致问题，因为shell也使用这样的字符在内部表示它自己的特殊字符，但最近版本的shell（大约从3.0开始）通过与NUL相同的方式规避了这个问题。任何剩余的问题——完全一致地处理这相当棘手——都是错误，应该报告。

你可以通过使引号标志中的`q`出现总共四次的相当荒谬的方式强制参数用POSIX引号引用。我想不出你为什么要这样做，除了这样会将换行符变成`\n`，因此结果将适合在单行（可能相当长）上。加上你会得到用转义序列替换有趣字符。

[]{#l116}

### 5.1.4: 双引号

双引号允许一些但不是所有的内部替换形式。更具体地说，它们允许参数扩展、命令替换和算术替换，但不允许其他任何替换：进程替换不会发生，大括号和初始波浪号和等号不会扩展，模式也不特殊。这里有一个表格；左边的每个表达式都是一些命令行参数，结果显示了如果它出现在引号外或双引号内会发生什么替换。

      表达式      引号外  双引号内
      ------------------------------------------------
      =(echo hi mum)  /tmp/zshTiqpL     =(echo hi mum)
      $ZSH_VERSION    4.0.1             4.0.1
      $(echo hi mum)  hi mum            hi mum
      $((6**2 + 6))   42                42
      {a,b}cd         acd bcd           {a,b}cd
      ~/foo           /home/pws/foo     ~/foo
      .zl*            .zlogin .zlogout  .zl*

那个`/tmp/zshTiqpL`可能是任何临时文件名，而且其他几个替换在你的情况下会有所不同。

你可能已经猜到，`${(qqq)string}`强制`$string`使用双引号来引用其特殊字符。与其他形式一样，这都是正确处理的——shell知道双引号内哪些字符需要引用，哪些不需要。

**双引号中的单词分割**\

在允许替换的地方，双引号的（几乎）不变的副作用是抑制单词分割。你可以使用`print -l`来看到这一点，它每行打印一个参数：

      % array=(one two)
      % print -l $(echo foo bar) $array
      foo
      bar
      one
      two
      % print -l "$(echo foo bar) $array"
      foo bar one two

这种`几乎`不变的原因是在参数替换的情况下，你可以指定正常的单词分割会发生。有两种方法可以做到这一点；都使用符号`@`。你可能还记得这一点来自参数`$@`，当它出现在双引号中时具有这种效果：脚本或函数的参数像普通数组一样分割成单词，除了空参数不会被删除。我在[第3章](zshguide03.html#syntax)中详细讨论了这一点。

这在以下方式中扩展到其他参数：

      % array=(one two three)
      % print -l "${array[@]}"
      one
      two
      three

以及使用另一个标志`(@)`在所有形式的替换中更普遍：

      % print -l "${(@)array}"
      one
      two
      three

**下标旁注**\

带标志的版本可能比其他版本更不清楚，但它可以出现在很多不同的地方。例如，这里是zsh中如何选择数组片段的方式：

      % print -l ${array[2,-1]}
      two
      three

其中负数从数组末尾开始计数。方括号中的数字称为下标。这也可以得到`(@)`处理：

      % print -l "${(@)array[2,-1]}"
      two
      three

虽然这可能不明显，但你可以在这个情况下使用其他符号：

      % print -l "${array[@][2,-1]}"
      two
      three

shell实际上会处理参数替换中的任意数量的下标，不仅仅是1个；每个都应用于前一个的结果：

      % print -l "${array[@][2,1][1]}"
      two

你必须注意的是，最后的下标选择了一个单词。你可以继续应用下标，但它们只会在该单词的*字符*上应用，而不是在数组元素上：

      % print -l "${array[@][2,1][1][2,-1]}"
      wo

我们现在严重偏离了主题：下标当然会完全独立于单词是否被分割或出现在双引号中而工作。尽管在双引号中发生的单词连接，数组的下标仍然选择数组元素。这是参数扩展规则应用顺序的结果。在`zshexpn`手册条目中有对此的详细描述（在那里的标题`规则`下查找，或在相应的Info或HTML文件的`参数扩展`节点下）。

**引用命令替换的单词分割**\

Zsh有一个有用的功能，你可以强制shell将参数扩展的规则应用于命令替换的结果。要看到这可能有用的地方，考虑特殊`命令替换`的情况（尽管它完全在shell中处理，而不是通过运行外部命令），它将文件的内容放在命令行上：

      % args() { print $#; }    # 报告参数数量
      % cat file
      Words on line one
      Words on line two
      % args $(<file)
      8
      % args "$(<file)"
      1

未引用的替换将文件分割成单个单词；引用的替换根本没有分割它。这些是标准的shell规则。

然而，通常你想要每行一个参数，而不是在行内按空格分割。这就是参数扩展可以派上用场的地方。有一个标志`(f)`表示`分割扩展结果，每行一个单词`。这里是如何在这种情况下使用它：

      % args "${(f)$(<file)}"
      2

在通常放置参数名称的地方，你放置命令替换，shell对结果进行操作（注意它不将结果视为参数的名称，而是作为值——这在下面更详细地讨论）。双引号是必要的，因为否则在参数替换查看结果时，文件已经被分割成单个单词。你可以很容易地验证这两个参数是文件的各个行。我不记得`f`代表什么，但当它出现时，我们已经在快速使用标志代码；Bart Schaefer相信它代表`fold`，这至少有助于你记住它。

[]{#l117}

### 5.1.5: 反引号

关于反引号要说的主要一点是你应该使用另一种命令替换形式。有两个好理由。

首先，另一种形式可以嵌套：

      % print $(print $(print a word))
      a word

显然这是一个愚蠢的例子，但主要的一点是，除了括号对（case语句中的模式是例外，但括号对周围的模式也是有效的，我在本指南中使用了这种形式）之外，唯一应该在shell中不加引号出现的时间是成对出现。因此你可以确信任何格式良好的shell代码都可以出现在命令替换中。

这在`` `...` ``的情况下显然不成立，即使基本效果是相同的。任何未加引号的`` ` ``如果碰巧出现在反引号内的代码块中，将被视为引号的结束。

第二个原因，与第一个密切相关，是可能很难决定在反引号表达式内需要多少层引号。考虑：

      % print "`echo \"hello\"`"
      hello
      % print "$(echo \"hello\")"
      "hello"

很难解释这两者之间的区别，但本质上的要点与嵌套相同：你不能用反引号做嵌套，因为开始和结束符号是相同的，但你可以用括号做嵌套。所以在第二种情况下，毫无疑问嵌入的命令行，`echo \"hello\"`，会被视为如果它出现在命令替换之外；而在第一种情况下，引号内的引号必须被引用。

因此，在

      % print "$(echo "hello")"
      hello

你需要小心：乍一看，双引号对包围了`$`(`echo `和`)`，但它们没有，它们通过替换的虚拟被嵌套。你在参数替换中也会看到同样的事情：

      % unset foo
      % print "${foo:-"a string"}"
      a string

第三个不太好的理由是使用带括号的形式是你的更 sophisticated 的朋友会嘲笑你。在这个复杂的世界里，同伴压力是如此重要。

这就是我要说的关于命令替换的所有内容，因为我在[第3章](zshguide03.html#syntax)讨论基本语法时已经说了很多。

[]{#l118}

## 5.2: 修饰符以及它们修饰的内容

修饰符在[第2章](zshguide02.html#init)中介绍，当时我谈到了`bang历史`，因为那是它们的来源。然而，在zsh中，它们可以在几个其他地方使用。在每种情况下，它们都有相同的格式：一个冒号，后跟一个字母，这是修饰符作用的代码，可能（在替换的情况下）后面跟着一些其他字符串。所以，为了提醒你，除非你设置了`NO_BANG_HIST`：

      % print ~/file
      /home/pws/file
      % print !-1:t
      file

其中`:t`取文件名的尾部（非目录部分）。

第二个用途是在参数中。这很自然地延续下去。注意，修饰符的这两种用途以及以后的用途都不依赖于`NO_BANG_HIST`选项；那纯粹是针对历史的。

      % param=~/file
      % print ${param:t}
      file

通常你可以省略参数替换中的大括号，但我倾向于在修饰符的情况下使用它们以求清晰。无论修饰符来自哪里，shell的相同部分都用于修饰符这一事实有某些后果：

      % print foo
      foo
      % ^foo^bar
      bar
      % param='this sentence contains a foo.'
      % print ${param:&}
      this sentence contains a bar.

符号`&`重复最后一次替换，对于参数修饰符和历史修饰符来说是相同的。我发现参数修饰符甚至比历史修饰符更有用；提取路径的头部或尾部是参数的非常常见的操作。

修饰符也足够聪明，能够以有用的方式处理数组。请注意，这在历史扩展中的参数集上不成立；`:t`只会提取一个尾部，在那种情况下，这可能不是你所期望的：

      % print a sentence with a /real/live/bogus/path in it.
      % print !!:t
      path in it.

然而，数组*确实*按照你可能希望的方式处理：

      % array=(~/.zshenv ~/.zshrc ~/.zlogout)
      % print ${array:t}
      .zshenv .zshrc .zlogout

同样的逻辑也适用于替换。这意味着数组中每个元素的第一个匹配被替换：

      % array=('a bar of chocolate' 'a bar of barflies' 
      array> 'a barrier of barns')
      % print ${array:s/bar/car/}
      a car of chocolate a car of barflies a carrier of barns

除非，当然，你进行全局替换：

      % print ${array:gs/bar/car/}
      a car of chocolate a car of carflies a carrier of carns

但是，请注意，参数替换有它自己的*更*强大的等价物，它可以进行模式匹配，部分替换原始字符串的修改部分，等等。我们将在适当的时候讨论所有这些。

修饰符的最终用途是在文件名生成中，即globbing。由于这通常通过在命令行上有特殊字符来工作，而修饰符只是由普通字符组成，语法略有不同：

      % print *.c
      parser.c lexer.c input.c output.c
      % print *.c(:r)
      parser lexer input output

所以你需要用括号把它们括起来。这是`glob限定符`的特殊情况，你将在下面遇到；你可以混合使用它们，但修饰符必须出现在末尾。例如，

      % print -l ~/stuff/*
      /home/pws/stuff/onefile.c
      /home/pws/stuff/twofile.c
      /home/pws/stuff/subdir
      % print ~/stuff/*(.:r:t)
      onefile twofile

glob限定符`.`指定文件必须是常规的，即不是目录也不是某种特殊文件。`:r`从结果中移除后缀，`:t`取走目录部分。因此，如果你设置了选项`NO_BARE_GLOB QUAL`，文件名修饰符将被关闭。

关于文件名的修饰符需要注意的两点。首先，这是globbing的唯一形式，其中结果不再是文件名；它总是在最后执行，在所有正常的文件名生成之后。据推测，在上面的例子中，插入到命令行中的单词实际上不再对应于真实文件。

其次，尽管如果命令行上的单词不是模式而是带有修饰符的普通单词，它*确实*有效，但如果该模式在修改之前不对应于真实文件，它*不*工作。所以`foo.c(:r)`只有在当前目录中有`foo.c`时才会剥离后缀。这在逻辑上是合理的，因为试图匹配文件会启动globbing系统，包括修饰符。如果这对你来说是个问题，有解决方法；例如，在这种简单的情况下手动插入正确的值，或者更现实地将值存储在参数中并对该参数应用修饰符。

[]{#l119}

## 5.3: 进程替换

关于进程替换我没有什么新要说的，但我确实有一个我发现有用的例子。如果你使用分页器`less`，你可能知道它有预处理你查看的文件的功能，例如通过环境变量`$LESSOPEN`（也许还有`$LESSCLOSE`）临时解压缩文件。Zsh可以非常容易地，以我完全不偏不倚的方式看，更方便地做同样的事情。这里是我的zsh函数前端到less的子集——或者实际上任何分页器，这里由标准环境变量`$PAGER`给出，默认为`less`。你可以硬编码任何文件显示命令在那个点，如果你喜欢。

      integer i=1
      local args arg
      args=($*)

      for arg in $*; do
        case $arg in
          (*.bz2) args[$i]="=(bunzip2 -c ${(q)arg)}"
                  ;;
          # 这假设你的zcat是与gzip一起安装的那个：
          (*.(gz|Z)) args[$i]="=(zcat ${(q)arg)}"
                     ;;
          (*) args=${(q)arg}
              ;;
        esac
        (( i++ ))
      done

      eval command ${PAGER:-less} $args

主要感兴趣的部分是如何替换了`$args`数组的元素。在每个参数中添加额外的引号层的原因是结尾的`eval`；`$args`首先被转换为文字字符数组，因此需要引用来保护特殊字符。没有这些，包含空格或星号或其他任何内容的文件名将无法正确显示。

`eval`在那里是为了让进程替换在运行分页器时在命令行上进行评估，而不是之前。它们在引号中被分配回`$args`的元素，所以不会在那时被评估。效果将是将：

      less file.gz file.txt

变成

      less =(zcat file.gz) file.txt

函数末尾的`command`只是以防函数与分页器同名（在这个例子中是`less`）；它强制调用外部命令而不是函数。进程替换在这种情况下是理想的；它为`less`提供了一个文件名，其中解压缩的`file.gz`内容已被发送到该文件，并且在命令退出后删除该文件。此外，替换以这样的方式进行，你仍然可以像通常使用less一样在命令行上指定多个文件。唯一的问题是`less`提示中显示的文件名没有意义。

以防你没有遇到过，`bzip2`是一个与`gzip`非常相似的程序，使用方式几乎相同，但它提供了更好的压缩。

在输出进程替换中有一个不愉快的地方，就像在多ios中一样。

      echo hello > >(sed s/hello/goodbye)

shell生成`sed`进程来处理命令行的输出——然后忘记了它。它不会等待它（至少，在它退出后不会，那时它会使用`wait`系统调用来整理）。所以依赖进程的结果在下一个命令中可用是危险的。如果你在交互式地尝试它，实际上，你可能会发现在`sed`的输出显示在终端上之前下一个提示已经被打印出来了。这可能被认为是一个错误，但很难修复。

[]{#l120}

## 5.4: 参数替换

你可能从上面看出参数替换是转换zsh命令行可用功能的核心。更重要的是，我们甚至没有涵盖所提供内容的重要部分。

[]{#l121}

### 5.4.1: 使用数组

zsh中的数组语法相当强大（惊讶吗？）；只是不要期望它像perl一样高效。像zsh的其他功能一样，它存在是为了让用户的生活更轻松，而不是让你的计算机运行得飞快。

我零散地介绍过如何设置数组，以及如何提取它们的片段——以下说明了这一点：

      % array=(one two three four)
      % print ${array}
      one two three four
      % print ${array[3]}
      three
      % print ${array[2,-1]}
      two three four

记住，如果你希望数组在函数中是局部的，你需要使用`typeset`或等效的。优雅的方式是`typeset -a`，它创建一个空数组，但只要你先给数组赋值，任何旧的`typeset`都可以。

你可以使用数组索引和数组切片符号在赋值的左侧进行赋值，也就是说，在`\``=`\'的左侧：

      % array=(what kind of fool am i)
      % array[2]=species
      % print $array
      what species of fool am i
      % array[2]=(a piece)
      % print $array
      what a piece of fool am i
      % array[-3,-1]=(work is a man)
      % print $array
      what a piece of work is a man

所以你可以用单个元素替换数组的单个元素，或者用数组切片替换；同样，你可以一次替换一个切片，用不同长度的切片替换——只有你明确告诉它要替换的部分才会被改变，其余部分保持不变，可能被移位以腾出空间。这类似于perl的`splice`命令，只是这一次可能更容易记住。注意，你不应该在左手边提供任何大括号。赋值中表达式的出现足以触发下标的特殊行为，即使`KSH_ARRAYS`生效——尽管在这种情况下你需要从下标中减去1。

你也可以删除中间的部分，但注意你应该使用一个空数组：

      % array=(one two three four)
      % print $#array
      4
      % array[2]=
      % print $#array
      4
      % array[2]=()
      % print $#array
      3

第一次赋值将第2个元素设置为空字符串，它没有被删除。第二次用长度为零的数组替换了数组元素，这确实删除了它。

就像参数替换有用于特殊目的的标志一样，下标也有。你可以强制它们搜索数组，在值上匹配。你可以返回匹配的值((r)everse下标)：

      % array=(se vuol ballare signor contino)
      % print ${array[(r)s*]}
      se
      % print ${array[(R)s*]}
      signor

`(r)`标志接受一个模式并替换了匹配的数组的第一个元素，而`(R)`标志做同样的事情但从数组的末尾开始。如果没有匹配，你会得到空字符串；像往常一样用参数，如果它是在未加引号的参数中唯一的，它将被省略。再次使用我们的`args`函数来计算传递给命令的参数：

      % array=(some words)
      % args() { print $#; }
      % args ${array[(r)s*]}
      1
      % args ${array[(r)X*]}
      0
      % args "${array[(r)X*]}"
      1

在最后一种情况下，空字符串被引用，并作为单个空参数传递下去。

你也可以返回匹配的索引；`(i)`从开头开始匹配，`(I)`从末尾开始匹配。

      % array=(se vuol venire nella mia scuola)
      % print ${array[(i)v*]}
      2
      % print ${array[(I)v*]}
      3  

第一次匹配了`vuol`，第二次匹配了`venire`。如果不匹配会发生什么可能有点出乎意料，但相当合理：你会得到下一个索引。换句话说，末尾不匹配给你数组长度加一，开头不匹配给你零，所以：

      array=(three egregious words)
      for pat in '*e*e*' '*a*a*'; do
        if [[ ${array[(i)$pat]} -le ${#array} ]]; then
          print "Pattern $pat matched in array: ${array[(r)$pat]}."
        else
          print "Pattern $pat failed to match in array"
        fi
      done

打印：

      Pattern *e*e* matched in array: three.
      Pattern *a*a* failed to match in array

如果你改编那段代码，你会看到你得到了索引1和4。注意`$pat`中的字符被视为模式，即使将`$pat`放在命令行上通常只会产生字符本身。下标在这种情况下是特殊的；在这一点上控制语法有点困难。在手册的`zshparam`手册页的`Subscript Parsing`部分或`Array Parameters`信息节点中有对此的更详细描述；要引用`pat`中的字符，你实际上必须提供命令行字符串`'\*e\*e\*'`和`'\*a\*a\*'`。只是绕着喃喃自语`额外的模式扩展层`，每个人都会认为你知道自己在说什么（这对我有效，时断时续）。

目前没有办法从普通数组中使用下标标志提取完整的匹配集。然而，我们将在下面看到其他方法来做到这一点。

[]{#l122}

### 5.4.2: 使用关联数组

回顾[第3章](zshguide03.html#syntax)，如果你忘记了关联数组。这些像普通数组一样接受下标，但这里的下标是与存储在数组元素中的值相关联的任意字符串（或键）。记住，你需要使用`typeset -A`来创建一个，或者使用具有相同选项的`typeset`的亲属。这意味着如果你在函数内部创建它，它将局限于局部作用域，所以如果你想创建一个全局关联数组，你还需要给出`-g`标志。这在关联数组中特别常见，它们经常用于存储全局信息，如配置细节。

从关联数组中检索信息可能会让你陷入一些在数组下标标志使用中已经暗示的问题。然而，由于普通下标不会激活模式，这里有一种解决方法：将下标变成另一个参数：

      % typeset -A assoc
      % assoc=(key value Shlüssel Wert clavis valor)
      % subscript='key'
      % print ${assoc[$subscript]}
      value  

我在这里使用了相当无聊的键，但它们可以是任何字符字符串：

      % assoc=(']' right\ square\ bracket '*' asterisk '@' at\ sign)
      % subscript=']'
      % print ${assoc[$subscript]}
      right square bracket

而*那*是更难用其他方式得到的。尽管如此，如果你定义自己的键，你经常会使用简单的单词，在这种情况下它们可以愉快地直接出现在方括号中。

我在[第3章](zshguide03.html#syntax)中介绍了两个参数标志，`(k)`和`(v)`：

      % print ${(k)assoc}
      * ] @

打印出键，而

      % print ${(kv)assoc}
      * asterisk ] right square bracket @ at sign

和剩下的两种可能性做同样的事情：

      % print ${(v)assoc}
      asterisk right square bracket at sign
      % print ${assoc}
      asterisk right square bracket at sign

你现在知道这些是应用于替换的更大系列技巧的一部分。没有什么能阻止你组合标志：

      % print -r ${(qkv)assoc}
      \* asterisk \] right\ square\ bracket @ at\ sign

这有助于看到单词分隔。不要忘记`print -l`技巧来分隔不同的单词，因此也分隔数组和关联数组的元素：

      % print -l ${(kv)assoc}
      *
      asterisk
      ]
      right square bracket
      @
      at sign

这要清楚得多。像往常一样，如果你从事不规范的zsh活动，比如`SH_WORD_SPLIT`，这将失败，但是明智地使用`@`，无论是作为标志还是下标，以及双引号，总是有效的：

      % print -l "${(@kv)assoc}"
      *
      asterisk
      ]
      right square bracket
      @
      at sign

无论选项设置如何。

除了下标，关联数组和普通数组之间的第二个主要区别是前者没有定义任何顺序。这在你使用过Perl的情况下会完全熟悉；这里的原理是相同的。然而，zsh对关联数组的切片完全没有概念，甚至作为便利也没有。你可以分配单个元素或整个关联数组——记住在第二种情况下，右侧必须由键/值对组成——但你不能分配子组。任何试图使用逗号表示法的切片都会被严厉的错误消息拒绝。

然而，zsh确实有额外的下标标志让你匹配和检索一个或多个元素。如果你使用一个前面带有`(i)`标志的普通下标，而不是普通的下标，shell将搜索给定模式的匹配键（不是值）并返回它。这故意与搜索普通数组以获取其键（在这种情况下只是数字，索引）相同，但注意这次它不匹配值，它确实匹配并返回键：

      % typeset -A assoc
      % assoc=(fred third\ man finnbar slip roger gully trevor long\ off)
      % print ${assoc[(i)f*]}
      fred

你仍然可以使用参数标志`(k)`和`(v)`告诉shell你想要看到哪个部分的匹配元素：

      % print ${(kv)assoc[(i)f*]}
      fred third man

注意分工。下标标志告诉shell要匹配什么，而参数标志告诉它你实际上想要看到匹配元素的哪一部分。

由于关联数组本质上是随机排序的，你无法确定这里会选中fred还是finnbar。然而，你可以使用大写形式`(I)`告诉shell检索所有匹配项。这次，让我们看看为键匹配的元素的值：

      % print -l ${(v)assoc[(I)f*]}
      third man
      slip

而这里我们也得到了`finnbar`所占据的位置。与普通数组中的`(r)`相同的模式规则适用——即使下标来自参数替换本身，下标也被视为模式。

你可能不会惊讶地听到下标标志`(r)`和`(R)`试图匹配关联数组的值而不是它的键。这些也会打印出实际匹配的部分，这里是值，除非你使用参数标志。

      % print ${assoc[(r)*i*]}
      third man
      % print ${(k)assoc[(R)*i*]}
      fred finnbar

还有一对特别相关的下标标志`(k)`和`(K)`。这些有点像case语句：下标被视为字符串，而关联数组的键被视为模式，而不是相反。使用`(k)`，第一个匹配下标的键的值被替换；使用`(K)`，所有匹配键的值被替换

      % typeset -A assoc
      % assoc=('[0-9]' digit '[a-zA-Z]' letter '[^0-9a-zA-Z]' neither)
      % print ${assoc[(k)0]}
      digit
      % print ${assoc[(k)_]}
      neither

以防你仍然困惑，第一个下标中的`0`被视为字符串，而`$assoc`中的所有键都被依次视为模式，有点像

      case 0 in
        ([0-9]) print digit
                ;;
        ([a-zA-Z]) print letter
                   ;;
        ([^0-9a-zA-Z]) print neither
                       ;;
      esac

这一点*不像*case语句中的选择，因为你不能依赖比较的顺序，所以你不能依赖更一般的模式在更具体的模式之后被匹配。你只需要使用足够明确的键来匹配你想要匹配的字符串，而不是其他字符串。这就是为什么我们选择了模式`[^0-9a-zA-Z]`而不是仅仅`*`，就像我们在case语句中可能会使用的一样。

我说存储配置信息是关联数组的常见用途，但shell有一种更强大的方式来做到这一点：样式，这将在下一章的可编程完成讨论中占据重要地位。样式相对于关联数组的主要优势是它们可以是上下文敏感的；你可以轻松地使同一个样式在全局范围内返回相同的值，或者让它在一种特定上下文中具有默认值，或者在不同的地方给出一整套不同的值。每个shell应用程序可以决定`上下文`的含义；你不受完成系统使用的方案或类似方案的束缚。像完成系统那样使用分层上下文意味着为不同模块创建不冲突的样式集很容易。

最后，这里是比较perl和zsh中关联数组的一些用法。

          perl                          zsh
      -----------------------------------------------------------------
      %hash = qw(key value);         typeset -A hash; hash=(key value)
      $hash{key}                     ${hash[key]}
      keys %hash                     ${(k)hash}
      values %hash                   ${(v)hash}
      %hash2 = %hash;                typeset -A hash2; hash2=("${(@kv)hash}")
      unset %hash;                   unset hash
      if (exists $hash{key}) {       if (( ${+hash[key]} )); then
        ...                            ...
      }                              fi

最后提醒：如果你在函数内部创建需要在函数结束后仍然存在的关联数组，你应该使用`typeset -gA`来创建它们，这会将它们放入周围的范围。`-g`标志当然对所有类型的参数都很有用，但关联数组是唯一一种在正确上下文中赋值时不会自动出现的类型；因此这个标志在这里特别值得注意。

[]{#l123}

### 5.4.3: 替换的替换，开头和结尾，等等。

有许多转换可以对参数替换的结果进行。其中最强大的涉及使用模式。对于这一点，你对模式了解得越多，就越好，所以我将在更详细地讨论模式之后保留一些最奇特的解释。特别是，如果你知道如何告诉shell标记它已经匹配的子表达式以供将来提取，这很有用。然而，你可以用所有shell共有的基本模式做一些非常有用的事情。

**标准形式：长度**\

我将分离出zsh特有的形式，并从一些出现在所有从Bourne shell派生的shell中的简单形式开始。手册中给出了更紧凑（读：简洁）的列表，像往常一样。

一些简单的形式不使用模式。首先，替换`${#`*param*`}`输出`$`*param*的长度。在zsh中，你不需要这里的花括号，尽管在具有此功能的大多数其他shell中你需要。注意，`${#}`单独存在是命令行参数数组中的参数数量，这就是为什么显式使用花括号更清楚。

`$#`在标量值和数组值上工作不同；在前一种情况下，它给出字符长度，而在后一种情况下，它给出元素长度。注意我说的是`值`，而不是`参数`——你需要计算出替换是给出标量还是数组：

      % print ${#path}
      8
      % print ${#path[1]}
      13

第一个结果显示我的路径中有8个目录，后者显示第一个目录（实际上是`/home/pws/bin`）有13个字符。在嵌套替换中，你应该记住这一点，如下所述，它可以返回数组或标量。

较早版本的zsh在双引号中或在shell将表达式评估为单个单词的任何地方总是返回字符计数，但现在不再这样；它只取决于值的类型。然而，你可以通过使用`(c)`标志强制shell计算字符，通过使用`(w)`计算单词（即使在标量中，如果需要，它会分割）：

      % print ${#PATH}
      84
      % print ${(c)#path}
      84
      % foo="three scalar words"
      % print ${(w)#foo}
      3

比较前两个，你会看到数组的字符计数包括用于分隔的空间（等于`$PATH`中元素之间冒号的数量）。有一个与`(w)`相关的`(W)`，它将多个单词分隔符视为中间有零长度单词：

      % foo="three  well-spaced  word"
      % print ${(w)#foo}
      3
      % print ${(W)#foo}
      5

在`(w)`的基础上给出两个额外的单词，它将空格组视为一个。作为参数标志，这些语法修改是zsh特有的。

注意，如果你在算术上下文中使用长度（在`((...))`或`$((...))`内部），你必须包括前导的`$`，而替换参数本身时不需要。那是因为在算术上下文中，`#foo`意味着不同的东西——`$foo`中第一个字符在ASCII字符集（或你使用的任何扩展字符集）中的数字。

**标准形式：条件替换**\

下一组替换是一整系列，参数后面跟着一个可选的冒号，然后是`-`、`=`、`+`或`?`。冒号在每种情况下都有相同的效果：没有冒号，shell测试参数是否已设置，然后执行操作，而有冒号，它测试参数是否有非零长度。

最简单的是`${`*param*`:-`*value*`}`。如果`$param`有非零长度（没有冒号，如果它已设置），使用它的值，否则使用提供的*value*。假设`$foo`在以下开始时未设置（无论这看起来多么不可能）：

      % print ${foo-bar}
      bar
      % foo=''
      % print ${foo-bar}
      
      % print ${foo:-bar}
      bar
      % foo='please no anything but bar'
      % print ${foo:-bar}
      please no anything but bar

使用带冒号的形式更常见。原因之一是在函数中你通常会在使用它之前用`typeset`创建参数，在这种情况下它总是存在，最初长度为零，所以其他形式永远不会使用默认值。我将使用冒号来描述其他三种类型。

`${`*param*`:=`*value*`}`与前一种类型类似。但在这种情况下，shell不仅会将*value*替换到行中，还会在这样做时将其分配给*param*（只有在这样做时）。这导致了脚本和函数中的常见习语：

      : ${MYPARAM:=default}  ${OTHERPARAM:=otherdefault}

如果用户已经设置了`$MYPARAM`，什么都不会发生，否则它将被设置为`default`，对于`${OTHERPARAM}`也是如此。`:`命令除了在处理完命令行后返回true外什么都不做。

`${`*param*`:+`*value*`}`在逻辑上是`:-`的对立面：如果参数*没有*零长度，则替换*value*。在这种情况下，*value*通常是另一个参数替换：

      print ${value:+"the value of value is $value"}

只有在`$#value`大于零时才打印字符串。注意，出现在`+`后面的东西可以是shell可以解析的几乎任何单个单词；所有常用的单字替换（所以globbing被排除在外）将应用于它，引号将像往常一样工作。这也适用于`:-`和`:=`后面的值。可能值得一提的另一个常用技巧是：

      print ${1+"$@"}

如果设置了第一个参数，则替换所有按原样传递的位置参数。在一些旧的shell中，单独的`"$@"`在没有传递参数时会给你一个空参数而不是没有参数。在zsh和大多数现代的Bourne派生shell中不需要这种变通方法。然而，zsh的处理中有一个错误；参见第3章中关于函数参数的部分。

最后一种类型不常用（我的意思是我从来没有用过）：`${`*param*`?`*message*`}`测试*param*是否已设置（没有冒号），如果没有，则打印消息并退出shell。交互式shell不会退出，但会立即返回提示符，跳过存储起来执行的任何其他内容。这是一种基本的安全功能，有点像C程序中的`assert`；大多数shell程序员似乎通过更详细的测试来覆盖缺少参数设置的情况。在交互式使用的简短shell函数中，这相当巧妙：

      mless() { mtype ${@:?missing filename} | $PAGER }

**标准形式：模式移除**\

大多数更复杂的类Bourne shell定义了两对模式运算符，我称之为`头尾`运算符。一对（使用`#`和`##`）从字符串头部移除给定模式，返回其余部分，而另一对（使用`%`和`%%`）从字符串尾部移除模式。在每种情况下，单符号形式移除最短匹配模式，而双符号形式移除最长匹配模式。两个典型用法是：

      % print $HOME
      /home/pws
      % print ${HOME##*/}
      pws
      % print ${HOME%/*}
      /home

这里与`${HOME:t}`和`${HOME:h}`有相同的效果，在zsh中你会更可能使用后者。然而，正如你所看到的，模式形式要通用得多。注意与以下的区别：

      % print ${HOME#*/}
      home/pws
      % print ${HOME%%/*}

其中头部最短匹配`*/`只是第一个斜杠，因为`*`可以匹配空字符串，而尾部最长匹配`/*`是整个字符串，一直回到第一个斜杠。尽管这些是标准形式，记住zsh模式的全部功能是可用的。

你如何记住哪个运算符做什么？较长形式做较长匹配的事实可能很容易。记住`#`在头部移除，`%`在尾部移除是困难的。试着想想`hash`和`head`（如果你称它为`pound sign`，当它看起来一点也不像`£`时，你不会得到我的同情），以及`percent`和`posterior`。这对我来说从未有效，但也许我只是缺乏心理纪律。Oliver Kiddle指出，`#`在标准美国键盘上更靠左（头部）。在我的英国键盘上，`#`就在回车键旁边，不幸的是，尽管在这里对`pound sign`的困惑会提醒你的记忆。

最重要的是要记住：这种符号不是我们的错。无论如何，抱歉。顺便说一句，注意在模式运算符的情况下没有有趣的冒号业务。（嗯——除了下面提到的zsh变体。）

**特定于zsh的参数替换**\

现在介绍一些增强功能，zsh具有我刚刚给出的参数替换形式以及其他一些相似但不同的形式。

一个简单的增强是除了`${`*param*`=`*value*`}`和`${`*param*`:=`*value*`}`之外，zsh还有`${`*param*`::=`*value*`}`，它执行无条件赋值以及将值放在命令行上。这与使用正常赋值然后正常参数替换没有多大不同，除了zsh用户喜欢密集的代码。

所有赋值类型都受到参数标志`A`和`AA`的影响，它们告诉shell执行数组和关联数组赋值（在第二种情况下，你需要像往常一样成对的键/值元素）。然而，你应该小心数组元素和单词分割：

      % print -l ${(A)foo::=one two three four}
      one two three four
      % print ${#foo}
      1

那确实让`$foo`成为一个数组，但将参数视为标量值并将其分配给第一个元素。有一个解决方法：

      % print -l ${(A)=foo::=one two three four}
      one
      two
      three
      four
      % print ${#foo}
      4

在这里，参数名称*之前*的`=`具有与其它完全不同的效果：它开启单词分割，就像`SH_WORD_SPLIT`选项生效一样。你可能还记得我在[第3章](zshguide03.html#syntax)的`函数参数`部分中详细讨论了这一点。

然而，你应该小心，因为更复杂的将数组放入参数值的尝试很容易让你误入歧途。通常使用`*array*`=`(*\...*)`或`set -A` *\...*表示法要容易得多。

一个极其有用的zsh增强是符号`${+foo}`，如果`$foo`已设置则返回1，如果未设置则返回0。你可以在算术表达式中使用它。这是处理可能未设置的参数的更灵活的方法，而不是更标准的`${foo?goodbye}`表示法，因此zsh程序员更喜欢使用它。`加号foo`表示`foo已设置`应该相当容易记住。一个更标准的方法是`0${foo+1}`，如果`$foo`未设置则给出0，如果已设置则给出01。

**参数标志和模式替换**\

Zsh通过一些参数标志增加了`头部和尾部`运算符的有用性。通常这些会显示在删除某些匹配部分后剩下的内容。然而，使用标志`(M)`时，shell会显示匹配部分本身。标志`(R)`是相反的，显示其余部分：在正常情况下这并不那么有用，因为你默认得到它。只有当你将它与其他标志结合使用时它才开始有用。

接下来，zsh允许你匹配子字符串，而不仅仅是头部或尾部。你可以通过在`#`或`%`模式匹配形式中给出标志`(S)`来做到这一点。这里的区别是shell是向前还是向后开始搜索匹配的子字符串。让我们取

      foo='where I was huge lizards walked here and there'

看看我们用`h*e`匹配得到什么：

      % print -l ${(S)foo#h*e} ${(S)foo##h*e} ${(S)foo%h*e} ${(S)foo%%h*e}
      wre I was huge lizards walked here and there
      w
      where I was huge lizards walked here and tre
      where I was huge lizards walked here and t

乍一看有些奇怪的差异，但这里是发生的事情。在第一种情况下，`#` shell向前查找直到找到`h*e`的匹配，并取最短的，即第一个单词中的`he`。用`##`，匹配在同一点成功，但最长的匹配延伸到字符串末尾的`e`。用其他两种形式，shell从末尾开始向后扫描，并在到达有匹配的起始点时停止。对于`%`和`%%`，这是最后一个`h`，但前者匹配`he`，后者匹配`here`。

你可以通过使用`(I)`标志来扩展这一点，以指定数字索引。索引需要用冒号分隔，虽然是惯例，但不一定是必须的。然后shell将根据使用的表单向前或向后扫描，直到找到第`(I)`个匹配。注意，它在每个位置只计算一个匹配，要么是最长的，要么是最短的，所以第`(I)`个匹配从有匹配的第`(I)`个位置开始。这里是使用上面的例子删除所有`#`的匹配。

      % for (( i = 1; i <= 5; i++ )); do
      for> print ${(SI:$i:)foo#h*e}
      for> done
      wre I was huge lizards walked here and there
      where I was  lizards walked here and there
      where I was huge lizards walked re and there
      where I was huge lizards walked here and tre
      where I was huge lizards walked here and there

每次我们匹配并删除一个可能的`h*e`集合，其中中间没有`e`，从左到右移动。最后一次没有东西可匹配，返回完整的字符串。注意我们使用的索引本身就是一个参数。

显然`##`会发生什么：它会在所有相同的位置找到匹配，但它们都会延伸到字符串末尾的`e`。`%%`和`%`会发生什么可能不那么明显，但如果你尝试，你会发现它们产生与`##`和`#`相同的匹配集，但索引顺序相反（4对应1，3对应2，等等）。

如果你愿意，你可以使用`M`标志来保留匹配部分而不是字符串的其余部分。还有三个其他标志可以让你获得与匹配相关的索引，而不是字符串：`(B)`表示开始，使用zsh的通常约定，第一个字符是1，`(E)`表示*之后*结束的字符，`(N)`表示长度，简单地说就是`B-E`。你甚至可以有多个这样的标志；替换的值是一个字符串，其中有给定的值用空格分隔，总是按开始、结束、长度的顺序。

有一种与`(S)`标志相反的标志，它不是匹配子字符串，而是只匹配整个字符串；要做到这一点，在`#`前放一个冒号。因此：

      % print ${foo:#w*g}
      where I was huge lizards walked here and there
      % print ${foo:#w*e}
      

      % 

第一个没有匹配，因为`g`不在末尾；第二个匹配了，因为末尾有`e`。

**模式替换**\

参数模式匹配形式中最强大的一个是借用了bash和ksh93；它在传统的Bourne shell中不存在。在这里，你使用一对`/`来表示要替换的模式和它的替换。让我们再次使用蜥蜴：

      % print ${foo/h*e/urgh}
      wurgh

有点难以理解：这是因为像大多数模式匹配器一样，除非另有说明，它取最长的匹配。在这种情况下，`(S)`标志被用来表示不是子字符串（那是自动的），而是最短的匹配：

      % print ${(S)foo/h*e/urgh}
      wurghre I was huge lizards walked here and there

那只会替换第一个匹配。这就是`//`的用武之地；它替换每个匹配：

      % print ${(S)foo//h*e/urgh}
      wurghre I was urgh lizards walked urghre and turghre

（毫无疑问，你已经开始感觉自己像一个典型的年代错误的好莱坞穴居人了。）注意语法：这有点像`sed`或perl中的替换，但末尾没有斜杠，而`//`只有第一个斜杠是双倍的。这有点令人困惑，因为在其他模式表达式中，单个和双个形式意味着最短和最长的匹配，而在这里是`(S)`标志造成了区别。

在`/`的情况下，索引标志`(I)`很有用。它告诉shell替换哪个单个匹配，在`//`的情况下，它告诉shell从哪个匹配开始：从那开始替换所有匹配。

重叠的匹配永远不会被`//`替换；一旦它将新文本放入匹配中，该部分就不再被考虑，而只是检查其右侧的文本是否有匹配。这在其他替换方案中可能是熟悉的。

你可能在想`如果能在替换文本中使用匹配的文本，或者它的某些部分，那不是很好吗？`这在sed中用`\1`或`\&`，在perl中用`$1`和`$&`是可能的。事实证明这在zsh中是*可能*的，由于更复杂的模式匹配功能的一部分。当我谈到模式时会谈论这个，因为它不是参数替换的一部分，尽管它被设计得与参数替换很好地配合。

[]{#l124}

### 5.4.4: 选项标志：分割和连接

有三种类型的标志看起来不像标志，出于历史原因；你已经在[第3章](zshguide03.html#syntax)中见过它们。第一种是打开`SH_WORD_SPLIT`选项的，`${=foo}`。注意，你可以将这与看起来像标志的标志混合使用，在括号中，这种情况下`=`必须出现在右括号之后。你可以通过加倍符号`${==foo}`来强制该选项对单个替换关闭。然而，你不会这样做，除非该选项已经设置，在这种情况下你可能试图与其他shell兼容，不会想使用这种形式。

对分割和连接的更多控制可以通过三种更标准类型的标志实现，`(s)`、`(j)`和`(z)`。这些分别在给定字符串上分割、用给定字符串连接，以及以shell的方式分割。在前两种情况下，你需要以与为`(I)`标志指定索引相同的方式指定字符串参数。例如，这里是将`$PATH`转换为普通数组的方法，而不使用`$path`：

      % print -l ${(s.:.)PATH}
      /home/pws/bin
      /usr/local/bin
      /usr/sbin
      /sbin
      /bin
      /usr/bin
      /usr/X11R6/bin
      /usr/games

任何字符都可以跟在`(s)`或`(j)`后面；字符串参数持续到匹配的字符，这里是`.`。如果字符是包括`<`在内的括号类字符之一，则`匹配`字符是相应的右括号，例如`${(s<:>)PATH}`和`${(s(:))PATH}`都是有效的。这适用于所有需要参数的标志，包括`(I)`。

尽管分割或连接字符串不是模式，但它不必是单个字符：

      % foo=(array of words)
      % print ${(j.**.)foo}
      array**of**words

`(z)`标志不需要参数。因为它处理在shell定义的完整单词上的分割，它自然与引用表达式配合使用，我上面讨论了它与`(Q)`标志一起使用以从带有引号移除的行中提取单词。

同一个参数表达式可以同时进行分割和连接是可能的。这总是以相同的顺序发生，无论你如何指定标志：先连接，然后分割。这在手册条目中参数替换的（相当复杂的）完整规则集中有描述。在某些情况下，这可能会有点令人惊讶。一种情况是当你设置了`SH_WORD_SPLIT`并试图连接字符串时：

      % setopt shwordsplit    
      % foo=('another array' of 'words with spaces')
      % print -l "${(j.:.)foo}"
      another
      array:of:words
      with
      spaces

如果你没有使用`print`的`-l`选项，你可能不会注意到，但即使你要求用冒号连接数组，空格仍然导致单词分割。为了避免这种情况，要么不使用`SH_WORD_SPLIT`（我的个人偏好），要么使用引号：

      % print -l "${(j.:.)foo}"
      another array:of:words with spaces

在这种情况下，数组的元素通常会用空格连接，但由`(j)`标志指定的字符优先。同样，如果`SH_WORD_SPLIT`生效，由`(s)`给出的任何分割字符串将代替正常的一组字符使用，这些字符是字符串`$IFS`中出现的任何字符，默认情况下是空格、制表符、换行符和NUL。

为特定参数替换指定分割不仅设置分割的字符串，还确保即使表达式被引用也会进行分割：

      % array=('element one' 'element two' 'element three')
      % print -l "${=array}"
      element
      one
      element
      two
      element
      three

清楚这里发生了什么：引号强制元素用空格连接，给出一个单个字符串，然后在原始空格以及用于连接数组元素的空格上进行分割。

我很快会谈到嵌套参数替换；你还应该注意，如果需要，分割和连接将在嵌套替换的所有层次上发生，而不仅仅是外层：

      % foo="three blind words"
      % print ${#${(z)foo}}
      3

这打印出最内层表达式的长度；由于zplit，这产生了一个三元素数组。

[]{#l125}

### 5.4.5: 选项标志：`GLOB_SUBST`和`RC_EXPAND_PARAM`

其他两个不使用括号的标志也会影响选项以进行单个替换。第二个是`~`标志，它打开`GLOB_SUBST`，使参数替换的结果有资格进行模式匹配。如符号所示，它也使文件名扩展成为可能，所以

      % foo='~'
      % print ${~foo}
      /home/pws

这是第一个`~`给出家庭目录；参数扩展中的一个只是允许发生这种情况。如果你设置了`GLOB_SUBST`，你可以使用`${~~foo}`来为一个替换关闭它。

还有一个选项标志：`^`强制为当前替换打开`RC_EXPAND_PARAM`，而`^^`强制关闭它。在[第3章](zshguide03.html#syntax)中，我展示了使用此选项扩展的参数如何与大括号扩展配合。

[]{#l126}

### 5.4.6: 更多参数标志

这里有一些其他参数标志；我正在重复其中一些。一个非常有用的标志是`t`，它告诉你参数的类型。这在[第3章](zshguide03.html#syntax)中也出现了。它最常见的用途是在使用参数之前测试参数的基本类型：

      if [[ ${(t)myparam} != *assoc* ]]; then
        # $myparam 不是关联数组。对此做些什么。
      fi

另一个非常有用的类型是用于字符串的左对齐或右对齐，到指定长度，可选择使用指定的填充字符串而不是空格；你甚至可以指定一个一次性字符串放在参数旁边。

      foo='abcdefghij'
      for (( i = 1; i <= 10; i++ )); do
       goo=${foo[1,$i]}
       print ${(l:10::X::Y:)goo} ${(r:10::X::Y:)goo}
      done

打印出相当漂亮的：

      XXXXXXXXYa aYXXXXXXXX
      XXXXXXXYab abYXXXXXXX
      XXXXXXYabc abcYXXXXXX
      XXXXXYabcd abcdYXXXXX
      XXXXYabcde abcdeYXXXX
      XXXYabcdef abcdefYXXX
      XXYabcdefg abcdefgYXX
      XYabcdefgh abcdefghYX
      Yabcdefghi abcdefghiY
      abcdefghij abcdefghij

注意那些冒号（可以是其他字符，如我为`(s)`和`(j)`标志解释的那样）总是在参数前后成对出现，所以有三个参数时，中间的冒号是双倍的。你可以省略`:Y:`部分和`:X:`部分，看看会发生什么。填充字符串不需要是单个字符；如果它们不能完全适合填充空间中的整数倍，最后一个重复将在最靠近插入参数的末端被截断。

两个参数告诉shell你希望对参数替换的值做一些特殊处理。`(P)`标志强制将值视为参数名称，所以你得到双重替换的效果：

      % final=string
      % intermediate=final
      % print ${(P)intermediate}
      string

这有点像在ksh中称为`nameref`的参数，一个标记为引用另一个参数的参数。Zsh可能最终也会有这些；在某些地方它们比`(P)`标志更方便。

一个更强大的标志是`(e)`，它强制重新扫描所有形式的单字替换的值。例如，

      % foo='$(print $ZSH_VERSION)'
      % print ${(e)foo}
      4.0.2

使`$foo`的值被重新检查，这时命令替换被发现并执行。

剩下的标志是一些简单的特殊格式技巧：用`(o)`按正常词法（字符）顺序排列数组元素，用`(O)`按相反顺序排列，用`(oi)`或`(Oi)`分别不区分大小写地做同样的事情，用`(%)`展开提示符`%`转义（容易记住），用`p`展开反斜杠转义就像`print`一样，用`(U)`或`(L)`强制所有字符大写或小写，用`(C)`大写字符串或每个数组元素的第一个字符，用`(V)`显示特殊字符为转义序列。这应该足以开始了。

[]{#l127}

### 5.4.7: 几个参数替换技巧

我忍不住要描述几个额外的技巧。

Zsh可以在参数表达式上做这么多事情，有时即使没有参数也很有用！例如，这里是获取固定字符串长度而不需要将其放入参数的方法：

      % print ${#:-abcdefghijklm}
      13

如果你没有给出名称的参数长度为零（确实如此，因为没有），则使用`:-`之后的字符串，并取其长度。注意你需要冒号，否则你在要求shell测试参数是否已设置，而当它意识到没有要测试的参数时会变得相当烦恼。其他shell不太可能容忍任何这样的语法违规；在这种情况下，`#`可能被视为`$#`，即shell参数的数量。但zsh知道那不会为零长度，假设你知道自己在做什么与额外部分；这很有用，但从技术上讲是违反规则的。

有时你不需要任何东西，只需要标志。最有用的情况是使`填充`标志生成重复单词，效果类似于perl的`x`运算符（对于不熟悉perl的人，表达式`"string" x 3`产生字符串`stringstringstring`。在这里，你需要记住你指定的填充宽度是总宽度，而不是重复次数，所以你需要将其乘以字符串的长度：

      % print ${(l.18..string.)}
      stringstringstring

[]{#l128}

### 5.4.8: 嵌套参数替换

Zsh有一个多层嵌套参数替换系统。而在大多数shell或其他脚本语言中，你会这样做：

      % p=/directory/file.ext
      % p2=${p##*/}            # 从头部移除最长的*/匹配
      % print $p2
      file.ext
      % print ${p%.*}          # 从尾部移除最短的.*匹配
      file

在zsh中你可以用一个替换来完成：

      % p=/directory/file.ext
      % print ${${p##*/}%.*}
      file

节省了中间的临时参数。（同样，在这种特定情况下，你更可能使用`${p:t:r}`。）当这成为一个主要优势时是对于数组：如果`$p`是一个数组，所有替换都应用于数组的每个元素：

      % p=(/dir1/file1.ext1 /dir2/file2.ext2)
      % print ${${p##*/}%.*}
      file1 file2

这可以显著减少处理数组的代码。这是一种绕过像zsh这样的直接交互用户设计的基本`命令，参数`语法的命令行界面没有像perl这样的非交互语言（其`map`函数可能是做同样事情的最简洁方式）的复杂性的方法：

       # Perl代码。
       @p = qw(/dir1/file1.ext1 /dir2/file2.ext2);
       @q = map { m%^(?:.*/)(.*?)(?:\.[^.]*|)$%; } @p;
       print "@q\n";'

或众多可能的变体。在shell中，没有办法将这样的函数放入命令行而不使基本的`命令，参数`语法复杂化；所以我们求助于替换的技巧。但是，请注意，这种程度的简洁性在Perl中也造成了某种可读性不足。此外，zsh针对常见情况进行了如此优化，以至于

      print ${p:t:r}

将适用于数组和标量：`:t`只取文件名的尾部，剥离目录，`:r`移除后缀。在4.0.1之前的zsh版本中，这两个运算符可能会有稍微意外的效果，移除包含目录路径的`后缀`，例如（尽管单独采用的模式形式也是如此）。

注意嵌套替换的一个特性：你可能期望里面的`${...}`进行完整的参数替换，所以外层的会作用于那个值——毕竟，如果替换是单独的，你会得到那个。然而，这不是发生的事情：里面的`${...}`只是一个语法技巧，表示`这里还有更多对参数的操作`。这意味着

      bar='this doesn'\''t get substituted'
      foo='bar'
      print ${${foo}}

只是打印`bar`，而不是`$bar`的值。这是我们之前遇到的情况，但没有额外的`##`和`%`部分。原因是历史性的：当极其有用的嵌套替换功能被添加时，让前导`$`指示shell再次调用替换函数比找到另一种语法要简单得多。你可以使用上面描述的`(P)`替换标志使值重新解释为另一个参数替换。只需记住`${${foo}}`和`${(P)foo}`是不同的。

[]{#l129}

## 5.5: 再次替换

最后，这里简要解释一下如何阅读章节顶部的表达式。这只是给高级学生看的（如果你问我，是疯子）。如果你足够努力，你可以在手册中找到所有部分，即使我上面没有来得及解释的部分。例如，假设数组包含

      array=(long longer longest short brief)

看看

      print ${array[(r)${(l.${#${(O@)array//?/X}[1]}..?.)}]}

给出什么。

1.  总是从里面开始。这里最内层的表达式是

            ${(O@)array//?/X}

    不太清楚？再从里面开始：有我们要操作的参数，其名称是`array`。在那之前，括号中有两个标志：(`O`)表示按降序字母顺序排序结果，(`@`)将结果视为数组，这在标量值（实际上是算术表达式）通常出现的地方是必要的，我们需要取数组元素。在数组名称之后，`//?/X`是全局替换：取模式`?`（任何字符）无论它出现在哪里，并将其替换为字符串`X`。结果是像`$array`一样的数组，但所有元素都变成了用`X`代替原始字符的字符串，并且最长的在前，因为这是反向字母顺序对相同字符的字符串的工作方式。所以

            long longer longest short brief

    会变成

            XXXXXXX XXXXXX XXXXX XXXXX XXXX

2.  接下来，我们有`${#`*result*`[1]}`包裹在周围。这意味着我们取上面得到的数组的第一个元素（`[1]`：这就是为什么我们必须确保它被视为数组），然后取其长度（`#`）。我们最终在这种情况下得到7，第一个（也是最长元素）的长度。我们终于有进展了。

3.  下一步是`${`(`l.`*result*`..?.`)`}`。我们之前的结果作为`(l)`标志替换的参数出现。这是嵌套替换的一个相当特殊的案例：在这一点上，shell期望一个算术表达式，给出要填充的字符串的最小长度。之前的替换被评估是因为算术表达式进行参数替换。所以是那个的结果，7，在这里出现，给出更易于管理的

            ${(l.7..?.)}

    `(l)`标志的完整表达式说`用填充字符`?`将此参数替换的结果填充到最小宽度7`。我们要填充的替换是什么？它是空的：zsh足够聪明，假设你知道自己在做什么当你不给参数名时，只是放入一个空字符串。所以空字符串用问号填充到长度7，给出`???????`。

4.  现在我们有`${array[(r)???????]}`。可能不明显（如果你明白了其余部分，恭喜），问号作为模式是活跃的。下标在这方面被特殊处理。下标标志`(r)`表示`反向匹配`，不是反向，而是相反的方式：在数组本身中搜索匹配的值，而不是将其作为索引。唯一会匹配的是长度为7的字符串。宾果！在这种情况下必须是元素`longest`。如果还有其他相同长度的元素，你只会得到第一个；我想不出一种方法通过单个表达式在不将`$array`转换为关联数组的情况下选择出所有该长度的元素，所以如果你有，你应该感到自豪。

在我写了这个之后，Sven Wischnowsky（负责完成函数中大量类似象形文字的人）指出，实现这一点的类似方法是：

      print ${(M)array:#${~${(O@)array//?/?}[1]}}

这确实显示了最大长度的所有元素。简要总结其工作原理是，最内层的表达式产生对应于元素的`?`，按照我们上面的方式最长的在前，将`?`变成模式匹配字符。下一个扩展选择最长的。最后，最外层的扩展遍历`$array`以找到与完整字符串`?`匹配的元素并选择出那些匹配的元素。

如果你想知道如何在perl中用单个表达式做到这一点，按长度排序可能是最容易的：

      # Perl代码
      @array = qw(long longer longest short brief);
      @array = sort { length $b <=> length $a } @array;

并取出`@array`的第一个元素或前几个元素。然而，在高度优化的脚本语言中，你几乎肯定会用其他方式做这件事：例如，避免排序并只记住最长的元素：

      # Perl代码
      $elt = '';
      $l = 0;
      foreach (@array) {
        $newl = length $_;
        $elt = $_, $l = $newl  if $l > $newl;
      }
      print $elt, "\n";

你可以很容易地在zsh中做同样的事情：

      local val elt
      integer l newl
      for val in $array; do
        newl=${#val}
        if (( newl > l )); then
          elt=$val
          (( l = newl ))
        fi
      done
      print $elt

所以这可能不是嵌套替换的特别好的用途，即使它说明了它的强大。

如果你喜欢那个表达式，在完成函数套件中还有很多类似的供你凝视。

[]{#l130}

## 5.6: 算术扩展

在[第3章](zshguide03.html#syntax)中首次描述了在shell内执行数学运算，我在那里展示了如何用`typeset`的变体创建数值参数，并简要谈到了算术替换。

除了数学库，可用`zmodload zsh/mathfunc`加载，zsh基本上拥有你从C和其他派生语言中期望的所有运算符。换句话说，像

      (( foo = bar ? 3 : 1, ++brr ))

这样的东西是被接受的。逗号运算符就像C中一样工作；所有参数都被评估，在这种情况下`foo = bar ? 3 : 1`根据`bar`是否非零将3或1赋值给`$foo`，然后`$brr`增加1。返回状态由最终表达式决定，所以如果`$brr`在增加后为零，返回状态为1，否则为零（整数可能是负数）。

一个额外的运算符是从FORTRAN或可能是Perl借来的，幂运算符`**`。这可以取整数或浮点数，尽管负指数会导致返回浮点数，所以`$(( 2 ** -1 ))`给出0.5，而不是向下舍入到零。这就是为什么标准库函数`pow`在`zsh/mathfunc`中缺失的原因——它已经以那种其他形式存在。然而，纯整数幂运算是通过重复乘法完成的——直到任意大小，所以代替`2 ** 100`，你应该使用`1 << 100`，对于任何其他整数的幂，如果你不需要精确结果，你应该使用浮点数。为此，`zsh/mathfunc`库使`casts`可用；`float`(*num*)强制表达式*num*被解释为浮点数，无论它本来会给出什么。注意，尽管这像C中的强制转换一样工作，但语法是普通函数调用的语法。同样，`int`(*num*)导致数字被解释为整数——向零舍入；你可以使用`floor`和`ceil`向下或向上舍入，使用`rint`舍入到最近的整数，尽管这三者实际上产生浮点数。它们是标准C库函数。

为了完整起见，幂运算的赋值形式`**=`也有效。我不记得曾经使用过它。

整数的范围取决于你的机器上zsh是如何配置的。主要目标是确保整数足够大以表示文件中的索引；在一些系统上，硬件通常处理32位整数，文件大小可能由64位整数给出，zsh也会尝试使用64位整数。然而，zsh也会测试大整数，即使没有大文件支持；通常它只需要你的编译器有一些容易识别的方式来定义64位整数，比如`long long`，即使本地编译器不处理，gcc也可能处理。你可以轻松测试；如果你的zsh支持64位整数，最大的可用整数是：

      % print $(( 0x7FFFFFFFFFFFFFFF ))
      9223372036854775807

如果你试着给它加上一些正数，你会因为二进制补码算术而得到负结果。这应该足以计算大多数东西。

浮点数的范围总是C `double`的范围，这通常是64位，内部数字极有可能是IEEE标准形式，这也影响了你可以得到的精度和范围，尽管那也是系统特定的。在大多数系统上，数学库函数处理`double`而不是单精度`float`，所以这是自然选择。强制转换函数被称为`float`，因为与C不同，浮点数的表示是为你选择的，所以使用通用名称。

[]{#l131}

### 5.6.1: 输入和输出进制

我将说一两句话关于进制。我已经说过你可以用任何小进制输入一个数字，如`2#101010`或`16#ffff`的形式，后者也可以是C中的`0xffff`。然而，你不能仅仅通过使用前导`0`来输入八进制数字，你可能从C中期望。这里有一个例子说明为什么不。让我们设置：

      % foo=${(%):-%D}
      % print $foo
      01-08-06
