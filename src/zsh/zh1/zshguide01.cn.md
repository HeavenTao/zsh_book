------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [下一章](zshguide02.html)

------------------------------------------------------------------------

[]{#intro}[]{#l1}

# 第一章：简短介绍

Z-Shell，简称 `zsh`，是 UNIX 系统的一个命令解释器，用 UNIX 的行话来说，就是一个 `shell`，因为它包裹着你使用的命令。但远不止于此，zsh 是一个特别强大的 shell --- 而且它是免费的，并处于定期维护中 --- 拥有许多交互式功能，让你能以最少的麻烦完成最多的工作。当然，为此你需要知道这个 shell 能做什么以及如何做，而这正是本指南的目的。

最基本的基础：我将假设你能够访问一个 UNIX 系统，否则本文档的其余部分对你来说没什么用。你也可以通过安装 Cygwin 在 Windows 下使用 zsh，Cygwin 为程序提供了一个类 UNIX 的环境 --- 鉴于标准 Windows 命令解释器的弱点，这样做是件好事。有一些旧版本的 zsh 被移植到了 Windows 上，可以本地运行，即无需 UNIX 环境，尽管它们在某些方面的行为略有不同，我不会进一步讨论它们。

我还将假设你具备一些 UNIX 的基础知识；你应该知道文件系统是如何工作的，例如 `/home/users/pws/.zshrc` 和 `../file` 的含义，以及一些基本命令，例如 `ls`，并且你应该有过不小心用 `rm` 删错文件的经历，诸如此类。在类似 `rm file` 的命令中，我通常会提到 `command`（命令，这里当然是 `rm`）和 `argument(s)`（参数，即命令后被其使用的任何东西），以及你一次性输入的完整内容称为 `command line`（命令行）。

你还需要 zsh 本身；如果你正在阅读本文，你很可能已经有了，但如果你没有，你或你的系统管理员应该阅读[附录 A](zshguide08.html#appa)。现在，我们假设你正坐在一台已经运行着 zsh 的终端前。

现在说到 shell。登录后，你可能会看到一些提示符（屏幕上表示你可以输入命令的一系列符号），例如 `$` 或 `%`，可能前面还有一些其他文本 --- 稍后，我们将看到如何以有趣的方式更改这些文本。那个提示符来自 shell。输入 `print hello`，然后用退格键删除 `hello` 并输入 `goodbye`。现在按下 `Return` 键（或 `Enter` 键，从现在起我将简称为 `<RET>`，同样 `<TAB>` 代表 Tab 键，`<SPC>` 代表空格键）；除非你的系统上有严重的恶作剧问题，否则你会看到 `goodbye`，然后 shell 会返回另一个提示符。在你按下 `<RET>` 之前的所有时间里，你都在与 shell 及其编辑器（称为 `Z-Shell Line Editor` 或简称 `zle`）进行交互；只有在那之后，shell 才去告诉 `print` 命令打印出一条消息。所以你可以看到 shell 是很重要的。

然而，如果你只是输入像那样的简单命令，为什么需要任何复杂的东西呢？在这种情况下，你不需要；但现实生活没那么简单。在本指南的其余部分，我将描述在 zsh 的帮助下，你如何能够：

-   通过使用启动文件，自定义你的工作环境，
-   编写你自己的命令来缩短任务，并将东西存储在 shell 变量（`parameters`）中，这样你就不必记住它们，
-   使用 zle 来最小化你必须输入的量 --- 在 zsh 中，你甚至可以用这种方式编辑小文件，
-   使用 zsh 非常复杂的 文件名生成（俗称 `globbing`）系统，为你想要用于特定命令（如 `mv` 或 `ls`）的文件进行挑选，
-   告诉编辑器你对特定命令使用什么样的参数，这样你只需要输入名称的一部分，它就会使用 zsh 无与伦-
-   使用最新版 zsh 提供的额外附加组件（`modules`），来做一些你通常在 shell 中根本做不到的事情。

这只是一个小小的样本。由于要说的东西太多，本指南将专注于 zsh做得最好的事情，特别是它拥有而其他 shell 没有的东西。下一章通过尝试解释如何按照你想要的方式设置 shell，来介绍一些基础知识。像本指南的其余部分一样，它不打算详尽无遗，要了解全部内容，你应该查阅 shell 手册。

还有一些你可能应该马上知道的事情。首先，shell 总是在运行，即使你输入的命令也在运行；shell 只是等待它完成：你可能从其他 shell 中知道，通过在命令后加上一个 `&`，可以将命令放入**后台**，这意味着 shell 不会等待它们完成。即使命令在前台，shell 也在那里，只是在这种情况下什么也不做。

其次，它不只是运行别人的命令，它也有自己的一些命令，称为**内建命令**或简称**builtins**，你甚至可以添加自己的命令，作为给 shell 的指令列表，称为**函数**；内建命令和函数总是在 shell 自身内部运行。了解这一点很重要，因为不在 shell 自身内部运行的东西不能影响它，因此不能改变参数、函数、别名以及我将要讨论的所有其他东西。

[]{#l2}

## 1.1: 其他 shell 和其他指南

如果你想对 shell 的工作原理、它们的语法（即如何编写命令）以及如何编写脚本和函数有一个基本的了解，你应该阅读关于这个主题的众多书籍之一。特别是，阅读一本描述 Korn shell (ksh) 的书会让你收获最多，因为 zsh 与它非常相似 --- 如此相似，以至于我在讲解过程中指出差异是值得的，因为它们可能会让 ksh 用户感到困惑。最近版本的 zsh 可以非常接近地模拟 ksh（严格来说是 1988 年版的 ksh，尽管越来越多地加入了 1993 年版的特性），虽然并不完美，而且你看得越仔细，就越不完美。然而，重要的是要认识到，如果你只是启动任何一个旧的 zsh，并不能保证它会被设置为像 ksh 一样工作；除非你或你的系统管理员更改了一些设置，否则它肯定不会。你可能不会马上看到这一点，但它会以微妙的方式影响 shell。我稍后会更多地讨论模拟。

还有一些其他的 shell 值得一提。所有 UNIX shell 的鼻祖是 sh，现在被称为 Bourne shell，但最初只被称为 `the shell`。情况与 ksh 类似：zsh 可以非常接近地模拟 sh（比模拟 ksh 更接近，因为 sh 要简单得多），但通常你需要确保它被设置为这样做，然后才能确定它会模拟 sh。

你可能还会遇到 `Bourne-Again Shell`，即 bash。这是 GNU 项目编写的 sh 的一个免费增强版 --- 但它并不总是沿着 ksh 的路线增强，因此在许多方面它与 zsh 非常不同。在一些免费的类 UNIX 系统上，例如 Linux/GNU（人们通常所说的 Linux），命令 sh 实际上是 bash，所以在那里，当你试图确保在所谓的 `sh` 下运行的东西也能在 zsh 下运行时，你应该格外小心。一些 Linux 系统还有另一个更简单的 Bourne shell 克隆，ash；因为它更简单，所以更像原始的 Bourne shell。

一些更现代的操作系统谈论 `POSIX shell`。这是对 UNIX shell 进行标准化的尝试；它最像 Korn shell，尽管有点令人困惑的是，它通常只被称为 sh，因为标准规定它应该如此。通常，这只意味着你的 sh 附带了一些额外的免费功能，并且仍然能如你所愿地工作。Zsh 已经做了一些尝试来符合标准，但你必须告诉它这样做 --- 同样，仅仅启动 `zsh` 并不会有正确的设置。

还有另一个常见的 shell 家族，不幸的是，它们的语法不兼容。这个家族的源头是 C-Shell，csh，之所以这么叫是因为它的语法更像 C 编程语言。当当时唯一可用的其他 shell 是 sh 时，csh 因为有更好的交互功能（如作业控制）而变得普及。后来它被增强为 tcsh，它具有许多你也会在 zsh 中找到的交互功能，因此变得非常流行。尽管有这些共同的特性，zsh 的语法却非常不同，所以你不应该在 zsh 中尝试使用除了最简单的 csh/tcsh 命令之外的命令；但如果你是 tcsh 用户，你会发现你习惯的几乎所有功能在 zsh 中都能找到，而且还有更多。

[]{#l3}

## 1.2: zsh 的版本

在撰写本文时，可供广泛使用的最新 zsh 版本是 4.0.6。你通常会发现两套旧的 zsh。3.0 系列，其最后一个版本是 3.0.9，是一个稳定版本，自 zsh 3 的第一个版本发布以来只有错误修复。3.1 系列是 beta 版本，有很多新功能；其中最后一个版本 3.1.9 与 4.0.1 相差不大；主要的变化是 shell 现在已被宣布为稳定版，因此与 zsh 3 一样，将有一组错误修复，标记为 4.0，以及一组包含新功能的版本，标记为 4.1。由于 4.0 取代了所有 zsh 3 版本，我将尽量简化并只讨论 4.0；但偶尔指出旧版本的不同之处会很有帮助。

Zsh 的一个显著特点是命令行参数的补全。该系统在 3.1.6 和 3.1.7 中发生了变化，使其更具可配置性，并且（只要你保持清醒）稍微不那么晦涩。因此，我不会详细描述旧的补全系统，它使用 `compctl` 命令；zsh FAQ 中有一个非常简短的介绍。旧系统仍然可用，但我们强烈建议新用户从新系统开始。有关新式补全的详细信息，请参见[第六章](zshguide06.html#comp) `补全，旧与新`。

4.0 和 4.1 之间不会有太大差异，只是一些错误修复和一些演进性变化，外加一些额外的模块。在[第七章](zshguide07.html#ragbag)中会有一些关于 4.1 新功能的说明，但你为 4.0 编写的任何东西在可预见的未来都不太可能过时。

[]{#l4}

## 1.3: 约定

我所说的大部分内容都将是相当独立的（这意味着我使用的短语如 `如我之前所说` 和 `我稍后会讨论` 比真正的文体家希望的要多，而且我引用其他章节的次数也过多），但在你深入之前，我可能应该提请你注意一些要点。

我经常会像你在文件中编写可执行代码（`脚本` 或 `函数`，差异将在各处讨论）那样写代码块：

      if [[ $ZSH_VERSION = 3.* ]]; then
        print This is a release of the third version of zsh.
      else
        print This is either very new or very old.
      fi

但有时我会同时显示你在 shell 中交互式输入的内容，以及 shell 返回给你的内容：

      % print $ZSH_VERSION
      3.1.9
      % print $CPUTYPE
      i586

在这里，`%` 显示了 shell 提示符，告诉你它正在等待输入（紧随其后的空格是它的一部分）。实际上，你可能会在百分号前看到一些东西，比如机器名或你的用户名，或者更花哨的东西。为了避免混淆，我把它精简到了最低限度，并保留它作为提醒，这是你输入的那一行。

如果你正在阅读本指南的电子版，并想将前面带有 `%` 的行复制到终端中执行，有一个巧妙的方法，你甚至不必先编辑该行：

      alias %=' '

然后，行首的 `%` 会变成空无一物；空格只是表示任何后续的别名都应该被展开。所以 ` % print $CPUTYPE` 这一行会忽略 `%` 并执行该行的其余部分。（我希望这很明显，但你*自己的*提示符总是被忽略的；这只是在你从指南中复制提示符到 shell 中时才适用。）

Zsh 中有许多不同类型的对象，但最常见的一种是参数，我将始终在它们前面加上 `$` 符号，如 `$ZSH_VERSION`，以提醒你它们是参数。你需要记住，当你设置或操作参数本身而不是其值时，你要省略 `$`。随着我们的深入，何时需要何时不需要它应该会变得更清楚。

我将特别展示的另一类对象是 shell 选项 --- 关于 shell 如何工作的选择 --- 我会这样写：`SH_WORD_SPLIT`、`NO_NOMATCH`、`ZLE`。同样，这也不是全部，因为只要 shell 期望选项，你就可以用大写或小写字母书写它们，下划线的数量也可以随意；而且在代码块中，我通常会使用最简单的形式：`shwordsplit`、`nonomatch`、`zle`。如果你有哲学头脑，可以认为这是在表达谈论编程和实际编程之间的类别差异，但实际上只是我前后不一致而已。

你可能会觉得我用三个连字符来表示一个破折号很奇怪。这实际上是本指南印刷版中使用的一个约定，它是用 LaTeX 制作的。总有一天，我会把它变成一个宏，它会在其他版本中正确显示；但是，总有一天宇宙也会终结。

[]{#l5}

## 1.4: 致谢

我感谢各位 zsh 用户的评论。特别是，我收到了来自 Bart Schaefer、Sven `Mr Completion` Wischnowsky 和 Oliver Kiddle 的详细评论和更正。通常会加上一句“任何剩余的错误都是我自己的”，但这简直是显而易见到了荒谬的地步。我的意思是，这是谁写的？算了。

大部分内容是在某个版本的 Linux Mandrake（Red Hat 的一个衍生版）上，使用通常的 GNU 和 XFree86 工具编写的。由于所有这些都是免费的，说声 `谢谢` 以示感谢似乎是公平的。它也比这台特定 PC 自带的操作系统好用得多。

------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [下一章](zshguide02.html)

------------------------------------------------------------------------