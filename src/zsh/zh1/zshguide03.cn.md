------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide02.html)
-   [下一章](zshguide04.html)

------------------------------------------------------------------------

[]{#syntax}[]{#l29}

# 第三章：处理基本 shell 语法

本章是对[第二章](zshguide02.html#init)中出现的大部分内容的更深入的审视；更具体地说，我假设你正坐在你的终端前，准备使用你刚刚在初始化文件中设置的功能，并想知道足够多的知识来让它们运行起来。实际上，你可能会花大部分时间编辑命令行，特别是补全命令——这两个活动都将在后面的章节中介绍。现在我将讨论命令以及使用它们所伴随的语法。这将让你能够编写 shell 函数和脚本来为你做更多的工作。

在下文中，经常会有几个连续的段落是关于相当次要的功能的。如果你发现你第一次就通读了所有内容，也许你需要多出去走走。大多数人可能会发现，最好是粗略地浏览一下以了解主题是什么，然后在以后发现他们想更多地了解 shell 命令和语法的某个特定方面时再回来。

语法的一个方面留给了[第五章](zshguide05.html#subst)：它的内容太多了，如果你知道得足够多以正确使用它，它会非常有用，以至于不能全部塞在这里。主题是展开，涵盖了诸如参数展开、通配符匹配和历史展开等多种内容。你已经在[第二章](zshguide02.html#init)中遇到了这些的基础知识；但如果你想知道如何用通配符表达式精确地挑选一个特定的文件，或者如何让一个单一的参数展开将一个长表达式简化为你需要的单词，你应该阅读那一章；它或多或少是独立的，所以你不必知道本章的所有内容。

我们从任何命令行解释器中最基本的问题开始，即运行命令。如你所知，你只需输入用空格分隔的单词，其中第一个单词是命令，其余的是它的参数。区分命令的类型很重要。

[]{#l30}

## 3.1: 外部命令

外部命令是最简单的，因为它们与 shell 的交互最少——shell 本身提供的许多命令，将在下一节中描述，被内置到 shell 中正是为了避免这种困难。

因此，唯一的主要问题是如何找到它们。这是通过参数 `$path` 和 `$PATH` 来完成的，正如我在[第二章](zshguide02.html#init)中描述的，它们是绑在一起的，因为虽然前者在 shell 内部更有用——作为一个数组，它的各个部分可以被分开操作——但后者是 shell 调用的其他命令使用的；用行话来说，`$PATH` 被“导出到环境中”，这正意味着 shell 调用的其他命令可以看到它的值。

所以假设你的 `$path` 包含

      /home/pws/bin /usr/local/bin /bin /usr/bin

然后你尝试运行 ``ls``。shell 首先在 `/home/pws/bin` 中寻找一个名为 `ls` 的命令，然后在 `/usr/local/bin` 中，然后在 `/bin` 中，它在那里找到了，所以它执行 `/bin/ls`。实际上，如果你以正确的方式执行一个命令，操作系统本身也知道路径，所以 shell 严格来说并不需要这样做。

这里有一个微妙之处。shell 会尝试记住命令在哪里，以便下次能再次找到它们。它把它们保存在一个所谓的“哈希表”中，你会在文档中到处看到“hash”这个词：它只意味着一种快速找到某个值的方法，给定一个特定的键。在这种情况下，给定一个命令的名称，shell 可以快速找到它的路径。你可以通过输入 ``hash`` 来看到这个表，形式为 `*key*`=`*value*`。

事实上，只有当 `HASH_CMDS` 选项被设置时，shell 才会这样做，默认情况下是设置的。正如你可能预期的，当它找到包含它正在寻找的命令的目录时，它会停止搜索。`HASH_ALL` 选项中还有一个额外的优化，默认也是设置的：当 shell 扫描一个目录以寻找一个命令时，它会将该目录中的所有其他命令添加到哈希表中。这是合理的，因为在大多数类 UNIX 操作系统上，读取同一目录中的一大堆文件是相当快的。

命令的存储方式还有其他后果。特别是，如果 zsh 已经知道在哪里找到一个命令，它就不会去寻找一个新的命令。如果在上面的例子中，我在 `/usr/local/bin` 中放了一个新的 `ls` 命令，zsh 将继续使用 `/bin/ls`（假设它已经被找到了）。要解决这个问题，有一个 `rehash` 命令，它实际上会清空命令哈希表，这样寻找命令就会从头开始。csh 的用户可能记得在使用新命令时需要经常输入 `rehash`：在 zsh 中情况没那么糟，因为如果没有命令已经被哈希，或者现有的命令消失了，zsh 会自动再次扫描路径；此外，如果 `$path` 被改变，zsh 会自行执行一次 `rehash`。所以，在 `$path` 的头部某处添加一个新的重复命令是需要 `rehash` 的主要原因。

如果 zsh 没有填满它的命令哈希表，因此不知道所有的外部命令，可能会发生一件事，那就是 `AUTO_CD` 选项，在上一章提到过，下面还会再次提到，可能会认为你正在尝试切换到一个与命令同名的特定目录。这是 `AUTO_CD` 的缺点之一。

说得更技术化一点，实际上命令哈希是否需要并不那么明显；许多现代操作系统可以在没有它的情况下快速找到命令。在 zsh 的情况下，关键在于同一个哈希表对于命令补全也是必需的，这是一个非常常用的功能。如果你输入 ``compr<TAB>``，shell 会将其补全为 ``compress``。只有当它有一个要补全的命令列表时，它才能这样做，而这个列表就是哈希表。（在这种情况下，它不需要知道在哪里找到命令，只需要它的名字，但多存储一点东西也只是多一点工作而已。）如果你关注了前面的段落，你会意识到 zsh 在你按 `TAB` 的时候不一定知道*所有*可能的命令，因为它只在需要的时候才去查找。为此，有另一个选项，`HASH_LIST_ALL`，默认也是设置的，它会确保在你尝试补全一个命令时命令哈希表是满的。它只需要这样做一次（除非你改变 `$path`），但这确实意味着第一次命令补全会很慢。如果 `HASH_LIST_ALL` 没有设置，命令补全就不可用：shell 可以被重写为每次你尝试补全一个命令名时都费力地搜索路径，但这似乎不值得。

`$PATH` 从 shell 传递给从它调用的命令（严格来说只有当变量被标记为导出时，通常是这样——这在下面用 `typeset` 系列内建命令更详细地描述）这一事实也有后果。一些命令使用 `$PATH` 调用它们自己的子命令。如果你把它设置成一些不寻常的东西，以至于一些标准命令找不到，可能会发生一个*被找到*的命令仍然不能正常运行，因为它在传递给它的路径中找不到它正在寻找的东西。这可能导致一些奇怪和令人困惑的错误消息。

关于外部命令，要记住的一件重要事情是，当它们运行时，shell 继续存在；它只是闲着什么也不做，等待作业完成（尽管你可以告诉它不要等，我们稍后会看到）。命令被给予一个全新的环境来运行；那里的变化不会影响 shell，它只是在命令运行后从它离开的地方重新开始。所以如果你需要做一些改变 shell 状态的事情，一个外部命令是不够的。这就引出了内建命令。

[]{#l31}

## 3.2: 内建命令

内建命令，或简称内建，是 shell 本身的一部分的命令。由于内建对于控制 shell 自身的行为是必需的，介绍它们实际上也作为对 shell 中正在发生的大部分事情的介绍。所以，本应出现在本章后面的相当一部分内容，以某种方式在这里累积起来了。这确实使事情在某些地方有点棘手；数数我用了多少次“微妙”的词，然后留给你的孙子孙女看。

我刚刚描述了内建的一个原因，但还有一个更简单的原因：速度。如果你只想在屏幕上打印一条消息，那么经历在开始时为命令设置一个全新的环境，在这个命令和计算机上正在运行的任何其他东西之间切换，然后在结束时再次销毁它的整个过程，是相当过度的。所以有用于这类事情的内建。

[]{#l32}

### 3.2.1: 用于打印的内建命令

命令 ``echo`` 和 ``print`` 是 shell 内建；它们只是显示你输入的内容，在 shell 移除了所有引用之后。两者之间的区别实际上是历史性的：``echo`` 先出现，只处理一些简单的选项；ksh 提供了 ``print``，它有更复杂的选项，因此成了一个不同的命令。zsh 中的这两个命令之间的区别仍然存在；如果你想要古怪的效果，你应该看看 `print`。请注意，通常还有一个名为 `echo` 的外部命令，它可能与 zsh 的不完全相同；没有标准的名为 `print` 的外部命令，但如果有人在你的系统上安装了一个，它很可能是把东西发送到打印机，而不是屏幕。

一个特殊效果是 ``print -z`` 将参数放到编辑缓冲区堆栈上，这是 shell 维护的一个你将要编辑的东西的列表。试试：

      print -z print -z print 这是一个行

（看起来好像有什么需要引用的，但实际上不需要）然后按三次 return。第一次导致第一个 ``print -z`` 之后的所有内容出现让你编辑，依此类推。

对于更有用的东西，你可以编写函数来给你一行来编辑：

      fn() { print -z print 现在的时间是 $(date); }

现在当你输入 ``fn`` 时，带有日期的那一行会出现在命令行上让你编辑。选项 ``-s`` 有点类似；该行出现在历史列表中，所以如果你使用向上箭头，你会看到它，但它不会自动重新出现。

一些其他有用的选项，其中一些你已经见过，是

**`-r`**
:   不解释像 ``\n`` 这样的特殊字符序列

**`-P`**
:   像在提示符中一样使用 ``%``

**`-n`**
:   在末尾不加换行符，以防后面还有输出

**`-c`**
:   以列的形式打印输出——这意味着 ``print -c *`` 的效果有点像一个穷人版的 ``ls``，只是更快

**`-l`**
:   每个参数占一行而不是一列，这有时对于将列表放入文件，以及计算数组参数的每个元素中有什么很有用。

如果你不使用 `-r` 选项，有一大堆特殊字符序列。其中许多你可能从 C 语言中很熟悉。

**`\n`**
:   换行

**`\t`**
:   制表符

**`\e` 或 `\E`**
:   转义字符

**`\a`**
:   响铃（警报），通常是可怕的哔哔声的委婉说法

**`\b`**
:   后退一个字符。

**`\c`**
:   不打印换行符——像 `-n` 选项，但嵌入在字符串中。这个替代方案来自伯克利 UNIX。

**`\f`**
:   换页，从终端被称为电传打字机的时代开始，表示“前进到下一页”的短语，你可能更熟悉的是 `^L`

**`\r`**
:   回车——打印时，是你在 DOS 文件中得到的烦人的 `^M`，但实际上与 ``print`` 一起使用相当有用，因为它会擦除到行首的所有内容。`-n` 选项和打印字符串开头的 `\r` 的组合可以给人一种连续变化的状态行的错觉。

**`\v`**
:   垂直制表符，我个人从未使用过（我刚才试了一下，它的行为像换行符，只是没有假设回车，但这取决于你的终端）。

实际上，你可以得到所有 255 个可能的字符，尽管你的终端可能不喜欢 127 以上的某些或所有字符，方法是在反斜杠后指定一个数字。通常这由三个八进制字符组成，但你也可以在 `\x` 后使用两个十六进制字符——所以 ``\n``、``\012`` 和 ``\x0a`` 都是换行符。``\`` 本身会转义任何其他字符，即它们会以自身的形式出现，即使它们通常不会。

两点说明：首先，不要因为 ``n`` 是字母表的第十四个字母而感到困惑；打印 ``\016``（八进制的十四）对你没有任何好处。补救措施是，在你发现你的文本不可读之后（对于像 xterm 这样的 VT100 类终端），打印 ``\017``。

其次，那些反斜杠会让你陷入真正的引用困境。通常命令行上的反斜杠会转义下一个字符——这是与 `print` 的转义*不同*的形式——所以

      print \n

不会产生换行符，它只是打印出一个 ``n``。所以你需要引用它。这意味着

      print \\n

传递一个反斜杠给引用，以及

      print \\n

或

      print '\n'

打印一个换行符（后面跟着通常会有的那个额外的换行符）。因此，要打印一个真正的反斜杠，你需要

      print \\\

实际上，如果后面没有其他东西，你可以用两个——`print` 只是耸耸肩，输出它被给予的东西——但这不是一个好习惯。还有其他方法可以做到这一点：因为单引号引用任何东西，包括反斜杠（它们是使反斜杠表现得像普通字符的唯一方法），并且因为 ``-r`` 选项使 print 正常处理字符，

      print -r '\'

有同样的效果。但你需要记住反斜杠的两级引用。引号对 `print` 来说不是特殊的，所以

      print '

对于打印一个引号来说已经足够了。

**`echotc`**\

有一个叫做 ``echotc`` 的怪东西，它以 `termcap` 功能作为其参数。它现在存在于自己的模块 `zsh/termcap` 中。

Termcap 是一种现在相当老式的方式，用于给出在终端上执行各种标准操作所需的命令：移动光标、清除到行尾、打开突出显示模式等等。它现在几乎在所有地方都被 `terminfo` 取代了，这是一种完全不同的指定功能的方式，以及 `curses`，一个更高级的用于在字符终端上操作对象的系统。这意味着你需要给 `echotc` 的参数可能相当难找；试试 `termcap` 手册页；如果有两个，可能是第五节中的那个给出了代码，即 ``man 5 zsh`` 或在 Solaris 上的 ``man -s 5 zsh``。否则你就得在网上搜索了。`zsh` 手册没有给出列表的原因是，shell 只使用少数几个众所周知的序列，还有很多其他的序列可以与 `echotc` 一起工作，因为这些序列是由终端解释的，而不是 shell。

这段代码给你一个感觉：

      zmodload -i zsh/termcap
      echotc md
      echo -n bold
      echotc mr
      echo -n reverse
      echotc me
      echo

首先我们确保模块被加载到 shell 中；在一些旧的操作系统上，这只有在 zsh 安装时被编译进去才行。`zmodload` 的 `-i` 选项阻止 shell 在模块已经加载时抱怨。这是在 shell 函数中确保你有正确设施可用的明智方法，因为加载一个模块会使其可用，直到它被明确卸载。

你应该看到 ``bold`` 是粗体字符，``reverse`` 是粗体反白视频。``md`` 功能打开粗体模式；``mr`` 打开反白视频；``me`` 关闭两种模式。一个更典型的 zsh 做法是：

      print -P '%Bbold%Sreverse%b%s'

这应该显示同样的东西，但使用提示符转义——提示符是特殊字体的最常见用途。``%S`` 是因为 zsh 称反白为“突出显示”模式，因为它就是这样。（在彩色 xterm 上，你可能会发现“粗体”被解释为“蓝色”。）

如果你真的尝试，你可以用 `echotc` 做更多的事情。shell 刚刚获得了一种打印 terminfo 序列的方法，可预见地称为 `echoti`，尽管它只在 zsh 需要 terminfo 来编译的系统上可用——这发生在 termcap 代码实际上是 terminfo 的一部分时。关于这个的好消息是，terminfo 往往有更好的文档，所以你很有可能从 `terminfo` 手册页中找到你想要的功能。`echoti` 命令存在于另一个可预见地命名的模块 `zsh/terminfo` 中。

[]{#l33}

### 3.2.2: 其他仅为速度而设的内建命令

只有少数其他内建命令只是为了让事情变得更快。严格来说，测试可以归入这一类，但正如我在上一章中解释的，以以下形式进行测试是很有用的

      if [[ $var1 = $var2 ]]; then
        print doing something
      fi

被 shell 视为一种特殊语法，以防 `$var1` 或 `$var2` 扩展为空，否则会使其混淆。这个例子包含了下面描述的两个特性：测试本身，在双方括号之间，如果两个替换后的值是相同的字符串，则为真；以及 ``if`` 结构，如果该测试为真，则运行中间的命令（这里只是 `print`）。

内建命令 ``true`` 和 ``false`` 什么也不做，除了分别返回命令状态零或一。它们只是用作占位符：要永远运行一个循环——`while` 稍后也会更详细地解释——你使用

      while true; do
        print doing something over and over
      done

因为测试总是成功。

``true`` 的一个同义词是 ``;``；它经常以这种形式用于给出有副作用但又不应该被使用的参数——有点像

      : ${param:=value}

这是所有 Bourne shell 衍生物中的一个常见用法。在参数扩展中，如果 `$param` 之前是空的，它会被赋予 `value` 的值，否则保持不变。因为那是参数扩展的唯一原因，你使用 `:` 来忽略参数。实际上，shell 愉快地构建命令行——冒号，后面跟着 `$param` 的任何值，无论赋值是否发生——然后执行命令；只是恰好 ``;`` 不理会它被给予的参数。如果你是从 ksh 转换过来的，你可能会期望某些像这样的同义词是别名，而不是内建命令本身，但在 zsh 中它们实际上是内建命令；shell 没有预定义任何别名。（你仍然可以使用 ``disable`` 来摆脱它们，如下所述。）

[]{#l34}

### 3.2.3: 改变 shell 状态的内建命令

内建命令更常见的用途是它们改变 shell 内部的某些东西，或者报告 shell 中正在发生的事情的信息。关于外部命令，有一件至关重要的事情要记住。它也适用于我们将会遇到的其他情况，即 shell “分叉”（fork），字面上是把自己分成两部分，其中分叉出来的部分行为就像一个外部命令。在这两种情况下，命令都在一个不同的*进程*中，这是 UNIX 运行事物的基本单位。（事实上，即使是 Windows 现在也知道进程，尽管它们之间的交互方式略有不同。）

至关重要的事情是，由 shell 启动的独立进程中的任何更改都不会影响 shell 本身。最常见的情况是当前目录——每个进程都有自己的当前目录。你可以通过启动一个新的 zsh 来看到这一点：

      % pwd               # 显示当前目录
      ~
      % zsh               # 启动一个新 shell，它
                          # 是一个独立的进程
      % cd tmp
      % pwd               # 现在我在一个不同的
                          # 目录...
      ~/tmp
      % exit              # 离开新 shell...
      % pwd               # 现在我回到了我原来的地方...
      ~

因此 `cd` 命令必须是一个 shell 内建，否则每次运行它都会发生这种情况。

这里有一个更有用的例子。将命令放在括号中会要求 shell 为它启动一个不同的进程。当你特别*不*希望效果传播回来时，这很有用：

      (cd some-other-dir; run-some-command)

运行该命令，但不会改变“真实” shell 所在的目录，只改变其分叉出来的“子 shell”。因此，

      % pwd
      ~
      % (cd /; pwd)
      /
      % pwd
      ~

还有一个更微妙的情况：

      cd some-other-dir | print Hello

记住，``|``（“管道”）将第一个命令的输出连接到下一个命令的输入——尽管实际上在这个例子中没有信息以这种方式传递。在 zsh 中，除了管道的最后一部分之外，所有部分都在不同的进程中运行。因此 `cd` 不会影响主 shell。我将称之为主 shell，这是 UNIX 对进程的标准语言；当你启动另一个命令或分叉一个子 shell 时，你正在创建“子进程”（无意冒犯，在这种情况下，子进程通常先死）。因此，正如你所猜测的，

      print Hello | cd some-other-dir

*确实*有改变目录的效果。请注意，其他 shell 的做法不同；在 zsh 中总是保证这样工作，因为许多人依赖它来设置参数，但许多 shell 的管道的*左侧*是在父 shell 中运行的部分。如果管道符号的两侧都是某种外部命令，那么两者当然都会在子进程中运行。

还有其他改变 shell 状态的方法，例如通过声明特定类型的参数，或者通过告诉它如何解释某些命令，或者，当然，通过改变选项。这里是最有用的，以一种模糊的逻辑方式分组。

[]{#l35}

### 3.2.4: cd 和它的朋友们

你现在不会惊讶地知道 ``cd`` 命令会改变目录。有一个同义词，``chdir``，据我所知，从来没有人用过。（它与系统调用的名称相同，所以如果你一直在用 C 或 Perl 编程，然后忘了你现在正在使用 shell，你可能会用 ``chdir``。但这似乎有点牵强。）

`cd` 和 `chdir` 中内置了各种额外的功能。首先，如果你省略了要切换到的目录，你将被带到你的主目录，尽管 ``cd ~`` 并不难输入。

其次，命令 ``cd -`` 是特殊的：它会带你到你上一个所在的目录。如果你执行一系列 `cd` 命令，只有紧邻的前一个目录会被记住；它们不会被堆叠起来。

第三，有一个在相似名称的目录之间切换的快捷方式。如果你输入 ``cd <old> <new>``，那么 shell 会在当前目录中寻找字符串 ``<old>`` 的第一次出现，并尝试用 ``<new>`` 替换它。例如，

      % pwd
      ~/src/zsh-3.0.8/Src
      % cd 0.8 1.9
      ~/src/zsh-3.1.9/Src

`cd` 命令实际上报告了新目录，就像它通常在不完全清楚它带你去了哪里时所做的那样。

请注意，只取 `<old>` 的*第一次*匹配。认为你可以用 ``cd 1 2`` 从 `/home/export1/pws/mydir1/something` 切换到 `/home/export1/pws/mydir2/something` 是一个容易犯的错误，但第一个 ``1`` 把它搞砸了。可以说 shell 在这里可以更聪明一些。当然，在这种情况下 ``cd r1 r2`` 会起作用。

`cd` 的朋友 ``pwd``（打印工作目录）告诉你当前的工作目录是什么；这个信息在 shell 参数 `$PWD` 中也可用，它是特殊的，当目录改变时会自动更新。稍后，当你了解了所有关于展开的知识后，你会发现你可以用它来玩一些花样来引用其他目录。例如，`${PWD/old/new}` 使用参数替换机制来引用一个不同的目录，其中 `old` 被 `new` 替换——而这一次 `old` 可以是一个模式，即包含通配符匹配的东西。所以如果你在上面的 `zsh-3.0.8/Src` 目录中，想从 `zsh-3.1.9/Src` 目录复制一个文件，你有一个简写：

      cp ${PWD/0.8/1.9}/myfile.c .

**符号链接**\

Zsh 尝试跨符号链接跟踪目录。如果你不熟悉这些，你可以把它们想象成一个行为像指向另一个文件的指针的文件名（有点像 Windows 的快捷方式，尽管 UNIX 拥有它们的时间要长得多，而且它们工作得更好）。你可以这样创建它们（`ln` 不是一个内建命令，但它用来创建符号链接的用法如今非常标准）：

      ln -s existing-file-name name-of-link

例如

      ln -s /usr/bin/ln ln

在当前目录中创建一个名为 `ln` 的文件，它除了指向文件 `/usr/bin/ln` 之外什么也不做。符号链接在表现得像原始文件方面非常出色，就像你通常希望的那样；例如，你可以运行你刚刚创建的 `ln` 链接，就好像它是 `/usr/bin/ln` 一样。它们在用 ``ls -l`` 进行长文件列表时显示得不同，最后一列显示它们指向的文件。

你可以让它们指向任何类型的文件，包括目录，这就是为什么在这里提到它们。假设你从你的主目录创建了一个到根目录的符号链接，并切换到它：

      ln -s / ~/mylink
      cd ~/mylink

如果你不知道它是一个链接，你会期望能够通过执行 ``cd ..`` 来切换到父目录。然而，操作系统——它只有一套从 `/` 开始向下的目录，并且在跟随符号链接后会忽略它们，它们真的只是指针——认为你在根目录 `/`。这可能会令人困惑。因此，zsh 试图跟踪*你*可能认为你在哪里，而不是系统认为你在哪里。如果你输入 ``pwd``，你会看到 ``/home/you/mylink``（无论你的主目录在哪里），而不是 ``/``；如果你输入 ``cd ..``，你会发现自己回到了你的主目录。

你可以通过设置 `CHASE_LINKS` 选项来关闭所有这些猜测；然后 ``cd ~/mydir; pwd`` 会显示你在 `/`，在那里切换到父目录没有效果；根目录的父目录是根目录，除非在某些稍微迷幻的网络文件系统上。这确实有优点：例如，``cd ~/mydir; ls ..`` 总是列出根目录，而不是你的主目录，无论选项设置如何，因为 `ls` 不知道你跟随的链接，只有 zsh 知道，它将 `..` 视为引用根目录。设置 `CHASE_LINKS` 允许 ``pwd`` 警告你系统认为你在哪里。

给非 UNIX 专家的旁注（据上次统计，占世界人口的 99.9% 以上）：我说“符号链接”而不是仅仅“链接”，因为还有其他叫做“硬链接”的。这就是如果你不使用 `-s` 选项时 ``ln`` 创建的。硬链接与其说是一个指向文件的指针，不如说是文件的一个替代名称。如果你这样做

      ln myfile othername
      ls -l

其中 `myfile` 已经存在，你无法分辨 `myfile` 和 `othername` 哪个是原始的——事实上，系统也不在乎。你可以删除任何一个，另一个作为文件的名称会完全没问题。这几乎就是重命名文件的工作方式，只是在这种情况下，创建硬链接是为你完成的。硬链接有限制——你不能链接到目录，或者链接到另一个磁盘分区上的文件（如果你不知道什么是磁盘分区，你会看到那会是多大的限制）。此外，你通常想知道哪个是原始的，哪个是链接——所以对于大多数用户来说，创建符号链接更有用。唯一的缺点是跟随指针会慢一点点；如果你认为你能注意到区别，你肯定应该慢下来一点。

符号链接的目标，与硬链接不同，实际上不必存在，并且在尝试使用链接之前不会执行任何检查。最好的做法是在创建链接时运行 ``ls -lL``；`-L` 部分告诉 `ls` 跟随链接，如果它工作了，你应该看到你的链接显示为与它指向的文件具有完全相同的特性。如果它仍然显示为链接，则没有这样的文件。

关于符号链接，我应该指出一个轻微的怪癖：被链接的文件名（第一个名字），如果它不是一个绝对路径（在任何 `~` 扩展后以 `/` 开头），则被视为相对于链接创建的目录——而不是你运行 `ln` 时的当前目录。这里：

      ln -s ../mydir ~/links/otherdir

链接 `otherdir` 将引用*其自身*父目录中的 `mydir`，即 `~/links`——而不是，你可能认为的，你运行命令时所在的目录的父目录。更糟糕的是，第二个词，如果不是绝对路径，*是*相对于你运行命令的目录来解释的。

**$cdpath 和 AUTO_CD**\

我们离用目录做的魔法还差得远呢（而且，事实上，我甚至还没讲到 zsh 特有的部分）。下一个技巧是 `$cdpath` 和 `$CDPATH`。它们看起来很像你在上一章遇到的 `$path` 和 `$PATH`，我在上一章的那个上下文中简要地提到了它们：`$cdpath` 是一个目录数组，而 `$CDPATH` 是一个冒号分隔的列表，行为上像一个标量变量。它们给出了一个目录列表，你可能想切换到它们的子目录。如果你使用一个普通的 cd 命令（即形式为 ``cd *dirname*``，并且 *dirname* 不以 `/` 或 `~` 开头），shell 会在 `$cdpath` 的目录中查找，以找到一个包含子目录 *dirname* 的目录。如果 `$cdpath` 没有设置，如你所料，它只使用当前目录。

请注意，`$cdpath` 总是按顺序搜索，你可以在其中放一个 `.` 来代表当前目录。如果你这样做，当前目录将总是在*那个点*被搜索，不一定是第一个，这可能不是你所期望的。例如，让我们设置一些目录：

      mkdir ~/crick ~/crick/dna
      mkdir ~/watson ~/watson/dna
      cdpath=(~/crick .)
      cd ~/watson
      cd dna

所以我已经移动到目录 `~/watson`，它包含子目录 `dna`，并执行了 ``cd dna``。但由于 `$cdpath`，shell 会首先在 `~/crick` 中查找，并在那里找到 `dna`，然后带你到那个自我复制目录的副本，而不是 `~/watson` 中的那个。大多数人因此在他们的 `cdpath` 的开头都有 `.`。然而，至少 `cd` 会警告你——如果你试过，你会看到它在这种情况下会打印出它选择的目录的名称。

事实上，如果你的目录中根本没有 `.`，shell 总是会先在那里查找；没有办法让 `cd` 永远不切换到当前目录的子目录，除非把 `cd` 变成一个函数。有些 shell 不这样做；它们使用 `$cdpath` 中的目录，而且只使用那些。

还有一个更简便的方法，这是 zsh 特有的：我在上一章提到的 `AUTO_CD` 选项。那样，一个没有任何参数的命令，如果它实际上是一个目录，就会带你到那个目录。通常这是完美的——否则你只会得到一个“命令未找到”的消息，你还不如利用这个选项。然而，偶尔，一个目录的名称会与一个命令、内建命令或外部命令，或一个 shell 函数的名称冲突，然后可能会有一些混淆：只要 zsh 知道它，它总是会选择命令，但有些情况下它不知道，正如我上面描述的。

我在上一章没有说的是，`AUTO_CD` 尊重 `$cdpath`；事实上，它的实现方式是让 `*dirname*` 本身的行为尽可能地像 ``cd *dirname*``，而不会把 shell 的内部搞得一团糟。

**目录栈**\

Zsh 从 C-shell 家族继承的一个非常有用的功能是目录栈（传统的 Korn shell 没有这个功能）。这是你最近访问过的目录的列表。如果你使用 ``pushd`` 命令而不是 ``cd``，例如 ``pushd *dirname*``，那么你所在的目录会被保存在这个列表中，然后你会被带到 *dirname*，使用 `$CDPATH` 就像 `cd` 一样。然后当你输入 ``popd`` 时，你会被带回到你原来的地方。这个列表可以任意长；你可以 `pushd` 任意数量的目录，每个 `popd` 都会带你回到列表中的前一个（这就是“栈”，或者更准确地说，是“后进先出”栈在计算机行话中通常的操作方式，因此得名“目录栈”）。

你可以用 `dirs` 命令看到这个列表——它总是以当前目录开始。所以，例如：

      cd ~
      pushd ~/src
      pushd ~/zsh
      dirs

显示

      ~/zsh ~/src ~

下一个 `popd` 会带你回到 `~/src`。如果你这样做，你会看到 `pushd` 在进行时会自动报告 `dirs` 给出的列表；你可以用 `PUSHD_SILENT` 选项关闭这个功能，那时你就必须依赖明确输入 `dirs` 了。

实际上，这个功能的很多用途并非来自简单的 `pushd` 和 `popd` 组合，而是来自另外两个特性。首先，单独的 ``pushd`` 会交换栈顶的两个目录。其次，`pushd` 带有以 ``+`` 或 ``-`` 开头的数字参数，可以带你到列表中的其他目录之一。命令 ``dirs -v`` 会告诉你需要的数字；`0` 是当前目录。所以如果你得到，

      0       ~/zsh
      1       ~/src
      2       ~

那么 ``pushd +2`` 会带你到 `~`。（这里需要一点点悬念，我没有直接用 `AUTO_CD` 然后输入 ``..``。）如果你用 `-`，它会从列表的另一端开始计数；`-0`（向数学家们道歉）是最后一项，在这种情况下与 `~` 相同。有些人习惯于让 ``-`` 和 ``+`` 参数反过来工作；`PUSHD_MINUS` 选项就是为此存在的。

除了 `PUSHD_SILENT` 和 `PUSHD_MINUS`，还有一些其他相关的选项。设置 `PUSHD_IGNORE_DUPS` 意味着如果你 `pushd` 到一个已经在列表中的目录，重复的条目将被静默删除。这对大多数人类操作来说很有用——然而，如果你在函数或脚本中使用 `pushd` 来为将来的匹配 `popd` 记住以前的目录，这可能很危险，你可能想在函数内部局部地关闭它。

`AUTO_PUSHD` 意味着任何改变目录的命令，包括自动 cd，都被视为一个带有目标目录作为参数的 `pushd` 命令。使用这个可能会让目录栈变得很长，有一个参数 `$DIRSTACKSIZE` 你可以设置来指定一个最大长度。当超过这个长度时，最旧的条目（``dirs -v`` 列表中的最高数字）会自动被删除。除非明确设置，否则没有限制。

最后一个 `pushd` 选项是 `PUSHD_TO_HOME`。这使得单独的 `pushd` 行为像单独的 `cd` 一样，即它带你到你的主目录，而不是交换栈顶的两个目录。通常一系列的 ``pushd`` 命令的工作方式很像一系列的 ``cd -`` 命令，总是带你到你之前的目录，明显的区别是 ``cd -`` 不会查询目录栈，它只是自动记住前一个目录，因此如果你只用 ``cd -``，它可能会让 `pushd` 感到困惑。

关于 `pushd` 还有一个最后的微妙之处，那就是当你用类似 ``pushd +2`` 的命令将一个特定的目录带到前面时，列表的其余部分会发生什么。通常列表只是简单地循环，所以之前是 +3 和 +4 的目录现在就在列表的新头部后面，而之前在它前面的两个目录被移到了末尾。如果之前的列表是：

      dir1  dir2  dir3  dir4

那么在 `pushd +2` 之后你得到

      dir3  dir4  dir1 dir2

这种行为在 zsh 的生命周期中改变了，我们中的一些人更喜欢旧的行为，即那个目录被拉到前面，其余的只是填补了空缺：

      # 旧行为
      dir3  dir1  dir2  dir4

这样过了一段时间，你就会在列表的前面得到一个“热门精选”组。如果你也喜欢这种行为（我觉得我需要写过群论的论文才能喜欢新的行为），源代码中提供了一个 `pushd` 函数，尽管它足够短，可以在这里重复——这是 zsh 风格的自动加载形式：

      # pushd 函数以模拟旧的 zsh 行为。
      # 有了它，pushd +/-n 会将选定的元素
      # 提升到栈顶，而不是循环
      # 栈。

      emulate -R zsh
      setopt localoptions

      if [[ ARGC -eq 1 && "$1" == [+-]<-> ]] then
              setopt pushdignoredups
              builtin pushd ~$1
      else
              builtin pushd "$@"
      fi

``&&`` 是一个逻辑“与”，要求两个测试都为真。测试是函数只有一个参数，并且它的形式是 ``+`` 或 ``-`` 后跟任意数字（``<->`` 是一个特殊的 zsh 模式，用于匹配任意数字，是像 ``<1-100>`` 这样的形式的扩展，后者匹配 1 到 100 范围内的任意数字，包括两端）。

**引用其他目录**\

Zsh 有两种方法可以让你引用特定的目录。它们的共同点是都以 `~` 开头（在非常旧的 zsh 版本中，第二种形式实际上使用了一个 ``=``，但现在的方式更合乎逻辑）。

你肯定知道，因为我已经大量使用了，一个单独的 ``~`` 或后面跟着一个 `/` 指的是你自己的主目录。这个的扩展——同样来自 C-shell，尽管 Korn shell 在这种情况下也有——是 `~name` 可以引用系统上任何用户的主目录。所以如果你的用户名是 `pws`，那么 `~` 和 `~pws` 是同一个目录。

Zsh 对此有一个扩展；你实际上可以命名你自己的目录。这在[第二章](zshguide02.html#init)中已经描述过了，关于提示符，因为那是主要用途：

      host% PS1='%~? '
      ~? cd zsh/Src
      ~/zsh/Src? zsrc=$PWD
      ~/zsh/Src? echo ~zsrc
      /home/pws/zsh/Src
      ~zsrc?

请查阅那一章，了解强制一个参数被识别为命名目录的方法。

有一个稍微更复杂的方法可以直接做到这一点：

      hash -d zsrc=~/zsh/Src

使得 `~zsrc` 像以前一样出现在提示符中，并且在这种情况下没有参数 `$zsrc`。这是纯粹主义者的方式（尽管很少有 zsh 用户是纯粹主义者）。你可以猜到 ``unhash -d zsrc`` 是做什么的；这也适用于通过参数命名的目录，但会保留参数本身。

可能会有一个与用户名同名的命名目录。在这种情况下，``~name`` 指的是你明确命名的目录，没有简单的方法可以得到 `name` 的主目录，除非删除你定义的名称。

如果你正在使用命名目录和 `cd` 类的命令或 `AUTO_CD`，你可以设置 `CDABLEVARS` 选项，它允许你省略开头的 `~`；使用这个选项的 ``cd zsrc`` 会带你到 `~zsrc`。这个名字是一个历史遗留物，现在是一个用词不当；它实际上是命名目录，而不是参数（即变量）被使用。

用 `~` 引用目录的第二种方法是使用数字而不是名称：数字引用目录栈中的目录。所以如果 `dirs -v` 给你

      0       ~zsf
      1       ~src

那么 `~+1` 和 `~-0`（不太数学，但如果你仔细想想很合逻辑）都指的是 `~src`。在这种情况下，与 pushd 参数不同，你可以省略 `+` 并使用 `~1`。`PUSHD_MINUS` 选项是被尊重的。你会看到这在上面的 `pushd` 函数中被使用了：诀窍是 `~+3`，例如，指的是与 `pushd +3` 相同的元素，因此 `pushd ~+3` 将那个目录推到了列表的前面。然而，我们设置了 `PUSHD_IGNORE_DUPS`，所以旧位置的值也被移除了，给了我们我们想要的效果，即简单地将目录拉到前面，没有棘手的循环。

[]{#l36}

### 3.2.5: 命令控制和信息命令

存在各种内建命令，它们控制你如何访问命令，并显示可以运行的命令的信息。

前两个严格来说是“前置命令修饰符”而不是命令：这意味着它们放在命令行之前并修改其行为，而不是它们本身就是命令。如果你在命令行前放上 ``command``，命令词（下一个词）将被视为外部命令的名称，无论它通常如何被解释；同样，如果你在前面放上 ``builtin``，shell 将尝试将该命令作为内建命令运行。通常，shell 函数优先于内建命令，内建命令优先于外部命令。所以，例如，如果你的打印机控制系统有 ``enable`` 命令（许多 System V 版本都有），它与我将要谈论的一个内建命令冲突，你可以运行 ``command enable lp`` 来启用一个打印机；否则，内建的 enable 将被运行。同样，如果你已经将 `cd` 定义为一个函数，但这次想调用正常的内建 `cd`，你可以说 ``builtin cd mydir``。

`command` 的一个常见用途是在同名的 shell 函数内部。有时你想通过在普通命令周围添加一些额外的东西来增强它，然后调用那个命令，所以你编写一个同名的 shell 函数。要在 shell 函数内部调用命令本身，你使用 ``command``。以下代码可以工作，尽管它显然不那么有用：

      ls() {
        command ls "$[@]"
      }

所以当你运行 ``ls`` 时，它会调用函数，函数会调用真正的 `ls` 命令，并传递你给它的参数。

你可以用 ``disable`` 和 ``enable`` 命令对 shell 将运行的命令进行更持久的控制。前者通常接受内建参数；每个这样的内建命令在 shell 中都不会被识别，直到你为它发出一个 ``enable`` 命令。所以如果你想能够运行外部的 `enable` 命令，并且不特别关心内建版本，``disable enable``（抱歉如果这令人困惑）就能做到。哈，你在想，你不能运行 ``enable enable``。没错：在遥远的过去，`builtin enable enable` 可能会起作用，但目前不行；如果我记得改的话，这可能会改变。你可以只用 ``disable`` 本身来列出所有被禁用的内建命令——大多数做这类操作的内建命令都像那样工作。

你可以通过给出不同的选项来用 `disable` 和 `enable` 操作其他命令集：用 `-a` 选项操作别名，用 `-f` 选项操作函数，用 `-r` 选项操作保留字。前两个你可能已经知道了，我稍后也会讲到，但“保留字”需要描述一下。它们本质上是对 shell 有一些特殊语法意义的内建命令，包括一些符号，如 ``{`` 和 ``[[``。它们优先于除别名之外的所有东西——事实上，由于它们在语法上是特殊的，shell 需要很早就知道它找到了一个保留字，等到它尝试执行一个命令时就太晚了。例如，如果 shell 找到 ``[[``，它需要知道直到 ``]]`` 的所有内容都必须被视为一个测试，而不是普通的命令参数。因此，你不会经常想禁用一个保留字，因为 shell 将无法正常工作。你可能这样做的最明显的原因是为了与某个没有该保留字的其他 shell 兼容。你可以用以下命令得到一个完整的列表：

      whence -wm '*' | grep reserved

我将在下面解释，因为我马上就要讲到 ``whence``。

此外，我倾向于发现，如果我想摆脱别名或函数，我使用 ``unalias`` 和 ``unfunction`` 命令来永久地摆脱它们，因为我总是在某个地方存储了原始定义，所以这两个选项可能也不是那么有用。禁用内建命令绝对是 `disable` 的四种可能性中最有用的。

外部命令必须以不同的方式操作。上面给出的类型由 shell 内部处理，所以它需要做的就是记住要调用什么代码。对于外部命令，问题在于如何找到它们。我上面提到了 `rehash`，但没有告诉你 `hash` 命令，你已经见过它的 `-d` 选项，可以用来告诉 shell 如何找到一个外部命令：

      hash foo=/path/to/foo

使得 `foo` 使用显示的路径执行命令（它甚至不必以 ``foo`` 结尾）。这有点像一个别名——大多数人可能会用别名来做这个，事实上——尽管速度快一点，但你不太可能注意到区别。你可以用 `unhash` 来移除这个。这里有一个陷阱是，如果路径被重新哈希，无论是通过调用 `rehash` 还是当你改变 `$path` 时，整个哈希表都会被清空，包括你以这种方式放入的任何东西；所以它不是特别有用。

在所有这些之中，能够找出 shell 认为一个特定的命令名是做什么的，是很有用的。命令 ``whence`` 告诉你这个；它也以 `where`、`which` 和 `type` 的名称存在，选项略有不同，主要是为了提供与其他 shell 的兼容性。我只讲 `whence`。

它的标准输出实际上并不特别有趣。如果它是一个 shell 内部以某种方式知道的命令，它会被回显回来，如果是别名，别名会被展开；如果它是一个外部命令，它会以完整路径打印出来，显示它来自哪里；如果它不为人知，命令返回状态 1 并且不打印任何东西。

你可以用 `-v` 或 `-c` 选项让它更有用，它们更详细；前者打印一条信息消息，而后者打印出它被问及的任何函数的定义（这也是使用 ``which`` 而不是 ``whence`` 的效果）。一个非常有用的选项是 `-m`，它将任何参数作为使用通常的 zsh 模式格式的模式，换句话说，与用于匹配文件的格式相同。因此

      whence -vm "*"

打印出 shell 知道的每个命令，以及它对它的看法。

注意 ``*`` 周围的引号——你必须在任何模式不用于在命令行上生成文件名，而是需要传递给命令以供解释的地方记住这些。如果这看起来是一个相当微妙的区别，想想如果你在一个有文件 ``foo`` 和（猜猜看）``bar`` 的目录中运行

      # 糟糕。最好不要在家里尝试这个。
      # （甚至更好，也不要在工作中这样做。）
      whence -vm *

会发生什么。当 shell 第一次看命令行时，它还没有决定要运行哪个命令；它只是看到 ``*`` 并将该行扩展为

      whence -vm foo bar

这不是你想要的。

还有几个值得一提的技巧：`-p` 使 shell 在你的路径中搜索它们，即使该名称被匹配为其他东西（比如说，一个 shell 函数）。所以如果你将 `ls` 定义为一个函数，

      which -p ls

仍然会告诉你 ``command ls`` 会找到什么。此外，选项 `-a` 搜索所有命令；在同一个例子中，这会向你显示 `ls` 命令和 `ls` 函数，而 `whence` 通常只会显示函数，因为那是将被运行的那个。`-a` 选项还会显示它是否在你的路径中找到了多个外部命令。

最后，选项 `-w` 很有用，因为它用一个单词标识命令的类型：`alias`、`builtin`、`command`、`function`、`hashed`、`reserved` 或 `none`。其中大多数是显而易见的，`command` 是一个普通的外部命令；`hashed` 是一个用 `hash` 内建命令明确给定了路径的外部命令，`none` 意味着它根本没有被识别为命令。现在你知道我们上面是如何提取保留字的了。

`whence` 的一个近亲是 `functions`，它当然适用于 shell 函数；它通常列出作为参数给出的所有函数的定义，但它的亲戚（其中 `autoload` 是一个）执行各种其他技巧，将在下面关于 shell 函数的部分描述。小心 `function`，没有 `s`，它完全不同，不像 `command` 或 `builtin`——它实际上是用于*定义*函数的关键字。

[]{#l37}

### 3.2.6: 参数控制

有各种用于控制 shell 参数的内建命令。你已经知道如何设置和使用参数，但当你查看细节时，它要复杂得多。

**局部参数**\

操作参数行为的主要命令是 ``typeset``。它最简单的用法是声明一个参数；你只需给它一个参数名列表，这些参数名被创建为标量参数。你可以通过赋值来创建参数，但 ``typeset`` 的主要作用是，如果一个参数以这种方式在函数内部创建，该参数将在函数结束时恢复其原始值，或者如果它以前不存在则被移除——换句话说，它具有“局部作用域”，就像你在大多数普通编程语言中声明的变量一样。事实上，用行话来说，它具有“动态”而非“语法”作用域，这意味着同一个参数在当前函数内调用的任何函数中都是可见的；这与 C 或 FORTRAN 不同，在 C 或 FORTRAN 中，任何被调用的函数或子程序都看不到父函数中声明的任何变量。

以下内容使这一点更具体。

      var='原始值'
      subfn() {
        print $var
      }
      fn() {
        print $var
        typeset var='函数中的值'
        print $var
        subfn
      }
      fn
      print $var

这段代码打印出

      原始值
      函数中的值
      函数中的值
      原始值

代码的前三块只是定义了参数 `$var` 和两个函数 `subfn` 和 `fn`。然后我们调用 `fn`。它做的第一件事是打印出 `$var`，得到 ``原始值``，因为我们没有改变原始定义。然而，接下来的 `typeset` 改变了它；如你所见，我们可以在 typeset 期间给参数赋值。因此，当我们再次打印出 `$var` 时，我们得到 ``函数中的值``。然后调用 `subfn`，它打印出与 `fn` 中相同的值，因为我们没有改变它——这就是 C 或 FORTRAN 会有所不同的地方，它们不会识别这个变量，因为它没有在那个函数中声明。最后，`fn` 退出，原始值被恢复，并由最后的 ``print`` 打印出来。

注意值改变了两次：一次在 `typeset`，另一次在 `fn` 的末尾。`$var` 在任何时候的值都将是这两个值之一。

虽然你可以在 `typeset` 语句中进行赋值，但你不能给数组赋值（我在上一章已经说过了）：

      typeset var=(这不起作用！)

因为带括号的语法是特殊的；它只在行只包含赋值时才起作用。然而，如果你尝试将一个数组赋给一个标量，或者反过来，shell 不会抱怨；它只是默默地转换类型：

      typeset var='标量值'
      var=(数组值)

我在 typeset 语句中加入了赋值，以强调它创建标量，但实际上在函数中设置数组的通常方法是

      typeset var
      var=()

它创建一个空的标量，然后将其转换为空的数组。最近版本的 shell 有 ``typeset -a var`` 来一步完成——但你*仍然*不能在同一个语句中给它赋值。

`typeset` 及其亲属只是带有普通参数集的普通命令，这一事实还带来了其他问题。考虑这个：

      % typeset var=`echo 两个 词`
      % print $var
      两个

“词”去哪儿了？答案是，反引号替换，下面会讨论，在未被引用时会分割单词。所以 `typeset` 语句等同于

      % typeset var=两个 词

有两种方法可以解决这个问题；首先，使用普通赋值：

      % typeset var
      % var=`echo 两个 词`

它可以判断出是标量赋值，因此知道不要分割单词，或者引用反引号，

      % typeset var="`echo 两个 词`"

我们还没有谈到三种重要的类型；这两种都只能用 `typeset` 或我稍后会列出的类似内建命令之一来创建。它们是整数类型、浮点类型和关联数组类型。

**数值参数**\

整数是用 ``typeset -i`` 创建的，或者 ``integer``，这是另一种说法。它们用于算术，shell 可以这样做：

      integer i
      (( i = 3 * 2 + 1 ))

双括号包围一个完整的算术表达式：它的行为就像被引用了一样。里面的表达式可以是你可能在其他编程语言的算术中习惯的几乎任何东西。一个重要的注意事项是，参数前面不需要有 `$``，即使它们的值正在被取用：

      integer i j=12
      (( i = 3 * ( j + 4 ) ** 2 ))

在这里，`j` 将被替换为 12，`$i` 得到值 768（十六的平方乘以三）。你可能不认识的一个东西是 `**`，这是 FORTRAN 和 Perl 中出现的“乘方”运算符。请注意，在双括号内有括号是没问题的——实际上，你甚至可以这样做

      (( i = (3 * ( j + 4 )) ** 2 ))

而且 shell 不会感到困惑，因为它知道里面的任何括号都必须是成对的（直到你用你的有 bug 的代码故意迷惑它）。

你通常会用 ``print $i`` 来看看 `$i` 被赋予了什么值，当然，它会以十进制数的形式打印出来。然而，`typeset` 允许你指定另一个基数来打印。如果你这样做

      typeset -i 16 i
      print $i

在上次计算之后，你应该会看到 `16#900`，这意味着以 16 为基数（十六进制）的 900。这就是选项 ``-i 16`` 对 `$i` 的唯一影响——你可以像平常一样给它赋值并在算术表达式中使用它，但当你打印它时，它会以这种形式出现。你也可以用这种基数表示法来输入数字：

      (( i = 16#ff * 2#10 ))

这意味着 255（十六进制的 `ff`）乘以 2（二进制的 `10`）。shell 也理解 C 的表示法，所以 ``16#ff`` 可以表示为 ``0xff``。

浮点变量非常相似。你可以用 ``typeset -F`` 或 ``typeset -E`` 来声明它们。两者唯一的区别，同样，是在输出上；`-F` 使用定点表示法，而 `-E` 使用科学（助记：指数）表示法。内建命令 ``float`` 等同于 ``typeset -E``（因为 Korn shell 就是这么做的，所以就这样）。浮点表达式也以你可能习惯的方式工作：

      typeset -E e
      typeset -F f
      (( e = 32/3, f = 32.0/3.0 ))
      print $e $f

打印

      1.000000000e+01 10.6666666667

几点说明：``,`` 可以分隔不同的表达式，就像在 C 中一样，所以 `e` 和 `f` 的赋值是分开执行的。`e` 的赋值实际上是一个整数除法，因为 32 和 3 都不是浮点数，浮点数必须包含一个点。这意味着进行了一个整数除法，产生 10，然后在最后才转换为浮点数。同样，这就像成熟的语言的工作方式，所以咒骂是没用的。`f` 的赋值是一个完整的浮点运算。浮点参数在 `3.1.7` 版本之前是不可用的。

虽然这实际上是后面章节的内容，但有一个浮点函数库你可以加载（实际上它只是链接系统数学库的一种方式）。通常的咒语是 ``zmodload zsh/mathfunc``；你的系统上可能没有库的“动态加载”，这可能意味着那不起作用。如果可以，你可以做类似的事情

      (( pi = 4.0 * atan(1.0) ))

广义上说，大多数系统数学库中出现的所有函数（参见 `math` 的手册页）在 zsh 中都可用。

像所有其他用 `typeset` 或其亲属之一创建的参数一样，整数和浮点参数是函数局部的。你可能想知道如何创建一个具有整数或浮点值的全局参数（即在函数外部和内部都有效的参数）。shell 最近增加了一个功能（在 3.1.6 版本中）允许这样做：在 typeset 中使用 `-g` 标志以及任何其他标志。例如，

      fn() {
        typeset -Fg f
        (( f = 42.75 ))
      }
      fn
      print $f

如果你试试，你会看到 `$f` 的值在函数之外仍然存在。`g` 代表全局，显然，尽管它不完全那么简单：

      fn() {
        typeset -Fg f
      }
      outerfn() {
        typeset f='标量值'
        fn
        print $f
      }
      outerfn

函数 `outerfn` 为 `f` 创建一个局部标量值；这就是 `fn` 所看到的。所以它实际上不是在操作一个“全局”值，它只是没有为 `fn` 的作用域创建一个新的。错误消息是因为它试图在改变其类型的同时保留 `$f` 的值，而该值不是一个正确的浮点表达式。错误消息，

      fn: bad math expression: operator expected at `value'

是因为对数字参数赋值总是执行算术求值。在操作 ``scalar value`` 时，它找到了 ``scalar`` 并假设这是一个参数，然后寻找一个像 ``+`` 这样的运算符；但它找到了 ``value``。如果你想实验，把字符串改成 ``scalar + value`` 并设置 ``value=42``，或者别的什么，然后再试一次。这有点令人困惑（这是说它让我困惑的委婉说法），但与 zsh 通常对待参数的方式是一致的。

实际上，在某种程度上你不需要使用整数和浮点参数。任何时候 zsh 需要一个数字表达式，它都会强制一个标量到正确的值，任何时候它产生一个数字表达式并将其赋给一个标量，它都会将结果转换为字符串。所以

      typeset num=3            # 这是*字符串* `3'。
      (( num = num + 1 ))      # 但这无论如何都有效
                               # ($num 仍然是一个字符串)。

如果你有一个参数有时是数字，有时是字符串，这可能很有用，因为 zsh 为你做了所有的转换工作。然而，如果你总是想要一个数字，这也可能令人困惑，因为 zsh 无法为你猜测；另外，不来回转换效率更高一些；另外，当你这样做时会失去精度，因为如果数字作为字符串而不是内部数字表示存储，你说的就是你得到的（尽管 zsh 在隐式转换为字符串时倾向于给你很多小数位）。无论如何，我建议如果你知道一个参数必须是整数或浮点值，你应该这样声明它。

有一个名为 `let` 的内建命令来处理数学表达式，但是因为

      let "num = num + 1"

等同于

      (( num = num + 1 ))

而且第二种形式更容易、更难忘，你可能不需要使用它。如果你确实使用它，请记住（与 BASIC 不同）每个数学表达式都应该作为引号中的一个参数出现。

**关联数组**\

剩下的一种主要参数类型是关联数组；如果你使用 Perl，你可能会称之为“哈希”，但我们倾向于不这样做，因为那实际上是对它如何实现的描述，而不是它做什么。（好吧，它做的是哈希。现在闭嘴。）

这些必须用 typeset 语句声明——没有别的办法。有一些相当不拘一格的内建命令会为你生成一个填充好的关联数组，但告诉 zsh 你想要你自己的关联数组的唯一方法是

      typeset -A assoc

来创建 `$assoc`。至于它做什么，最好用例子来展示：

      typeset -A assoc
      assoc=(one eins two zwei three drei)
      print ${assoc[two]}

它打印 ``zwei``。所以它的工作方式有点像一个普通数组，但普通数组中会出现在方括号内的数字*下标*被字符串*键*取代了，在这种情况下是 `two`。数组赋值有点欺骗性；“值”实际上是成对的，``one`` 是值 ``eins`` 的键，依此类推。如果这样的列表中有奇数个元素，shell 会抱怨。这可能也让你想起了 Perl。你可以一次赋一个值：

      assoc[four]=vier

也可以取消设置一个键/值对：

      unset 'assoc[one]'

这里的引号阻止了方括号在命令行上被解释为模式。

展开被推迟了，但你可能想知道如何取回你放进去的东西。如果你这样做

      print $assoc

你只会看到值——这与普通数组完全相同，其中下标 1、2、3 等不显示。注意它们的顺序是随机的——这是与普通数组的另一个主要区别；关联数组没有顺序的概念，除非你明确地对它们进行排序。

但在这里，键可能同样有趣。所以有：

      print ${(k)assoc}
      print ${(kv)assoc}

得到（如果你已经执行了上面所有的命令）：

      four two three
      four vier two zwei three drei

它打印出键而不是值，以及你输入的键和值对。你可以看到，虽然对的顺序不明显，但每次都是一样的。从这个例子中你可以得出如何将一个关联数组复制到另一个：

      typeset -A newass
      newass=(${(kv)assoc})

其中 ``(kv)`` 很重要——就像赋值前的 `typeset` 一样，否则 `$newass` 会是一个糟糕的普通数组。你也可以证明 ``${(v)assoc}`` 做了你可能期望的事情。还有很多其他的技巧，但它们大多与聪明的参数展开类型有关，将在[第五章](zshguide05.html#subst)中描述。

**其他 typeset 和类型技巧**\

`typeset` 有变体，上面零星提到了一些。没有任何一个能做 `typeset` 做不到的事情——情况并非总是如此；我们试图改进选项的正交性。它们在默认设置的选项和允许的附加选项上有所不同。这里有一个列表：`declare`、`export`、`float`、`integer`、`local`、`readonly`。我不会通过详细描述所有这些来迷惑你；请参阅手册。

如果有一个例外，那就是 `export`，它不仅标记一个参数以便导出，而且默认情况下打开了 `-g` 标志，因此该参数不是函数局部的；换句话说，它等同于 `typeset -gx`。然而，一个从选项不那么合乎逻辑的时代遗留下来的问题是，`typeset -x` 的行为像 `export`，换句话说，`-g` 标志默认是打开的。你可以通过取消设置 `GLOBAL_EXPORT` 选项来解决这个问题——该选项只为兼容性而存在；逻辑上它应该总是被取消设置。这部分是因为在过去你不能导出局部参数，所以 `typeset -x` 要么必须打开 `-g`，要么关闭 `-x`；这在 3.1.9 版本中得到了修复，并且（例如）``local -x`` 创建一个导出到环境的局部参数；参数本身和环境中的值都将在函数退出时恢复。内建命令 `local` 本质上是 `typeset` 的一种形式，它放弃了 `-g` 标志及其所有功能。

另一个已经消失的旧限制是，你不能让特殊参数，特别是 `$PATH`，成为函数局部；你只是修改了原始参数。现在如果你说 ``typeset PATH``，事情会像你可能期望的那样发生，`$PATH` 具有其通常的效果，并在函数退出时恢复其旧值。然而，由于 `$PATH` 仍然是特殊的，你应该确保在函数中调用外部命令之前给它赋一些值，否则它将为空，并且找不到任何命令。可能你特别不希望你创建的某个局部参数具有特殊属性；3.1.7 及更高版本允许 typeset 标志 `-h` 来隐藏该参数的特殊性，所以在 ``typeset -h PATH`` 中，`PATH` 在封闭函数期间将是一个普通变量。在内部，之前设置的相同值将继续用于查找命令，但它不会被导出。

我在上一章提到了另一个特殊的 typeset 选项：

      typeset -T TEXINPUTS texinputs

以与 `$PATH` 和 `$path` 工作相同的方式将标量 `$TEXINPUTS` 和数组 `$texinputs` 绑定在一起。这是一次性的；这是 `typeset` 在命令行上只接受两个参数名的唯一一次。所有其他 `typeset` 的用法都接受一个参数列表，任何给定的标志都应用于这些参数。有关其余标志，请参阅手册，尽管大多数更有趣的已经讨论过了。

关于标志，你需要知道的另一件事是，你用 ``+`` 符号来关闭相应的属性。所以

      typeset +r msg

允许你再次设置 `$msg`。从 `4.1` 版本开始，你将无法关闭特殊参数的只读属性；那是因为有太多的混淆空间，包括试图在代码中设置常量字符串。例如，``$ZSH_VERSION`` 总是打印一个固定的字符串；试图改变那是徒劳的。

`typeset` 的最后一个用途是列出参数。如果你只输入 ``typeset``，你会得到一个完整的参数及其值的列表。从 3.1.7 开始，你可以为一个参数打开 `-H` 标志，这意味着在这样做时隐藏它的值。这对于一些更庞大的参数可能很有用，特别是我将在[第七章](zshguide07.html#ragbag)关于模块的部分谈论的特殊参数，它们往往会淹没 `typeset` 产生的显示。

你也可以列出特定类型的参数，方法是列出你想知道的标志。例如，

      typeset -r

列出所有只读参数。你可能会期望 ``typeset +r`` 列出*没有*该属性的参数，但实际上它列出相同的参数，但不显示它们的值。``typeset +`` 以这种方式列出所有参数。

了解参数的另一种好方法是使用特殊扩展 ``${(t)*param*}``，例如

      print ${(t)PATH}

打印 ``scalar-export-special``：`$PATH` 是一个标量参数，设置了 `-x` 标志，并且对 shell 有特殊含义。实际上，“特殊”的含义比那多一点：它意味着获取和设置参数的内部代码的行为方式对参数本身或 shell 的其他地方有副作用。还有其他参数，比如 `$HISTFILE`，被 shell 使用，但以正常方式获取和设置——它们只是特殊在 shell 会查看其值；毕竟，任何旧的 shell 函数也可以做到这一点。与此形成对比的是 `$PATH`，它在设置时需要处理所有关于哈希命令的繁琐事务，正如我上面讨论的，我希望你能看到区别。

**读入参数**\

内建命令 ``read``，顾名思义，是 ``print`` 的反面（shell 中没有 ``write`` 命令，尽管通常有一个同名的外部命令用于向另一个用户发送消息），但读取与打印不同，需要 shell 中的某些东西改变以接受值，所以与 `print` 不同，`read` 被迫成为一个内建命令。不可避免地，值被读入一个参数。通常它们从标准输入中获取，通常是终端（即使你正在运行一个脚本，除非你重定向了输入）。所以最简单的情况就是

      read param

如果你输入一行，然后按回车，它将被放入 `$param`，不带最后的换行符。

`read` 内建命令实际上对输入做了一些处理。它通常会从读入的行中剥离任何初始或末尾的空白（空格或制表符），但中间的任何空白都会被保留。你可以通过列出要赋值的参数来读取一组由空白分隔的值；最后一个参数会得到该行的所有剩余部分，而不会被分割。通常最简单的方法是直接读入一个数组：

      % read -A array
            this is a line typed in now, \ 
          by me,    in this   space
      % print ${array[1]} ${array[12]}
      this space

（我假设你正在使用原生的 zsh 数组格式，而不是用 `KSH_ARRAYS` 设置的那个，并且将继续假设这一点。）

当你想要读取某些东西时，能够打印一个提示符是很有用的。你可以用 ``print -n`` 来做到这一点，但有一个简写：

      % read line'?请输入一行： '
      请输入一行： some words
      % print $line
      some words

注意引号包围了 ``?`` 以防止它在命令行上被当作模式的一部分。如果你喜欢，你可以从 ``line`` 的开头引用整个表达式；我只是那样写，因为我知道参数名不需要引用，因为它们不能有奇怪的字符。这几乎是合乎逻辑的。

`read` 的另一个有用技巧是读取单个字符；``-k`` 选项可以做到这一点，实际上你可以在 ``k`` 后面紧跟一个数字，指定要读取的数量。更容易的是，``-q`` 选项读取单个字符，如果是 `y` 或 `Y` 则返回状态 0，否则返回状态 1；因此你可以读取是/否问题的答案，而根本不使用参数。但是请注意，如果你不提供参数，回复无论如何都会被赋给 `$REPLY`（如果它是标量——就像 `-q` 的情况）或 `$reply`（如果它是数组——即如果你指定了 `-A`，但没有参数名）。这些是 shell 使用的非特殊参数的更多例子——它设置 `$REPLY` 或 `$reply`，但方式与你设置它们的方式相同；没有副作用。

像 `print` 一样，`read` 有一个用于原始模式的 `-r` 标志。然而，这对 `read` 只有一个效果：没有它，行尾的 ``\`` 指定下一行是当前行的延续（你可以在终端输入时这样做）。有了它，``\`` 不被特殊对待。

最后，一个关于分词的更复杂的说明。我说过，当你读取多个参数或一个数组时，单词会在空白处被分割。实际上，shell 会在 `$IFS`（代表“输入字段分隔符”）参数中找到的任何字符处分割单词，这个参数是真正特殊的，因为它影响 shell 的内部。默认情况下——并且在绝大多数用途中——它包含空格、制表符、换行符和一个空字符（字符零：如果你知道这些通常用于标记字符串的结尾，你可能会惊讶于 shell 将这些作为普通字符处理，但它确实如此，尽管打印它们通常不显示任何东西）。然而，你可以将它设置为任何字符串：输入

      fn() {
        local IFS=:
        read -A array
        print -l $array
      }
      fn

然后输入

    one word:two words:three words:four

Shell 会向你显示它读入的数组中的内容，每行一个“单词”：

      one word
      two words
      three words
      four

你会看到香蕉，呃，单词（三十岁以上的人的笑话）被视为由冒号分隔，而不是由空白分隔。在旧版本的 zsh 中，将 `$IFS` 设为局部变量不起作用，与其他特殊变量一样；你必须保存它并恢复它。

Zsh 中的 `read` 命令不允许你进行行编辑，而一些 shell 可以。为此，你应该使用 `vared` 命令，它运行行编辑器来编辑一个参数，使用 `-c` 选项，它允许 `vared` 创建一个新参数。它还接受 `-p` 选项来指定一个提示符，所以上面的一个例子可以重写为

      vared -c -p '请输入一行： ' line

它的工作方式很像 read，但有完整的编辑支持。如果你给出 `-h`（历史）选项，你甚至可以从以前的命令行中检索值。然而，它没有 read 的所有格式化选项，尽管在读取数组时（如果创建新数组，请与 `-c` 一起使用 `-a` 选项）它会执行分割。

**其他控制参数的内建命令**\

其余处理参数的内建命令可以更快地处理。

内建命令 `set` 只是设置作为参数传递给函数或脚本的特殊参数，你可以通过 `$*` 或 `$@`，或 `$<number>`（Bourne-like 格式），或通过 `$argv`（csh-like 格式）来访问，无论你如何设置它们，它们都被称为“位置参数”：

      % set a whole load of words
      % print $1
      a
      % print $*
      a whole load of words
      % print $argv[2,-2]
      whole load of

这完全就像你在一个函数中，并且用参数 ``a whole load of words`` 调用了该函数。实际上，set 也可以用来设置 shell 选项，无论是作为标志，例如 ``set -x``，还是在 ``-o`` 之后的单词，例如 ``set -o xtrace`` 与前一个例子做同样的事情。通常使用 `setopt` 更容易，结果是，当你以这种方式设置参数时，你需要小心，以防它们以 ``-`` 开头。在真实参数前放上 ``--`` 可以解决这个问题。

`set` 的另一个用途是通过

      set -A any_array words to assign to any_array

来设置任何数组，这等同于（并且是标准的 Korn shell 版本）

      any_array=(words to assign to any_array)

`set` 版本更有用的一个情况是，如果一个数组的名称本身来自一个参数：

      arrname=myarray
      set -A $arrname words to assign

在另一种形式中没有简单的等价物；普通赋值的左侧不会扩展一个参数：

      # 不起作用；语法错误
      $arrname=(words to assign)

这在旧版本的 zsh 中是可行的，但那是在非标准方面。`eval` 命令，下面会描述，提供了另一种解决这个问题的方法。

接下来是 ``shift``，它只是将一个数组向上移动一个元素，删除原来的第一个元素。没有数组名时，它作用于位置参数。你也可以在数组名前给它一个要移动的数字，而不是一。

      shift array

等同于

      array=(${array[2,-1]})

（几乎——我将把这里的微妙之处留给关于展开的章节）它选取数组的第二个到最后一个元素，并将它们赋回给原始数组。再次注意，`shift` 使用数组的*名称*而不是*值*来操作，所以前面不应该出现 ``$``，否则你会得到类似于我为 ``set -A`` 展示的技巧。

最后，`unset` 取消设置一个参数，我已经展示了你可以取消设置一个关联数组的键/值对。这里有一个需要提到的微妙之处。通常，`unset` 只是让命名的参数从地球上消失。然而，如果你在函数中调用 `unset`，它的幽灵会以这样的方式存在：你在同名中创建的任何参数都将具有与原始参数相同的作用域。因此：

      var='全局值'
      fn() {
        typeset var='局部值'
        unset var
        var='这个怎么样？'
      }
      fn
      print $var

最后的语句打印 ``全局值``：即使 `$var` 的局部副本被取消设置，shell 也会记住它是局部的，所以函数中的第二个 `$var` 也是局部的，它的值在函数结束时消失。

[]{#l38}

### 3.2.7: 历史控制命令

访问 shell 命令历史最简单的方法是直接编辑它。第二简单的方法是使用 ``!``-历史机制。其他操作它的方法都基于 `fc` 内建命令，它可能曾经代表什么（根据 Oliver Kiddle 的说法，是“修复命令”，这和任何东西一样好）。我在上一章已经谈了很多，真的没有什么要补充的了。只需注意，另外两个基于它的命令是 `history` 和 `r`。

[]{#l39}

### 3.2.8: 作业控制和进程控制

C-shell 的主要贡献之一是作业控制。你需要了解前台和后台任务，我在上一章连同控制它们的选项一起介绍了这些。这里是对相关内建命令的介绍。

你用两种方式启动一个后台作业。首先，直接地，通过在它后面放一个 ``&``：

      sleep 10 &

其次，通过以正常方式启动它（即在前台），然后输入 `^Z`，并使用 `bg` 命令将其放入后台。在输入 `^Z` 和 `bg` 之间，作业仍然存在，但没有运行；它被“挂起”或“停止”（系统对同一件事有不同的描述），等待你决定如何处理它。在任何一种情况下，作业然后继续，而 shell 不等待它。如果那是你启动它的方式，它仍然会尝试从终端读取或写入；如果你想改变这一点，你需要在作业已经启动后就无能为力了，你需要在开始时就使用 shell 的重定向功能。

顺便说句，``sleep`` 不是一个内建命令。奇怪的是，你可以用 `^Z` 挂起一个内建命令或命令序列（比如 shell 函数），尽管由于 shell 必须继续执行你的命令以及被挂起，它只能做它能做的事——分叉，这样你挂起的命令就被放入后台。可能你很少会对内建命令这样做。据我所知，没有其他 shell 有这个功能。

如果一个作业需要从终端读取，它会停止。你会看到一条像这样的消息：

      [1]  + 1348 suspended (tty input)  jobname and arguments

这意味着作业被挂起了，很像你刚刚输入了 `^Z`。你需要把作业带到前台，如下所述，这样你就可以给它输入一些东西。

顺便说句，用于挂起命令的键可能不是 `^Z`；通常是，但这可以改变。运行 ``stty -a`` 并查找 ``susp =`` 后面列出的内容——可能是，但不一定是 `^Z`。所以如果你想使用另一个字符——它必须是单个字符；这是在终端接口深处处理的，而不是在 shell 中——你可以运行

      stty susp '^]'

或者别的什么。你会从 `stty` 的输出中注意到，各种其他的作业控制字符也可以类似地改变。`stty` 命令是外部的，它的输出和输入格式在不同系统之间可能会有很大差异。

除了将命令放入后台，你还可以用 `fg` 将其再次带回前台。这对于暂时停止你正在做的事情以便你可以做别的事情很有用。如今你可能会在另一个窗口中这样做；在过去，当人们从简单的终端登录时，这更有用。一个典型的例子是

      more file                        # 查看文件
      ^Z                               # 挂起
      [1] + 8592 suspended  more file  # 打印的消息
      ...                              # 做别的事情
      fg %1                            # 恢复 `more`

``%`` 是引用作业的常用方式。它后面的数字是出现在挂起消息的方括号中的数字；我不知道为什么 shell 在那里也不用 ``%`` 表示法。你也会在将某物放入后台时的“继续”消息中看到它，以及在后台作业完成时告诉你它已完成的“完成”消息中再次看到它。``%`` 可以有其他形式；最常见的是在它后面跟一个命令的名称，比如在这种情况下是 ``%more``。形式 `%+` 和 `%-` 指的是最近和次近的作业——挂起消息中的 ``+`` 告诉你 `more` 作业可以那样被引用。

大多数作业控制命令实际上会假设你是在谈论 ``%+``，如果你不给参数的话，所以假设我没有在后台启动任何其他命令，我本可以在上面的命令序列的末尾只放一个 ``fg``。这实际上是双向的：`fg` 是对用 ``%`` 表示法引用的作业的默认操作，所以只输入 ``%1`` 而没有命令名也会起作用。

你可以用 ``jobs`` 命令来提醒自己正在发生什么。它看起来像一系列以方括号中的数字开头的消息；通常作业要么是“正在运行”要么是“已挂起”。这会告诉你需要的数字。

你可以对一个作业做的另一件有用的事是告诉 shell 忘记它。这只有在它已经在后台运行时才真正有用；然后你可以用作业标识符运行 ``disown``。这对于你想在注销后继续运行的作业，以及那些有自己的窗口因此你可以直接控制的作业很有用。对于被 disown 的作业，shell 在你注销时不会警告你它们还在那里。你实际上可以在启动后台作业时通过在行尾放上 ``&|`` 或 ``&!`` 而不是简单的 ``&`` 来 disown 它。请注意，如果作业在你 disown 它时被挂起，它将保持被 disown 的状态；这几乎没有意义，所以你可能应该先对它运行 ``bg``。

你最可能想对一个作业做的下一件事是杀死它，或者当它已经在后台并且你不能只输入 `^Z` 时挂起它。这就是 `kill` 内建命令的用武之地。这比上面提到的内建命令要复杂得多。首先，你可以对不是从当前 shell 启动的其他进程使用 `kill`。在这种情况下，你会用一个数字来标识它，没有 ``%``——这就是为什么在其他情况下有 ``%`` 的原因。当然，你需要找出这个数字；通常的方法是用 `ps` 命令，它不是一个内建命令，但出现在所有类 UNIX 系统上。作为一个愚蠢的例子，这里我启动一个做很少事情的被 disown 的进程，寻找它，然后杀死它：

      % sleep 60 &|
      % ps -f
      UID        PID  PPID  C STIME TTY          TIME CMD
      pws        623   614  0 22:12 pts/0    00:00:00 zsh
      pws       8613   623  0 23:12 pts/0    00:00:00 sleep 60
      pws       8615   623  0 23:12 pts/0    00:00:00 ps -f
      % kill 8613
      % ps -f
      UID        PID  PPID  C STIME TTY          TIME CMD
      pws        623   614  0 22:12 pts/0    00:00:00 zsh
      pws       8616   623  0 23:12 pts/0    00:00:00 ps -f

第二次我看时，进程已经消失了。注意，以通常的 UNIX 沉闷方式，shell 没有费心告诉你进程已经被杀死；然而，如果它发送信号失败，它会报告一个错误。发送信号是 shell 关心的全部；如果进程决定在被告知时不想死，shell 不会警告你，所以最好还是检查一下。

有时你想等待一个进程退出；`wait` 内建命令可以做到这一点，并且像 `kill` 一样，可以接受一个进程号以及一个作业号。然而，这有点欺骗性——你实际上不能等待一个不是直接从 shell 启动的进程。的确，等待的机制与 UNIX 处理进程的方式紧密相连；除非它的父进程等待它，否则一个进程会变成一个“僵尸”并徘徊，直到系统的养父，即“init”进程（总是进程号 1）等待它。这有点巴洛克风格，但对于 shell 用户来说，wait 只是意味着你可以坚持到你启动的某个东西完成。的确，这就是前台进程的工作方式：shell 实际上使用 `wait` 的内部版本来等待作业退出。（嗯，实际上那是个谎言；系统会从它正在做的任何事情中唤醒它，告诉它一个子进程已经完成，所以它所要做的就是打盹等待。）

此外，即使作业控制没有运行，你也可以等待一个进程。作业控制，基本上任何涉及那些 ``%`` 的东西，只有当你在终端上摆弄命令时才有用；当你运行脚本时，它不起作用。那时 shell 在如何控制其作业方面有更少的自由，但它仍然可以等待一个后台进程，并且如果它知道它的号码，它仍然可以对一个进程使用 `kill`。为此，shell 将最后一个在后台启动的进程的 ID 存储在参数 `$!` 中；``!`` 可能有一个很好的理由，但我不知道是什么。无论作业控制如何，这都会发生。

**信号**\

`kill` 命令能做的远不止杀死一个进程。那是默认操作，这就是为什么该命令有那个名字。但它真正做的是向一个进程发送一个“信号”。信号是与另一个进程通信的最简单方式；事实上，如果你没有为进程从你这里读取消息做特殊安排，它们是大约唯一的简单方式。信号名称写成 `SIGINT`、`SIGTSTP`、`SIGKILL`；要向一个进程发送一个特定的信号，你去掉 `SIG`，在前面加一个连字符，并将其用作 `kill` 的第一个参数，例如：

      kill -KILL 8613

你已经知道的一些事情实际上就是这样做的。当你输入 `^C` 来停止一个进程时，你实际上是在向它发送一个 `SIGINT`，代表“中断”，就好像你做了

      kill -INT 8613

`kill` 通常发送的信号不是，你可能猜到的，`SIGKILL`，而是 `SIGTERM`，代表“终止”；`SIGKILL` 更强，因为进程不能阻塞那个信号，而它可以对许多信号这样做（我们稍后会看到 shell 如何做到这一点）。它很熟悉