niri中有两种主要的坐标空间：物理坐标（每个输出的像素）和逻辑坐标（在所有输出之间共享，考虑每个输出的缩放）。Wayland客户端主要在逻辑空间中工作，这也是进行所有布局最方便的空间，因为它包含了输出缩放因子。

然而，许多东西需要在整数物理坐标处进行大小调整或定位。
例如，Wayland顶层缓冲区通常被假定放置在输出的整数物理像素上（`WaylandSurfaceRenderElement`会为您完成此操作）。
边框和焦点环的宽度也应该等于整数物理像素，以保持清晰（更不用说`SolidColorRenderElement`不会在分数像素位置进行线条抗锯齿）。

然而，整数物理坐标不一定对应整数逻辑坐标。
即使缩放倍数为整数2，物理坐标(1,1)处的像素将在逻辑位置(0.5, 0.5)处。
这个问题在使用分数缩放倍数时变得更糟，因为大多数整数逻辑坐标将落在分数物理坐标上。

因此，niri对大部分布局使用分数逻辑坐标。
然而，需要非常小心以使事物与物理网格对齐，以避免如以下的人工痕迹：

*   边框宽度交替1像素更粗/更细
*   边框在某些位置显示为与窗口偏离1像素
*   圆角周围的1像素间隙
*   调整大小期间窗口内容略微模糊
*   等等...

在niri中处理这个问题的方法是：

1.  工作区上所有相关大小都根据当前输出缩放四舍五入到整数物理坐标。如struts、间隙、边框宽度、工作区域位置。

    重要的是要理解，它们在逻辑空间中仍然保持分数数字，但这些数字对应于物理空间中的整数像素数。
    四舍五入看起来像这样：`(logical_size * scale).round() / scale`。
    每当工作区移动到具有不同缩放的输出时（或输出缩放更改），所有大小都从其原始配置值重新四舍五入，以与新物理空间对齐。
2.  视图偏移和单个列/平铺渲染偏移*不*四舍五入到物理像素，但是：
3.  `tiles_with_render_positions()`在返回时将平铺位置四舍五入到物理像素，
4.  诸如打开、关闭和调整窗口大小的自定义着色器，也小心保持位置和大小四舍五入到物理像素。

其想法是每个平铺可以假设它在整数物理坐标处渲染，因此当按边框宽度（也四舍五入到整数物理坐标）移动位置时，新位置将保持四舍五入到整数物理坐标。
由于间隙、struts和工作区域也以类似方式四舍五入，其余布局的逻辑相同。
这样，只要布局在整数物理坐标处定位（将平铺位置四舍五入可有效实现），整个布局始终对齐。