> *Freeman博士，是时候了吗？真的又是...那个时间了吗？*

合成器处理一个或多个显示器上基本固定的刷新周期。
例如，170 Hz的显示器每~5.88毫秒可以绘制一帧。

大多数时候，合成器实际上并不重绘显示器：当屏幕上没有变化时（例如您正在阅读文档且没有移动光标），唤醒GPU来合成相同的图像是浪费的。
然而，在动画期间，屏幕内容在每一帧都会变化。
niri通常会在上一帧显示在屏幕上时立即开始绘制下一帧。

由于显示器刷新周期在大多数情况下是固定的（即使使用VRR，也有最大刷新率），合成器可以预测下一帧何时会显示在显示器上，并为那个确切的时间点渲染正在进行的动画。
这样，所有动画帧都与无抖动完美同步，无论渲染代码何时运行。
例如，即使合成器必须处理新的窗口事件，延迟渲染几毫秒，动画时序仍将完全与显示器刷新周期对齐。

因此，合成器对其时序系统有几个属性要求。

1.  应该能够在不久的将来特定时间获取动画状态，以精确渲染与显示器显示时间对齐的帧。
    *   这种时间覆盖能力应在测试中可用，以完全控制的方式推进时间。
2.  响应用户操作的动画应在操作发生时开始。
    例如，按下工作区切换键应在用户按下键的瞬间开始动画（而不是在我们预测的未来某个时间点，那时我们已经渲染了下一个显示器帧）。
3.  在处理单个操作期间，查询当前时间应返回完全相同的值。
    即使处理在开始后几微秒完成，结束时查询时间应返回相同的内容。
    这通常使编写代码更加合理；否则您需要避免连续两次读取某些元素的位置，因为它可能在两者之间移动了一个像素，破坏逻辑。
    此外，获取当前系统时间[可能相当昂贵](https://mastodon.online/@YaLTeR/109934977035721850)。
4.  应该相对容易实现动画减速偏好，以便所有动画可以按相同因子减速或加速。

niri中的解决方案是`LazyClock`，一个记住一个时间戳的时钟。
最初，时间戳是空的，所以当您询问`LazyClock`当前时间时，它会获取并返回系统时间，并记住它。
随后，它将继续返回它记住的相同时间戳。

您也可以清除时间戳，然后`LazyClock`在需要时将重新获取系统时间。
在niri中，时间戳在每次事件循环迭代结束时清除，就在进入睡眠等待新事件之前。
这样，接下来发生的任何事情（如用户按键）将在需要时获取和使用最新的时间戳，但然后处理代码将继续获取完全相同的时间戳，因为`LazyClock`存储它。

您也可以手动将时间戳设置为特定值。
这就是我们为显示器显示时间预测渲染帧的方式。
此外，测试中也使用此功能：它们只需始终设置时间戳，从不使用系统时间。

最后，还有一个`AdjustableClock`包装器，提供通过修改时钟返回的时间戳来控制减速率的能力。

一个重要细节是，使用速率变化时，来自`AdjustableClock`的时间戳将偏离并与系统时间无关。
然而，我们的目标时间戳（用于渲染）来自系统时间，因此覆盖直接作用于底层的`LazyClock`。
也就是说，覆盖时间戳然后查询`AdjustableClock`将返回一个*不同*的时间戳，该时间戳与`AdjustableClock`所做的调整保持一致。
这反映在API中，函数名为`Clock::set_unadjusted()`（还有`Clock::now_unadjusted()`来获取原始时间戳）。

时钟在niri中的所有动画之间共享，通过传递和存储引用计数指针。
这样，覆盖时间自动应用于所有内容，而在测试中我们可以为每个测试使用单独的时钟，使它们不相互干扰。