这些是niri窗口布局设计的一些通用原则。
如果有充分的理由，可以在特定情况下绕过这些原则。

1.  打开新窗口不应影响任何现有窗口的大小。
2.  聚焦窗口不应自主移动。
    *   特别是：聚焦窗口左侧的窗口打开、关闭和调整大小不应导致它视觉上移动。
3.  操作应立即生效。
    *   像调整大小或合并到列中的操作会立即生效，即使窗口需要时间跟上。
    *   这对于合成器的响应性和可预测性都很重要，并且有助于保持代码合理，避免边缘情况和不必要的异步性。
4.  如果窗口或弹出窗口大于屏幕，应将其对齐到左上角。
    *   窗口的左上角区域更可能包含重要信息，因此应始终可见。
5.  将窗口宽度或高度设置为固定像素大小（例如`set-column-width 1280`或`default-column-width { fixed 1280; }`）将设置窗口本身的大小，但是设置比例大小（例如`set-column-width 50%`）将设置平铺的大小，包括niri添加的边框。
    *   使用比例时，用户希望在屏幕上平铺多个窗口，所以它们应包含边框。
    *   使用固定大小时，用户希望测试特定客户端大小或拍摄特定大小的截图，所以它们应直接影响窗口。
    *   设置大小后，它总是转换为包含边框的值，以使代码合理。即，`set-column-width 1000`后更改niri边框宽度将相应调整窗口大小。

以下是我试图在整个niri中遵循的一些更多原则。

1.  禁用时，视觉效果功能不应影响性能。
    *   像动画和自定义着色器在禁用时不运行，在渲染树中不存在。避免额外的离屏渲染。
    *   动画即使在禁用时也仍然"启动"，但持续时间为0（这样，它们在时间推进时立即结束）。这不会影响性能，但有助于避免代码中的大量边缘情况。
2.  视觉效果功能不应导致不合理的过度渲染。
    *   例如，clip-to-geometry在许多情况下会阻止直接扫描输出（因为窗口表面不是完全可见的）。但在表面或子表面*完全*可见（完全在裁剪区域内）的情况下，它仍将允许直接扫描输出。
    *   例如，动画*可以*每帧造成损坏，甚至绘制到离屏，因为它们预计是短暂的（可以禁用）。然而，像圆角着色器这样的东西不应离屏或每帧造成过度损坏，因为它运行时间长且持续活动。
3.  注意不可见状态。

    这是niri状态，从屏幕上看不到。这本身并不坏，但您应仔细考虑如何减少意外因素。

    *   例如，当显示器断开连接时，其所有工作区移动到另一个连接的显示器。为了能够在第一个显示器重新连接时恢复这些工作区，这些工作区保留了哪个是它们的*原始显示器*的知识——这是不可见状态的一个例子，因为您无法通过查看屏幕来分辨它。这可能有令人惊讶的后果：想象在家中断开显示器，去工作，完全重新排列那里的窗口，然后回家，突然一些随机工作区出现在您的家庭显示器上。为了减少这种意外因素，每当工作区上出现新窗口时，该工作区将其*原始显示器*重置为其当前显示器。这样，您积极工作的工区保持在原地。
    *   例如，niri在窗口出现或窗口全屏时保留视图位置，以在之后恢复它。这样，处理临时事物如对话框的打开和关闭，或切换全屏，变得不那么烦人，因为它不会弄乱视图位置。这也是不可见状态，因为您无法通过查看屏幕来分辨关闭窗口将恢复视图位置。如果推向极端（为每个打开的窗口永远保存以前的视图位置），这可能令人惊讶，因为关闭长时间运行的窗口会导致视图随机移动。为了减少这种意外因素，niri只记住每个工作区的一个最后视图位置，并在窗口焦点更改时忘记此存储的视图位置。