## 通用原则

这些是我在整个niri中试图遵循的一些通用原则。
如果有充分的理由，可以在特定情况下绕过这些原则。

### 打开新窗口不应影响任何现有窗口的大小。

这是传统平铺的主要烦恼：您想打开一个新窗口，但它会弄乱您现有的窗口大小。
特别是当您正在查看像浏览器或图像编辑器这样的大窗口时，想要快速打开一个终端，它会使大窗口变得无法使用，或重新排列内容，或裁剪窗口的一部分。

平铺WM中的常见解决方法是使用更多工作区：当您需要一个新窗口时，您转到一个空工作区并在那里打开它（这样，您还可以获得整个屏幕给新窗口，而不是它的一小部分）。

可滚动平铺提供了另一种选择：对于临时窗口，您只需打开它们，做您需要的事情，然后关闭，所有这些都不会弄乱其他窗口或必须转到新工作区。
它还通过将不常用的窗口滚动出视图，让您在同一工作区上组合更多相关的窗口。

### 聚焦窗口不应自主移动。

特别是：聚焦窗口左侧的窗口打开、关闭和调整大小不应导致它视觉上移动。

聚焦窗口是您正在工作的窗口。
视图外发生的事情不应弄乱您聚焦的内容。

### 操作应立即生效。

这对于合成器的响应性和可预测性都很重要，并且有助于保持代码合理，避免边缘情况和不必要的异步性。

*   像调整大小或合并到列中的操作会立即生效，即使窗口需要时间跟上。
*   动画工作区切换使您的输入立即转到最终工作区和窗口，无需等待动画。
*   打开概览（具有缩小动画）让您立即抓取窗口，关闭概览使您的输入立即回到窗口，无需等待放大。

### 禁用时，视觉效果功能不应影响性能。

像动画和自定义着色器在禁用时不运行，在渲染树中不存在。
避免额外的离屏渲染。

动画即使在禁用时也仍然"启动"，但持续时间为0（这样，它们在时间推进时立即结束）。
这不会影响性能，但有助于避免代码中的大量边缘情况。

### 视觉效果功能不应导致不合理的过度渲染。

*   例如，clip-to-geometry在许多情况下会阻止直接扫描输出（因为窗口表面不是完全可见的）。但在表面或子表面*完全*可见（完全在裁剪区域内）的情况下，它仍将允许直接扫描输出。
*   例如，动画*可以*每帧造成损坏，甚至绘制到离屏，因为它们预计是短暂的（可以禁用）。然而，像圆角着色器这样的东西不应离屏或每帧造成过度损坏，因为它运行时间长且持续活动。

### 注意不可见状态。

这是niri状态，从屏幕上看不到。这本身并不坏，但您应仔细考虑如何减少意外因素。

*   例如，当显示器断开连接时，其所有工作区移动到另一个连接的显示器。为了能够在第一个显示器重新连接时恢复这些工作区，这些工作区保留了哪个是它们的*原始显示器*的知识——这是不可见状态的一个例子，因为您无法通过查看屏幕来分辨它。这可能有令人惊讶的后果：想象在家中断开显示器，去工作，完全重新排列那里的窗口，然后回家，突然一些随机工作区出现在您的家庭显示器上。为了减少这种意外因素，每当工作区上出现新窗口时，该工作区将其*原始显示器*重置为其当前显示器。这样，您积极工作的工区保持在原地。
*   例如，niri在窗口出现或窗口全屏时保留视图位置，以在之后恢复它。这样，处理临时事物如对话框的打开和关闭，或切换全屏，变得不那么烦人，因为它不会弄乱视图位置。这也是不可见状态，因为您无法通过查看屏幕来分辨关闭窗口将恢复视图位置。如果推向极端（为每个打开的窗口永远保存以前的视图位置），这可能令人惊讶，因为关闭长时间运行的窗口会导致视图随机移动。为了减少这种意外因素，niri只记住每个工作区的一个最后视图位置，并在窗口焦点更改时忘记此存储的视图位置。

## 窗口布局

以下是窗口布局逻辑的一些设计考虑。

1.  如果窗口或弹出窗口大于屏幕，应将其对齐到左上角。

    窗口的左上角区域更可能包含重要信息，因此应始终可见。

2.  将窗口宽度或高度设置为固定像素大小（例如`set-column-width 1280`或`default-column-width { fixed 1280; }`）将设置窗口本身的大小，但是设置比例大小（例如`set-column-width 50%`）将设置平铺的大小，包括niri添加的边框。

    *   使用比例时，用户希望在屏幕上平铺多个窗口，所以它们应包含边框。
    *   使用固定大小时，用户希望测试特定客户端大小或拍摄特定大小的截图，所以它们应直接影响窗口。
    *   设置大小后，它总是转换为包含边框的值，以使代码合理。即，`set-column-width 1000`后更改niri边框宽度将相应调整窗口大小。

3.  全屏窗口是滚动布局的正常部分。

    这是一个很酷的想法，只有可滚动平铺才能实现。
    全屏窗口不在覆盖一切的"特殊"层上；相反，它们是您可以切换离开的普通平铺，而不会干扰全屏状态。

    当然，当聚焦在全屏窗口上时，您确实希望覆盖整个显示器。
    这专门硬编码到逻辑中：当视图在聚焦的全屏窗口上静止时，顶层shell层和浮动窗口会隐藏。

    这也是为什么将浮动窗口全屏化会使其进入滚动布局。

## 默认配置

[默认配置](https://github.com/YaLTeR/niri/blob/main/resources/default-config.kdl)旨在为新niri用户提供熟悉、有帮助且不会太令人震惊的体验。
重要的是，它不是"建议的美化配置"；我们不想用全彩虹边框和疯狂的着色器来吓到人们。

由于我们不是一个完整的桌面环境（也没有成为桌面环境的贡献者基础），我们无法提供完全集成的体验——发行版变体更适合这样做。
因此，新niri用户被期望通读并调整默认的niri配置。

因此，默认配置用相关wiki部分的链接进行了彻底注释。
我们不会在默认配置中包含每个可能的选项，以避免过度压倒用户；任何过于具体或不常见的内容可以留在wiki上。
一般规则是包含用户合理期望想要更改或知道如何做的事情。
我们也确实宣传了我们更独特的功能，如屏幕录制block-out-from。

我们默认使用CSD（`prefer-no-csd`被注释掉）。
这为新用户提供了通过标题栏移动和关闭窗口的简单熟悉方式，特别是考虑到niri目前没有服务器端标题栏（至少目前没有）。

默认情况下，焦点环完全在窗口后面绘制。
虽然这不幸地会影响窗口透明度，[这是常见的困惑来源](./FAQ#why-are-transparent-windows-tinted-why-is-the-borderfocus-ring-showing-up-through-semitransparent-windows)，但默认只在窗口周围绘制焦点环会更糟，因为它在客户端圆角内有孔洞。
这里的理想解决方案是为窗口向合成器报告其圆角半径提出Wayland协议（这通常有助于不同合成器中的服务器端装饰）。

默认焦点环相当厚，为4 px，以与客户端装饰的窗口很好地配合并明显可见，而默认间距也相当大，为16 px，以与默认焦点环宽度很好地配合。

默认输入设置如触摸板轻触和自然滚动是我认为大多数人想要使用计算机的方式。

阴影默认关闭，因为它们是相当性能密集的着色器，并且因为许多客户端装饰的窗口已经绘制了它们自己的阴影。

默认截图路径与GNOME Shell匹配。

默认窗口规则仅限于修复已知的严重问题（WezTerm）和做大多数人可能想要的事情（使Firefox画中画播放器浮动——它目前无法自己做到这一点，也许pip协议会改变这一点）。

默认绑定主要来自我使用PaperWM的经验，以及其他合成器的经验。
它们假设QWERTY布局。
绑定以一种逐渐向您介绍不同绑定配置概念的方式排序。

一般系统是：如果热键切换到某处，那么添加<kbd>Ctrl</kbd>会将聚焦窗口或列移动到那里。
添加<kbd>Shift</kbd>执行替代操作：对于焦点和移动，它开始跨显示器移动，对于调整大小，它开始作用于窗口高度而不是宽度等。
工作区切换在<kbd>Mod</kbd><kbd>U</kbd>/<kbd>I</kbd>上，比用于窗口切换的<kbd>Mod</kbd><kbd>J</kbd>/<kbd>K</kbd>上移一个键。

由于<kbd>Alt</kbd>是嵌套niri中的修饰符，具有明确<kbd>Alt</kbd>的绑定主要是仅在主机上有用的绑定，例如生成屏幕锁。