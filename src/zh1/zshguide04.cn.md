------------------------------------------------------------------------

-   [目录](zshguide.html)
-   [上一章](zshguide03.html)
-   [下一章](zshguide05.html)

------------------------------------------------------------------------

[]{#zle}[]{#l75}

# 第四章：Z-Shell 行编辑器

Zsh 行编辑器可能是你开始输入命令时最早使用的 shell 部分。即使是最基本的 shell，如 sh，也提供某种编辑能力，尽管在这种情况下可能只是系统本身的功能——输入字符、删除最后一个字符、删除整行。如今你可能使用的大多数 shell 功能都远不止于此。使用 zsh，你甚至可以使用 shell 函数来扩展编辑器命令集。

[]{#l76}

## 4.1: zle 介绍

Zsh 行编辑器通常缩写为 `zle`。通常它会为任何交互式 shell 自行启动；在你决定需要改变其行为之前，你不需要做任何特别的事情。如果一切看起来正常，并且你对 zle 是如何启动的不感兴趣，请跳到下一小节。

如今，zle 存在于其自己的可加载模块 `zsh/zle` 中，这节省了在 shell 非交互式时拥有编辑器的所有开销。然而，你通常不需要担心这个；我将在[第七章](zshguide07.html#ragbag)中更多地讨论模块，但 shell 知道你何时需要 zle 并会自动提供给你。通常模块位于一个名为 `/usr/local/lib/zsh/4.0.4/zsh/zle.so` 的目录中，其中 `4.0.4` 是 shell 的版本号，与参数 `$ZSH_VERSION` 的值相同，之后除了后缀 `.so` 之外的所有内容都是模块名。后缀可能是 `.sl` (HP-UX) 或 `.dll` (Cygwin)，但 `.so` 是迄今为止最常见的形式。它之所以不同，是因为 zsh 对动态可加载库，或 UNIX 术语中的“共享对象”，保持与操作系统相同的约定。

如果 shell 安装不当，你有时会看到错误消息，说它或像 `bindkey` 这样的命令无法加载。这意味着 shell 在模块加载路径，即数组 `$module_path` 中，任何地方都找不到 `zsh/zle`。那么你需要向你的系统管理员投诉。如果你刚刚编译了 zsh 并遇到这个问题，那是因为你必须在运行 shell 之前安装模块，即使 shell 本身没有安装。你可以通过说 `make install.modules` 来做到这一点。然后编译好的 zsh 应该可以从它所在的位置运行。

请注意，与 bash 的行编辑器 readline（一个完全独立的库）不同，zle 是 shell 的一个组成部分。因此，你通过在你的 `.zshrc` 中添加命令来配置它——因为它只对交互式 shell 有用，所以只有 `/etc/zshrc` 和 `.zshrc` 对此有意义。

如果你正在使用 info 查看 zsh 手册，无论是用同名命令还是在 Emacs 中用 `C-h i`，我发现这是最方便的方式：zle 的条目被称为 `Zsh Line Editor`，全称，而不仅仅是 `Zle`。顺便说一句，祝你在寻找 `Shell Builtin Commands`（而不是 `Builtins`）时玩得开心。

[]{#l77}

### 4.1.1: 简单事实

与 `ed` 之后的任何编辑器一样，你可以使用各种“按键”，即一次输入的一个或多个键集，在行上移动和更改它。例如，向后移动一个单词的按键是（也许是）`ESC b`。这意味着你首先按 escape 键；此时什么也没发生。然后你按 `b`，光标立即跳回到单词的开头。（关于 zle 认为什么是“单词”，我还有更多要说的——它不一定与 shell 其余部分认为的单词相同。）

如果我马上介绍 shell 描述按键的方式，可能会有所帮助；然后当你需要输入它们时，你可以直接复制它们。Escape 键是 `\e`，所以那个按键将是 `\eb`。其他常见的按键包括按住 control 键，可能在键盘左下角，同时输入另一个键。指示一个 control 键最简单的方法是在前面放一个 `^`；所以例如 `^x^x` 意味着按住 control，并在 control 仍然按住的情况下按两次 `x`。它的效果与 `^X^X` 完全相同。（你可能会发现每次这样做时，它都会带你到行的开头，然后回到你原来的位置。）

我已经引入了“也许”这个含糊的词来试图避免撒谎。这是因为实际上 zle 有两种操作模式，一种（默认的）像 Emacs，另一种像 vi。如果你不知道这两个古老的 UNIX 编辑器中的任何一个，我建议你坚持使用 Emacs 模式，因为它对你正在做的事情的干扰要小一些，而且补全也更容易一些。补全是从 zle 行为中派生出来的一个分支，将在[第六章](zshguide06.html#comp)中描述（你会注意到，那一章比这一章长）。

如果你通常使用 vi，你可能将环境变量 `$EDITOR` 或 `$VISUAL` 中的一个或两个设置为 `vi`。（如果你使用 `vim`，或者任何碰巧包含 `vi` 的编辑器，比如 `elvis`，它的工作方式完全相同。）在这种情况下，zle 将以其“vi”模式启动，其中的按键完全不同。这就是为什么你可能会发现 `\eb` 没有像我说的那样工作，即使你没有尝试配置 zle。你可以通过在你的 `.zshrc` 中放入以下任一命令来让 zle 始终使用 emacs 或 vi 模式：

      bindkey -e

或

      bindkey -v

这只是 `bindkey` 的众多用途之一。

如果你不熟悉“绑定”这个词的用法，它只是意味着“让一个按键执行一个特定的编辑器命令”。命令有带连字符的长名称，它们很好地描述了它们做什么，比如 `backward-delete-char`。对应于可打印字符的普通键通常“绑定到 `self-insert`”，这是一种反常的说法，意思是它们做你期望的事情，并显示你输入的字符。然而，你实际上可以把它们绑定到别的东西上。在 vi 命令模式下，这是完全正常的。

实际上，如果你使用窗口系统，你可能想说 `bindkey -me`，它绑定了一整套“meta”键。在 X Windows 中，你键盘上的一个键，可能是 `ALT`，可能被指定为一个“meta”键，它具有类似于 control 键的特殊效果。按住 meta 键的绑定描述有点像它们在 Emacs 中的样子，`\M-b`。（实际上，你可以类似地指定 control 键，比如 `\C-x`，但 `^x` 更短。）使用 `bindkey` 的 `-m` 选项告诉 zsh，无论它在哪里绑定一个像 `\eb` 这样的转义序列，它也应该绑定相应的像 `\M-b` 这样的 meta 序列。Emacs 总是把这些绑在一起，但 zsh 不会——你可以分别重新绑定它们，如果你想让两个序列都绑定到一个新命令，你必须明确地绑定它们两个。

然而，你需要小心使用 `bindkey -m`；shell 无法判断你是在输入一个最高位被设置的字符，还是在执行一个命令。随着用于字符的 UTF-8 编码变得越来越流行，这可能会变得更糟，因为一个非 ASCII 字符那时由一整串最高位被设置的字节组成。

如果你对绑定功能键感兴趣，你可能已经发现它们发送的键序列显然没有任何意义；更多信息请参见[下面的部分](zshguide04.html#fkeys)。这将介绍名为 `zkbd` 的函数，它可以使这个过程不那么痛苦。该函数也对“meta”和“ALT”键有帮助。

[]{#l78}

### 4.1.2: Vi 模式

我将专注于 Emacs 模式，原因有几个：首先，因为我自己使用它；其次，因为你使用 vi 模式最可能的原因是你已经熟悉 vi，不需要被告知它如何工作；第三，因为大多数命令在两种模式下都是相同的，只是绑定不同；最后，因为如果你*不*已经知道 vi，你很可能会发现 vi 编辑模式相当不直观且难以使用。

然而，这里有一些关于它的评论，只是为了把它讲完。就像真正的 vi 编辑器一样，有两种基本模式，插入模式，你在其中输入文本，和命令模式，在其中插入字符的相同按键被绑定到编辑命令。与真正的 vi 不同，行编辑器在你编辑的每个新命令上都以插入模式启动。这意味着你通常可以简单地输入一行直到最后的“回车”，而忘记你正处于 vi 模式。

要进入命令模式，你按“escape”，再次像普通的 vi 一样。此时你处于 vi 命令的魔法世界，输入一个普通字符可以产生任何效果。然而，绑定与普通的 vi 相似，所以 `h` 和 `l` 向左和向右移动。当你想插入更多文本时，你可以使用任何允许你这样做的普通 vi 命令，比如 `i` (`vi-insert`) 或 `a` (`vi-add-next`)。

除了独立的命令和插入模式以及完全不同的键绑定集之外，Emacs 模式和 vi 模式之间没有基本区别。你可以在两种 vi 模式中都绑定键——它们*不必*在插入模式下对应于 `self-insert`。下面，我将描述“键映射”，这是一套完整的关于所有键将做什么的描述（听起来比实际的要令人印象深刻，因为很多键可能被设置为“undefined-key”，这意味着它们不做任何有用的事情），你将看到如何改变两种模式下的行为。

[]{#l79}

## 4.2: 基本编辑

如果你了解 Emacs 或 vi，你很快就会发现如何做一些简单的命令，比如移动光标、在历史列表中上下移动、删除和复制单词。如果你不了解，你应该阅读 `zshzle` 手册页，以简明地了解它能做什么。这里是 Emacs 模式的摘要。

[]{#l80}

### 4.2.1: 移动

你可以使用光标键在行上向前和向后移动。关于光标键产生什么按键序列，有各种不同的约定。你可能天真地期望按，比如说，右光标键，会发送一个类似于“右光标”的信号给应用程序。不幸的是，ASCII 字符集中没有这样的字符，所以像 zsh 这样将输入作为字符流读取的程序必须被给予一个任意的字符串。 （对于理解其他输入形式的程序，比如窗口系统，情况就不同了。）

光标键最常见的两种约定是，向上键发送 `\e[A`，其他三个键在末尾分别发送 `B`、`C` 和 `D`，以及用 `O`（大写字母 `O`）替换 `[` 的约定。在旧版本的 zsh 中，只支持这两种约定中的第一种。第二种以及任何其他约定都不被支持，你必须自己绑定键。这是通过类似以下的方式完成的：

      bindkey "\eOA" up-line-or-history
      bindkey "\eOB" down-line-or-history
      bindkey "\eOC" forward-char
      bindkey "\eOD" backward-char

现在 shell 更加努力了，只要你的系统有关于你的终端的正确信息（zsh 使用一个名为“termcap”的旧系统，它在很大程度上已被另一个名为“terminfo”的系统所取代），你应该会很幸运。如果 shell 认为你的键太反常——特别是，如果它想要绑定函数的按键序列已经被 zsh 定义了——你仍然需要手动操作。上面的列表应该可以作为一个模板。

除了光标键，传统的 Emacs 键也可用：`^b` 和 `^f` 用于向后和向前，`^p` 和 `^n` 用于上一行和下一行，所以即使光标键不工作，你也可以继续。

移动更长的距离是通过 `\eb` 和 `\ef` 向后或向前移动一个单词（或者，如你所见，`\M-b` 和 `\M-f`），以及 `^a` 和 `^e` 用于行的开始和结束。这差不多就是你最常使用的那些了。

[]{#l81}

### 4.2.2: 删除

对于删除，退格键或删除键会向后删除。由于 PC 键盘上中央键盘区左上角的键是“退格”，即字符 `^h`，而传统 UNIX 键盘上是“删除”，即字符 127，通常写为 `^?`（zsh 也理解），这两个键之间存在着永恒的争论。当你在系统的原始行编辑模式下时，就像 sh（除非你的 sh 实际上是 bash），只有一个是“绑定”的，尽管它不是真正的键绑定，而是由系统的终端驱动程序进行的转换，而且通常是错误的一个。因此你经常发现系统在你想要删除时在屏幕上打印 `^h`。你可以用

      stty erase '^h'

来更改键，但 zsh 保护你免受所有这些——`^h`（退格）和 `^?`（删除）都会向后删除一个字符。顺便说一句，请注意，zsh 不理解任何按键的智能名称——如果你尝试绑定一个名为“backspace”的键，zsh 会将一个命令绑定到该字符序列，而不是该名称的键。请参阅关于 `bindkey -s` 的评论，了解什么时候这样做甚至可能有用。

更令人困惑的是，在 101 或 102 键 PC 键盘上，通常标记为“Delete”的键，在光标键上方的 6 个键组中，又完全不同，并且可能不发送这两个序列中的任何一个。在我的键盘上，它发送序列 `\e[3~`。我发现让它删除下一个字符很方便，这是它在 PC 世界中的传统角色，我通过

      bindkey '\e[3~' delete-char

来做到这一点。然而，删除下一个字符的传统 *Emacs* 方式是使用 `^d`，zsh 默认为你绑定了它。如果你查看绑定，你可以通过不给 bindkey 一个要绑定的编辑器命令来做到这一点，

      % bindkey '^d'
      delete-char-or-list

你会看到它*不完全*像我建议的那样。`-or-list` 部分是用于补全的，你将在下一章中了解它。我所知道的第一个有这种奇怪组合的 shell 是 tcsh。

既然我喜欢混淆，我不如指出，通常 `^d` 还有另一个用途，那就是告诉终端驱动程序你已经到达了文件的末尾。在，比如说，磁盘上的文件的情况下，系统自己知道这一点，但如果你正在提供一个字符流，告诉它的唯一方法是发送一个特殊字符。默认通常是 `^d`。你会注意到，如果你在行的开头输入 `^d`，你会看到消息

      zsh: use 'exit' to exit.

那是因为 zsh 在那个位置将 `^d` 识别为文件结束。默认情况下，shell 会警告你；你可以通过设置 `IGNORE_EOF` 选项来关闭它。你可以告诉系统你永远不想以这种方式发送文件结束，再次使用 `stty`：以下在 Linux 中是等效的，但你的系统可能需要其中一个或另一个：

      stty eof '^-'
      stty eof undef

记住 `stty` 不是 shell 的一部分；它是控制系统终端驱动程序状态的一种方式。这意味着只要终端或终端窗口仍然连接，它就会一直存在，即使你启动一个新的 shell 或退出一个不是登录 shell 的 shell。

顺便说一句，如果你需要通过其编号来引用一个字符，最简单的方法可能是使用语法 `\x??`，其中 `??` 是键的两个十六进制数字。在删除的情况下，它是 `\x7f`。你可以通过以下方式确认：

      % bindkey '\x7f'
      "^?" backward-delete-char

[]{#l82}

### 4.2.3: 更多删除操作

你可以用 `\ed` 删除下一个单词，用 `\e^h` 或 `\e^?`（escape 后跟向后删除）删除前一个单词。`^u` 通常会删除整行，光标前后都删除——这不像 Emacs，在 Emacs 中 `^u` 引入数字参数，我将在下一小节中描述。然而，它像终端驱动程序本身提供的另一个原始编辑命令，这个命令在 `stty` 中被称为 `kill`。在 zsh 之外，这个最常见的用途是在登录时删除你的密码，当你确定你输错了但又看不到你输了多少个 !@?*! 字符，并且可能无法依赖终端与你在哪个 `^h` 或 `^?` 会删除单个字符上达成一致时。

严格来说，上一段中的所有按键都执行“kill”（zsh 术语，不要与 `stty` 的“kill”混淆）而不是“delete”（或 deletion，当我们对名词化和动词化有区别时我们过去常说）。区别与 Emacs 中相同——“killed”的文本被保存起来以便以后“yank”回别处，你用 `^y` 键来做，而像 `^?` 和 `^d` 那样“deleted”的文本则永远消失了。这就是所有没有在 Emacs 下长大的人称之为“剪切”和“粘贴”的东西（尽管由于 Emacs 可以追溯到七十年代，也可能是其他所有人都错了）。从 Emacs 借来的另一个特性是，如果你在中间没有任何其他编辑的情况下进行多次“kill”，被 kill 的文本会连接在一起，你可以一次性将它们全部 yank 回来。当我谈到点和标记（另一个 Emacs 的想法）时，我会说更多。

实际上，即使是删除的文本也不会永远消失：zsh 有一个类似 Emacs 的编辑历史，你可以撤销行上的前一个命令。这通常绑定到 `^xu` 和 `^x^u`，还有一个更短的绑定，被相当令人困惑地描述为 `^_`——令人困惑，因为在我用过的所有不完全奇怪的键盘上，你实际上是通过按住 control 并按 `/` 键来生成该序列的。Zsh 默认不使用 `^z`，如果你习惯于 Windows，那是 `undo` 的另一个合适的绑定。

Zsh 在一个方面胜过 Emacs——它也有“redo”，默认未绑定。这意味着如果你撤销得太多，你可以通过重复使用 `redo` 命令来放回你刚刚撤销的东西。

[]{#l83}

## 4.3: 更高级的编辑

[]{#l84}

### 4.3.1: 控制 zle 的选项

与补全不同，`zle` 没有很多与之关联的选项；大多数控制是通过键绑定和内建命令完成的。只有两个真正有用；都控制哔哔声。`beep` 选项可以被取消设置，以告诉 shell 在出错时永远不要发出声音；`histbeep` 选项可以被取消设置，以仅在尝试返回到第一个历史条目之前或前进到最后一个历史条目之后的情况下禁用哔哔声。

不太有用的选项是 `zle` 和 `singlelinezle`。前者控制 zle 是否完全活动，并且不是那么有用，因为它通常在你需要时自动打开，换句话说，在交互式 shell 中，并在你不需要时关闭。然而，通过 `[[ -o zle ]]` 进行测试有时很有用；这让你可以在交互式 shell 中让一个函数做一些更聪明的事情。

`singlelinezle` 选项将编辑限制在一行；如果它变得太长，它将被截断，并在缺少的部分打印一个 `$`。它只用于与 ksh 的兼容性，以及如果你的终端真的搞砸了，作为一个保障，尽管即使在这种情况下，zsh 也会尝试猜测它需要的一切是否可用。

影响 zle 的其他函数包括历史函数。这些在[第二章](zshguide02.html#init)中已经描述过了；一旦你设置好它，在 zle 中搜索历史的工作方式与用 `!` 历史命令基本相同。

[]{#l85}

### 4.3.2: minibuffer 和扩展命令

“minibuffer”是另一个 Emacs 的概念；它是一个出现在命令行正下方的提示，供你输入编辑器本身需要的一些编辑。通常，它随心所欲地来来去去，你不需要考虑它。最常见的用途是输入搜索文本，以及输入一个没有绑定到字符串的命令。这又是另一个 Emacs 的特性：`\ex` 提示你输入一个命令的名称。幸运的是，由于名称往往相当长，补全是可用的。所以输入 `echo foo<ESC>xba<TAB>w<TAB>` 最终会得到：

      % echo foo
      execute: backward-word

然后按回车执行该函数，带你到 `foo` 的开头；你可能能想到更容易的方法来做到这一点。这确实提供了一种运行你不经常使用的命令的方法。

（我希望我的表示法不会太令人困惑。当我显示你按下的单个字符时，我会写成 `<TAB>`，以使其与周围的文本区分开来。然而，当我不显示正在输入的文本时，我会写成 `\t`，这是你将字符输入到要绑定的键序列或要打印的字符串中的方式。）

minibuffer 只处理非常有限的一组编辑命令。输入一个它不理解的命令通常会退出你正在用 minibuffer 做的任何事情，然后执行该按键。然而，在这种特殊情况下，它不会让你退出，直到你输完一个命令；你唯一的其他选择是中止。通常的 zle 中止字符是 `^g`，`send-break`。这与更激烈的 `^c` 不同，后者向 shell 本身发送一个中断信号。然而，在 zle 中，它们通常有相同的效果。（你会注意到 `^c` 实际上“绑定到 `undefined-key`”，换句话说，zle 不认为它做任何事情。然而，终端驱动程序可能会导致它发送一个中断，而 zle 确实会对此做出响应。）

另一个对罕见命令有用的特性是 `where-is`。惊喜！它默认没有绑定，所以输入 `<ESC>xwhere-is` 是运行它的方式。然后你在 `Where is:` 提示符下输入另一个编辑器命令，shell 会告诉你哪些按键（如果有的话）绑定到了它。你也可以简单地对 `bindkey` 的输出使用 `grep`，`bindkey` 在没有参数的情况下会列出所有绑定。

[]{#l86}

### 4.3.3: 前缀（数字）参数

许多命令可以通过给它们一个数字前缀或数字参数来重复。例如，在一长串文本的末尾，输入 `<ESC>4<ESC>b`。单独的 `<ESC>b` 会让你向后移动一个单词。`<ESC>4` 给它传递了数字四，它就向后移动四个单词。一般来说，只要重复一个命令有意义，这都有效。它也对 `self-insert` 有效，只是重复插入字符。如果它不起作用，前缀参数就会被简单地忽略。

你可以通过重复 `\e` 和它后面的数字或 `-` 来构建长参数或负参数；例如，`<ESC>-<ESC>1<ESC>0` 指定负十。负数有多大用处因命令而异，但它们通常会从后退切换到前进或类似：`<ESC>-<ESC>4<ESC>\f` 是执行与 `<ESC>4<ESC>b` 相同操作的无意义方式。

shell 也有 Emacs 的“universal-argument”特性，但它默认没有绑定——在 Emacs 中是 `\C-u`，但正如我们所见，那已经被占用了。这是所有那些转义的替代方案。如果你将该命令绑定到一个按键（否则它作为快捷方式绝对没有意义），并输入该键，那么一个可选的减号后跟任何数字都会被记作一个前缀。下一个不是这些之一的按键然后作为命令执行，带有在 `universal-argument` 后输入的数字形成的前缀。

例如，在我的键盘上，`F12` 键发送键序列 `\e[[24~`——参见下面了解如何找出功能键发送什么。因此我使用

      bindkey '\e[[24~' universal-argument

然后如果我按 `F12`、`4`、`0`、`a`，一行四十个“a”就会被插入到命令行中。我不是说这个例子特别有用。

[]{#l87}

### 4.3.4: 单词、区域和标记

在 zsh 中，单词的处理方式与大多数编辑器有点不同。首先，Emacs 模式和 vi 模式认为的单词之间有区别。也就是说，在这些模式下默认绑定的函数之间有区别；你可以通过重新绑定键在任一模式下使用相同的函数。

在 vi 和 Emacs 模式中，无论你是向前还是向后移动若干个单词，还是删除或剪切它们，关于单词的逻辑都适用；剪切时移除的文本量与光标在其他情况下移动的量相同。

在 vi 模式下，单词基本上与 vi 认为的单词相同：一串字母数字字符加上下划线——本质上，可以出现在标识符中的字符，实际上 zsh 内部就是这样识别 vi 的“单词字符”的。然而，关于 vi 的逐词行为有一个轻微的怪癖，你可以很容易地看到，如果你输入 `/a/filename/path/`，用 `ESC` 离开插入模式，然后用 `w` 或 `b` 在它上面逐词前进或后退。它会在移动单词中的字符和移动分隔符 `/` 中的字符之间交替。

然而，在 Emacs 中，做法有点不同。vi 的“单词字符”总是被认为是单词的一部分，但有一个参数 `$WORDCHARS`，它给出了一个*也*是单词一部分的字符的字符串。这可能与你期望的相反；鉴于字母数字总是单词的一部分，你可能会期望有一个参数，你可以向其中添加你*不*希望成为单词一部分的字符。但事实并非如此。

也与 vi 不同，跳过一个单词总是意味着跳到单词开头的单词字符。在跳过非单词字符时没有额外的“回合”用完。

`$WORDCHARS` 的默认值是

      *?_-.[]~=/&;!#$%^(){}<>

即，几乎所有东西和厨房水槽。因此，你通常会想要移除你不想被认为是单词一部分的字符；`-`、`/` 和 `.` 是特别可能的可能性。如果你想移除单个字符，你可以用一些模式匹配的技巧来做到（下一章）：

      % WORDCHARS=${WORDCHARS//[&.;]}
      % print $WORDCHARS
      *?_-[]~=/!#$%^(){}<>

显示该操作已从 `$WORDCHARS` 中移除了组中的那三个字符，即 `&`、`.` 和 `;`。`//` 表示全局替换：方括号中的任何字符都被替换为空。

许多其他行编辑器，即使是像 `readline` 这样有 Emacs 绑定的，其行为也好像只有标识符字符是单词的一部分，即好像 `$WORDCHARS` 是空的。用一个 zle shell 函数做到这一点非常容易。最近版本的 zsh 提供了 `bash-forward-word`、`bash-kill-word` 以及一系列其他类似的函数，供你绑定到键上以获得那种行为。

通过编写函数，其他行为也是可能的；例如，你可以通过使用一些更多的替换技巧来跳过真正的 shell 单词（即单个命令参数），或者你可以只考虑以空格分隔的单词（尽管这与你通过向 `$WORDCHARS` 添加 ` `"`'@ ` 得到的结果相差不远）。

[]{#l88}

### 4.3.5: 区域和标记

另一个来自 Emacs 的有用概念是区域和标记。在 Emacs 术语中，“点”是光标所在的位置，“标记”是你留下一个标记以便以后回来的地方。在当前点设置标记的命令是 `^@`，就像在 Emacs 中一样，这是一个象形文字，通常意味着按住 control 键并按空格键。在某些系统上，比如某个著名的非 UNIX 窗口系统提供的有限版本的 `telnet`，你无法发送这个序列，你需要将一个不同的序列绑定到 `set-mark-command`。一种可能性是 `\e `（escape 后跟空格），就像在 MicroEMACS 中一样。（一些 X Windows 配置也不允许 `^@` 在 xterm 中工作，尽管这通常是可以修复的。）

继续使用 Emacs 的语言，点和标记之间的区域被简单地描述为“区域”。在 zsh 中，你不能像你可能习惯于在直接在窗口系统下运行的编辑器中那样高亮显示这个区域，所以找出区域两端最简单的方法是使用 `^x^x`，`exchange-point-and-mark`，我之前提到过——默认情况下，标记留在行的开头，因此你看到了上面的行为。

各种编辑命令——通常是那些名称中带有“region”的命令——都作用于此。最常见的是那些剪切或复制区域的命令。令人烦恼的是，`kill-region` 没有被绑定——在 Emacs 中，它是 `^w`，但 zsh 遵循传统，将其绑定到 `backward-kill-word`，尽管那也可以通过传统的 Emacs 绑定 `\e^?` 来获得。所以重新绑定它可能很有用。要复制区域，通常的绑定 `\ew` 是有效的。

然后你用 `^y` 在另一点“粘贴”回复制或剪切的文本。shell 实现了“剪切环”功能，这意味着如果你执行一次粘贴，然后重复输入 `<ESC>y` (`yank-pop`)，shell 会循环回到以前剪切或复制的文本，这样你可用的就不止最后一个了。

[]{#l89}

## 4.4: 历史和搜索

Zle 可以访问保存在 shell 历史中的行，如[第二章](zshguide02.html#init)中的“设置历史”所述。基本上有三种方法可以检索历史的片段：逐行向后移动，向后搜索匹配的行，以及从历史中提取单个单词。实际上，前两种非常相似，并且有混合命令，允许你一步一步地向后移动，但仍然只匹配特定的行。

[]{#l90}

### 4.4.1: 在历史中移动

最简单的行为是你用普通光标键绑定得到的那种，`up-line-or-history` 和 `down-line-or-history`。如果你在适合单行的文本中（这可能是一个续行，即行首有一个由 `$PS2` 给出的新提示），这会将整行替换为历史中的前一行或后一行。历史不是循环的，它有开始和结束。开始是 shell 仍然记住的第一行（即 `$HISTSIZE` 行之前，考虑到实际存在的行数会因你设置的任何特殊历史选项以删除不需要的行而修改）；结束是你正在输入的行。你可以使用 `\e<` 和 `\e>` 转到历史的第一行和最后一行。

最后一句话听起来微不足道，但并非如此。输入 `echo 这是最后一行`，用向上箭头返回几行，然后再向下回到末尾，你会明白我的意思——shell 记住了你正在输入的行，即使它还没有被输入，所以你可以上下滚动历史，仍然可以回到它。

当然，你可以编辑任何早期的历史行，然后按“回车”执行它们——这就是能够回滚历史的全部意义所在。可能不那么明显的是，shell 也会记住你对这些行所做的更改，直到你按“回车”。

例如，在一个新的 shell 提示符下输入 `echo this is the last line`，但不要按回车。现在按一次向上箭头，并将前一行编辑为 `echo this is the previous line`。如果你上下滚动，你会看到 shell 保留了这两行。当你决定使用哪一行并按回车时，该行被执行并添加到历史的末尾，对历史中前几行的任何更改都会被忘记。

有时你不想向历史添加新行，而是想逐个重新执行一系列早期的命令。这可以用 `^o`，`accept-line-and-down-history` 来完成。当你在历史中的一行上按 `^o` 时，该行被执行，历史中的下一行被显示。所以你只需要一直按它来继续执行命令。

还有两个我用得不多的类似命令，`infer-next-history`，绑定到 `^x^n`，和 `accept-and-infer-next-history`，默认未绑定。“推断”下一个历史意味着 shell 查看当前行中的内容，无论其来源如何——例如，你可能刚刚输入了它——并在历史中向后查找匹配的行；“推断”的下一个历史行是该行之后的行。在第一种情况下，你只是被显示那一行；在第二种情况下，当前行首先被执行，然后你被显示推断的行。如果你发现这是自切片面包以来最好的东西，请随时给我写信。

关于历史的一个轻微混淆是，很难记住你到底在历史的哪个位置，例如，如果你正在编辑一行，并且不得不回滚以寻找其他东西。在这种情况下，`\e>` 是你的朋友，因为它会带你到最后一行。此外，无论何时你按回车，你都保证在历史的末尾，即使你正在编辑历史中靠前的某一行，不像某些其他系统（尽管 `accept-line-and-down-history` 可以模拟那些）。所以通常不难保持对你正在编辑的内容不感到困惑。

[]{#l91}

### 4.4.2: 搜索历史

Zsh 有你期望的搜索历史的命令，即你按一个搜索键，然后输入要搜索的单词。然而，它还有其他功能，可能 zsh 社区用得更多，其中搜索是基于当前行的某个特征，特别是第一个单词或光标位置之前的行。这些通常使你能够更快地向后搜索，因为你不需要告诉 shell 你在寻找什么。

**普通搜索**\

标准的搜索命令，我指的是你可能从普通文本编辑器（如果 Emacs 或 vi 可以这样称呼的话）中最熟悉的那些，旨在让 Emacs 和 vi 用户感到宾至如归。

在 Emacs 模式下，你有增量搜索：`^r` 向后搜索——这通常是你想要的，因为你通常从末尾开始——和 `^s` 向前搜索。请注意，`^s` 是另一个经常被终端驱动程序拦截的按键；在这种情况下，它通常会冻结终端的输出，直到你输入 `^q` 重新打开它。如果你不喜欢这样，你要么可以使用 `stty stop` 和 `stty start` 来更改字符，要么简单地 `unsetopt flowcontrol` 来完全关闭该功能。然而，绑定到 `^s` 的命令 `history-incremental-search-forward` 也绑定到 `^xs`，所以你可以用那个代替。

就像在 Emacs 中一样，对于你输入的每个字符，增量搜索都会带你到与所有字符匹配的最近的历史条目，直到匹配失败。在任何时候再次输入搜索按键都会带你到 minibuffer 中字符的下一个匹配项。

在 vi 命令模式下，默认可用的按键是熟悉的 `/` 和 `?`。然而，与 vi 有各种不同之处。首先，是 `/` 向后搜索——这是你会更经常使用的那个。其次，你不能搜索正则表达式（模式）；唯一的例外是行首的 `^` 将搜索锚定到行首。其他一切都只是纯字符串。

另外两个标准的 vi 搜索按键也存在：`n` 搜索当前字符串的下一个匹配项，`N` 做同样的事情，但反转搜索方向。

**按第一个单词搜索**\

下一种搜索可能是最常用的，但只在 Emacs 模式下绑定：`\ep` 和 `\en` 向前或向后搜索与当前行第一个单词相同的下一个历史行。所以通常要重用一个命令，你只需输入命令名称本身，然后按 `\ep` 直到你想要的命令行出现。这些命令被简单地称为 `history-search-backward` 和 `history-search-forward`；这个名称并不能很好地描述其功能。

**前缀搜索**\

最后，你可以向后搜索一个从开头到光标位置与当前行完全相同的行。这比 `history-search-`*direction* 给你更多的控制。相应的命令，`history-beginning-search-backward` 和 `history-beginning-search-forward`，默认没有绑定。我发现将它们绑定到 `^xp` 和 `^xn` 很有用，因为这与初始单词搜索类似：

      bindkey '^xp' history-beginning-search-backward
      bindkey '^xn' history-beginning-search-forward

**其他基于函数的搜索命令**\

搜索命令是最常通过编写 shell 函数来定制的类型之一。最新版本的 shell 提供了一些；请查看 `zshcontrib` 手册页的 ZLE 部分。你应该能在你的 `$fpath` 中的某个地方找到函数本身，通常是

      /usr/local/share/zsh/$ZSH_VERSION/functions

或该目录的子目录 `Zle`，取决于你的 zsh 版本是如何安装的。如果 shell 是预装的，最可能的位置是

      /usr/share/zsh/$ZSH_VERSION/functions/Zle

这些应该能指导你编写自己的。

需要注意的一点是，当从函数调用时，`history-search-`*direction* 和 `history-incremental-search-`*direction* 可以接受一个字符串参数，指定要搜索的内容。在第一种情况下，这只是一次性搜索，而在第二种情况下，你保持在增量搜索中，并且该字符串用于填充 minibuffer，所以你可以编辑它。我稍后会更多地讲关于编写 zle 函数，但从用户定义的编辑函数中调用一个搜索命令就像这样简单：

      zle history-search-backward search-string

你可以测试返回状态以查看搜索是否成功。

[]{#l92}

### 4.4.3: 从历史中提取单词

有时，你不想编辑前一行，只想从中提取一个单词到当前行。如果这个单词是行尾的最后一个，并且该行在历史中不远，这就特别容易：只需重复按 `\e.`，shell 就会循环浏览前几行上的最后一个单词。你可以给它一个前缀参数，以从你上次挑选单词的那一行上面的那一行中挑选第 *N* 个倒数单词。正如你从描述中可以看出的，这有点棘手；shell 的 4.1 版本可能会提供一个稍微更灵活的版本。

虽然这严格来说与历史无关，但你可以用 `copy-prev-word` 复制当前行上的前一个单词，由于某种原因，它被绑定到 `\e^_`，即 escape 后跟（可能）control 和斜杠。我把它绑定到 `\e=`（在某些版本的 ksh 中，该键序列被 `list-choices` 的等价物占用）。这会复制以空白分隔的单词，但你可以通过使用 `copy-prev-shell-word` 来复制 shell 会看作是前一个完整参数的内容。这个默认没有绑定，因为它比另一个新，但它可以说更有用。

有时你想从历史中补全一个单词；这可以使用补全系统来完成，下一章会描述。

[]{#l93}

## 4.5: 绑定键和处理键映射

在键绑定这个标题下有两个主题要讲：首先，如何绑定键本身，其次，键映射以及如何使用它们。操作键绑定和键映射都是用 `bindkey` 命令完成的。第一个主题更直接有用，所以我先从那个开始。

[]{#l94}

### 4.5.1: 简单键绑定

你已经看到了 `bindkey` 的基本用法，用于将编辑命令链接到一个特定的键序列。你已经看到了命名键的简写，用 `\e` 表示 escape，`^x` 表示按住 control 键时按下的字符 `x`。我甚至提到了一些关于“meta”键绑定的事情。

现在让我更详细地讲一下。当你绑定一个键序列时，你用 `bindkey` *key-sequence* *editor-command* 来做，*key-sequence* 可以包含任意多个字符。即使键序列的某个初始集合已经被绑定了，也（几乎）没关系。例如，你可以做，

      bindkey '\eA' backward-word
      bindkey '\eAA' beginning-of-line

在这里，我将遵循 shell 文档，将 `\eA` 称为 `\eAA` 的前缀。

这引入了两点。首先，请注意 `\eA` 的绑定与 `\ea` 的绑定是不同的；你会看到后者仍然执行 `accept-and-hold`（在 Emacs 模式下），这意味着它执行当前行，然后把它还给你编辑——这对于做很多非常相似的任务很有用。同时，`\eA` 带你向后一个单词。

这种大小写敏感性只适用于本身就是一个完整键的字母字符，而不适用于按住 control 键的那些字符——`^x` 和 `^X` 是相同的。（你可能发现在 Emacs 中，在窗口系统下运行时有办法分别绑定两者，因为窗口系统可以告诉 Emacs shift 键是否与其他键一起按住；如果你使用的是普通终端，那就没那么简单了。）

如果你输入了那两个 `bindkey` 命令，你可能会注意到在 `\eA` 生效之前有一个短暂的停顿。那是因为它在等待看你是否会输入另一个 `A`。如果你在那次停顿期间确实输入了额外的 `A`，你将被带到行的开头。那个停顿是 shell 决定是否单独执行前缀的方式。

它等待的时间是可配置的，由参数 `$KEYTIMEOUT` 给出，这是以百分之一秒为单位的延迟。默认是 40，即十分之四秒。它的使用通常取决于个人偏好；如果你打字不快，你可能想增加它，代价是在等待前缀执行时有更长的延迟。如果你在非常慢的链接上远程编辑机器，你也可能需要增加它，以便能够让具有这样前缀的完整键序列正常工作。

然而，只有当前缀本身被绑定时，shell 才会有这种矛盾的行为；如果初始的一个或多个键本身没有任何意义，它会一直等你输入一个被绑定的完整序列。这是迄今为止最正常的情况。唯一常见的单独绑定前缀的例子是在 vi 插入模式下，其中 `<ESC>` 带你回到命令模式，而可能还有其他以 `\e` 开头的绑定，比如光标键。我们将在下面看到如何移除那些如果它们冒犯了你的 vi 纯粹感。（别笑，vi 用户很奇怪。）

请注意，如果整个序列毕竟没有被绑定，shell 会在它读到一个不再是前缀的完整键序列后立即中止。例如，如果你输入 `\e[`，很可能 shell 还在等待更多，但如果你加上一个 `/`，比如说，它可能会认为你在胡闹并中止。你输入的下一个键然后开始一个新的序列。

[]{#l95}

### 4.5.2: 移除键绑定

如果你想移除一个键绑定，你可以简单地将它绑定到别的东西上。几乎所有 `bindkey` 和 `zle` 命令的用法在处理这种情况时都很聪明，会自动移除死木。然而，你也可以使用 `bindkey -r` *key-sequence* 来明确地移除绑定。你也可以简单地将序列绑定到 `undefined-key` 命令；这有完全相同的效果——甚至可以完全修剪掉任何长序列的绑定。例如，假设你将 `\e\C-x\C-x` 绑定到一个命令，然后又绑定到 `undefined-key`。所有关于 `\e\C-x\C-x` 曾被绑定的记忆都会被移除；`\e\C-x` 将不再被标记为前缀键，除非你还有其他以该前缀开头的绑定。

你可以通过添加 `-p` 选项来移除以给定前缀开头的所有绑定。手册中给出的例子，

      bindkey -rpM viins '\e'

（除了它使用了等效形式 `^[`）是最有用的之一，因为它将移除你在输入 `\e` 以进入 vi 命令模式后烦人的延迟。延迟是因为光标键通常也以 `\e` 开头，shell 在等待看你是否实际输入了其中一个。所以如果你能在 vi 插入模式下不用光标键，你可能想考虑这个。

请注意，前缀本身的任何绑定都不会被移除。在这个例子中，`\e` 在 `viins` 键映射中保持其原来的绑定，大概是 `vi-cmd-mode`。

所有像这样的操作都特定于一个特定的键映射。你需要用不同的 `-M` *...* 选项参数重复它们，才能在其他键映射中产生相同的效果，这将在下面描述。

[]{#l96}

### 4.5.3: 功能键等

[]{#fkeys}

通常可以绑定你键盘上的功能键，包括像“Home”和“Page Up”这样的特殊命名的键。这在很大程度上取决于你的窗口系统或终端驱动程序如何处理它们，但如今，一个设置良好的系统几乎总是允许功能键向终端发送一个字符串。要绑定这些键，你需要找出那个字符串是什么。

幸运的是，你通常会得到帮助，因为字符串的第一个字符通常是“奇怪的”，即它做的不是插入一个字符。所以有一个技巧可以找出这个序列是什么。在一个 shell 窗口中，按 `^v`（如果你使用 vi 绑定，你需要处于插入模式），然后按有问题的功能键。你可能会看到一个像 `^[OP` 这样的字符串——这是我从 F1 键得到的。我的 `.zshrc` 中的一个注释表明我曾经得到 `\e[11~`，所以即使你像我一样使用标准的 xterm 终端模拟器，也要准备好会有所不同。对这个 Linux/GNU/XFree86 系统上的终端模拟器进行快速调查表明，这两种可能性是迄今为止最受欢迎的。

你甚至可能通过同时按住 shift 或 control 来得到不同的序列（当然，是在按 `^v` 之后）。在我的键盘上，将 F1 与 shift 组合会给我 `^[O2P`，与 control 组合会给我 `^[O5P`，两者都按会给我 `^[O6P`。同样，你的系统可能会做完全不同的事情。

如果你将光标移回那个 `^[`，你会发现它是一个单一的字符——你可以将光标定位在 `^` 上，但不能定位在 `[` 上。这是 zsh 将一个真实的、活生生的转义字符插入到行中的方式。事实上，如果你输入

      bindkey '

然后是 `^v`，功能键，和另一个单引号，你就有一种在命令行上绑定该键的完全可接受的方式。Zsh 通常对你使用不可打印字符相当宽松；它们可能不会在你的终端上正确显示，但 shell 能够处理所有单字节字符。然而，它还不支持超过单字节的字符。

你也可以在你的 `.zshrc` 中做同样的事情；shell 会毫无怨言地处理输入中的奇怪字符。你也可以使用两个字符 `^[`，这只是输入转义键的另一种方式。然而，合乎规矩的做法是将其变成 `\e`。例如，

      bindkey '\e[OP'  where-is           # F1
      bindkey '\e[O2P' universal-argument # shift F1

等等。使用这个，你可以给“Home”、“End”等赋予合理的含义。注意窗口系统避免前缀问题的明智方式——任何额外的字符都插入在最后一个字符之前，所以 shell 可以很容易地判断序列何时完成，而不必等待看是否还有更多。

Zsh 提供了一个名为 `zkbd` 的实用程序，它可以通过为你找出并记住定义来帮助处理所有这些。你可能只需自动加载并运行它就可以使用它，因为它通常与其他函数一起安装。它应该相当不言自明，否则请查阅 `zshcontrib` 手册。

如果你正在使用 X Windows 并且受过足够的教育，你可以修改你的 `.Xdefaults` 文件来调整终端模拟器如何解释键。例如，以下内容将任何使用“VT100 小部件”（这是 xterm 通常操作模式的基础）的东西中的退格键变成删除键：

      *VT100.Translations: #override \ 
      <Key>BackSpace: string(0x7F)

展示这个的部分原因是为了让 zsh 的键绑定系统相比之下看起来非常精简。然而，在这个层面上进行修改可以让你对键修饰符（shift、alt、meta、control，如果你幸运的话甚至可能是 super 和 hyper）的使用有更多的控制。这远远超出了本指南的范围——正如你现在可能意识到的，我说这个是为了掩盖我对它知之甚少。不过，这里有另一个来自 Oliver Kiddle 的例子；它使用 control 和左光标键来发送一个转义序列：插入

      Ctrl<Key>Left: string(0x1b) string("[159q") \
\

到上面例子的中间——这显示了如何处理多个定义。现代的 xterm 已经发送了特殊的转义序列，你可以像我描述的那样去研究和绑定。

[]{#l97}

### 4.5.4: 绑定字符串而不是命令

通过给 `bindkey` `-s` 选项，可以将任意字符串绑定到一个键序列，而不是一个编辑器命令。这样做的一个好处是，字符串会被 zle 重新解释，所以它们可以包含活动的键序列。在过去，这经常被用作一种基本的宏形式，用来串联编辑器命令。例如，以下是通过重复 Emacs 模式绑定来向后移动两个单词的简单方法。我再次使用了我的 F1 绑定；你的可能完全不同。

      bindkey -s '\e[OP' '\eb\eb'

将一个键序列绑定到包含其自身的另一个字符串不是一个好主意。

这种方法有一个明显的缺点，如果有人来重新绑定 `\eb`，那么 F1 也会停止工作。如今，这类任务可以通过编写用户定义的小部件来更灵活、更清晰地完成，这将在后面的部分描述。所以这类绑定有点过时了。然而，它们确实提供了快速的快捷方式。来自 Oliver Kiddle 的两个例子：

      bindkey -s '^[[072q' '^V^I'                       # Ctrl-Tab
      bindkey -s "\C-x\C-z" "\eqsuspend\n"

你也可以很容易地做一些你可以用全局别名做的事情。

记住，“普通”字符也可以被重新绑定；它们只是通常碰巧有一个使它们被直接插入的绑定。作为一个特别无意义的例子，考虑：

      bindkey -s secret 'Oh no!'

如果你足够快地输入 `secret`，这些字母会被吞掉，而 `Oh no!` 会出现。如果你在中间停顿足够长的时间，这个词就会像平常一样被插入。那是因为它的所有部分都可以被解释为它们自己的前缀，所以 `$KEYTIMEOUT` 在每个中间阶段都适用。不那么无意义的是，你可以用这个作为定义缩写的一种方式。

[]{#l98}

### 4.5.5: 键映射

到目前为止，我所说的关于键映射的全部内容是，有三个标准的，一个用于 Emacs 模式，两个用于 vi 模式，并且 `bindkey -e` 和 `bindkey -v` 选择 Emacs 或 vi 插入模式绑定。没有简单的方法可以选择 vi 命令模式绑定，因为那通常不是直接可用的，而是通过 `vi-cmd-mode` 命令进入的，通常绑定到 vi 插入模式下的 `\e`。（有一个 `bindkey -a`，但那不选择用于正常使用的键映射；它等同于，但不如 `bindkey -M vicmd` 清晰。）

大多数对键映射的处理都是通过 `bindkey` 完成的。键映射有短名称，`emacs`、`viins` 和 `vicmd`，用于 `bindkey`。还有一个键映射 `.safe`，你通常不需要，但它永远不会改变，所以如果你的实验完全毁了所有其他键映射，你可以使用它。它只有 `self-insert`（大多数键）和 `accept-line`（`^j` 和 `^m`）的绑定，但这足以输入命令。

这些名称在两个地方最有用。首先，你可以使用 `bindkey -M` *keymap* 来在特定的映射中定义键：

      bindkey -M vicmd "\e[OA" up-line-or-history

在 `vicmd` 模式下绑定通常的向上光标键，无论当前设置了哪个键映射。实际上，任何理解 `-M` 选项的 shell 版本可能都已经绑定了那个。

其次，你可以强制 zle 使用一个特定的键映射。这是以一种稍微不明显的方式完成的：zle 总是使用键映射 `main` 作为当前键映射（除非它在 vi 命令模式下关闭，那里的处理有点特殊）。要使用你自己的，你需要用 `bindkey -A` 使 `main` 成为它的一个别名。这之后的顺序与 `ln` 之后的顺序相同：你想要引用的现有键映射排在第一位，然后是你想要为它创建别名的东西，在这种情况下是 `main`。这意味着

      bindkey -A emacs main

与

      bindkey -e

有相同的效果，但更明确，如果有点巴洛克的话。不要将 `vicmd` 链接到 main，因为那样你就不能使用 `viins`，这很糟糕。请注意，`bindkey -M emacs` 没有这个效果；它只是列出 `emacs` 键映射中的绑定。

你也可以创建自己的键映射。最简单的方法是复制一个现有的键映射，比如

      bindkey -N mymap emacs

它创建（或替换）`mymap` 并用 `emacs` 的绑定来初始化它。现在你可以像使用 `emacs` 一样使用 `mymap`。每个中的绑定是完全独立的。如果你用完了一个键映射，你可以用 `bindkey -D keymap` 来移除它，尽管你最好先确保它没有链接到 `main`。

你可以省略 `emacs` 来创建一个空的键映射；如果你的键映射只会在某些特殊的地方使用，并且你想要完全控制其中的内容，这可能是合适的。然而，目前 shell 在让你只在某些地方应用你自己的键映射方面做得不是很好。

你可能会遇到各种其他在特殊情况下使用的键映射。如果你列出所有键映射，这是通过 `bindkey -l` 完成的，你可能会看到 `listscroll` 和 `menuselect`。这些被新的补全系统使用，所以如果那个没有激活，你可能不会看到它们。它们存在于模块 `zsh/complist` 中。关于它们的效果，[第六章](zshguide06.html#comp)中会有更多内容；`listscroll` 允许你在超过终端窗口的补全列表中上下移动，`menuselect` 允许你从显示的列表中交互式地选择项目。你可以像在任何其他键映射中一样在其中绑定键。

[]{#l99}

## 4.6: 高级编辑

（在物理学中，“高级波”是一种假设的向后移动的波。不幸的是，尽管它对赶上最后期限很有用，但这并不是我所说的“高级编辑”。）

这里有一些超出了普通 shell 命令的行编辑范围的东西。尽管它们到目前为止在 shell 中并不普遍，但我每天都使用它们所有，所以它们不仅仅是为研究生 zsh 学者准备的。

[]{#l100}

### 4.6.1: 多行编辑

所有类 Bourne shell 都允许你编辑续行；也就是说，如果 shell 可以确定你还没有输完，它会显示一个新的提示符，由 `$PS2` 给出，并允许你从上一行离开的地方继续。在 zsh 中，你甚至可以看到 shell 在等待什么。举个简单的例子，输入 `array=(`first` 然后按“回车”。shell 在等待数组的最后一个括号，并向你打印 `array>`，除非你改变了 `$PS2`。你可以继续向数组添加元素，直到你关闭括号。

源自 csh 的 shell 对续行不太满意；从历史上看，这是因为它们试图一次性评估所有内容，如果不能就会感到困惑。最初的 csh 没有一个特别复杂的解析器。这一次，zsh 没有一个选项来匹配 csh 的行为；你只需要习惯于 zsh 中事情就是这样工作的。

Zsh 相对于其他 shell 的改进之处在于，你不仅限于编辑单个续行；你实际上可以在屏幕上编辑一整块行，就像在全屏编辑器中一样——尽管你不能滚动出你正在编辑的行块，那没有意义。

最简单的方法是在你还没有输完的时候，在输入换行符之前按 escape。实际上，你随时都可以这样做，即使到目前为止的行是完整的。例如，

      % print 这是第一行<ESC><RET>
      print 这是第二行

行尾的那些尖括号意味着你按 escape，然后按 return。什么也没发生，也没有新的提示符；你只是轻快地继续输入。这次按回车，没有转义，两行都会被执行。请注意，没有隐含的反斜杠，或类似的东西；当 zsh 读取整个东西时，那个转义的回车变成了一个真正的回车，就像 shell 从脚本中读取它一样。

这是因为 `\e\r` 实际上绑定到 `self-insert-unmeta` 命令，意思是“插入我刚刚输入的字符，去掉 escape 或最高位”——换句话说，一个字面上的回车。如果你输入 `^v^j`，你会得到完全相同的效果，因为 `^v` 同样会转义 `^j`（换行符），就像它对任何其他字符一样。

（仅供极度好奇者阅读的旁注：为什么这里是换行符而不是回车符——你可能期望的“enter”键？这是一个相当怪诞的故事。事实证明，出于主要是历史原因，UNIX 终端驱动程序喜欢交换换行符和回车符，所以当你输入回车符（由那个键和 `^m` 发送，与 `\r` 表示的字符相同）时，它出来的是换行符（在大多数键盘上，只由 `^j` 发送，与 `\n` 表示的字符相同）。换行符是你“看到”在行尾的那个字符（因为它就是行尾）。然而，`^v` 看穿了这一点，如果你在它后面输入 `^m`，它会插入一个字面上的 `^m`，它看起来就像一个 `^m`，因为 zsh 就是这样输出它的。所以这就是为什么那不起作用。实际上，`self-insert-unmeta` 也会看到 `^m`，因为那是你去掉 `\e` 后得到的东西，但它有一点额外的代码让 UNIX 用户感到宾至如归，并且行为就像它是一个换行符。通常，`^j` 和 `^m` 被同样对待（`accept-line`），但字面字符有不同的行为。如果你现在非常困惑，就庆幸我还没有告诉你输出换行符时发生的额外扭曲吧。）

这可能看起来还不是特别有用，因为你所做的只是省略了一个新的提示符。让它变得有用的是，你现在可以只用光标键在两行（或更多行）之间上下移动。我假设你没有重新绑定光标键，你的终端不是一个不支持向上光标的哑终端，并且 `singlelinezle` 选项没有生效——如果生效了就取消它，你以后会感激的。

所以例如，输入

      % if [[ true = false ]]; then<ESC><RET>
        print Fuzzy logic rules<ESC><RET>
      fi

我只是用空格缩进了第二行，因为我通常在“if”里面这样做。这里没有续行提示符，只有原始的 `$PS1`；那不是印刷错误。现在，在按回车之前，向上移动两行，并将 `false` 编辑为 `true`。你可以看到这有多有用。在命令行上输入函数可能是一个更典型的例子。

假设你已经用 `$PS2` 以正常方式经历了几次续行？那时你就不能回滚了，即使块还没有被编辑。有一个神奇的方法可以将所有那些续行变成一个单一的块：编辑器命令 `push-line-or-edit`。如果你不在续行上，它的行为就像我们下面会遇到的普通 `push-line` 命令，但就目前的目的而言，当你在续行上时使用它。你会看到一个从（重绘的）提示符到末尾的无缝文本块，你可以像一个整体一样编辑它。将 `push-line-or-edit` 而不是 `push-line` 绑定到 `^q` 或 `\eq`（在 Emacs 模式下，我将像往常一样假设）是相当合理的。不过要小心 `^q`——如果 `flowcontrol` 选项被设置，它可能会被终端驱动程序吞掉，而无法到达 shell，这与我上面提到的 `^s` 的问题相同。

[]{#l101}

### 4.6.2: 内建 vared 和函数 zed

我在[第三章](zshguide03.html#syntax)中提到了 `vared` 命令；它使用普通的行编辑器来编辑一个变量，通常是一个你不想完全输入的长的变量，比如 `$path`，尽管你需要记住*不要*在前面放 `$`，否则 shell 会在 `vared` 运行之前替换它。然而，由于它就像任何其他输入一样只是一段文本，所以它也可以有多行，你以同样的方式输入——而且由于一个 shell 参数可以包含任何东西，你就有了一个相当通用的编辑器。shell 函数 `zed` 与 shell 一起提供，允许你使用所有现在熟悉的命令来编辑一个文件。因为在编辑文件时，你不期望回车会把你踢出编辑器，只是插入一个新行，所以 zed 将回车重新绑定到 `self-insert-unmeta`（这里的 `-unmeta` 只是为了得到将回车变成换行符的交换行为）。要保存并退出，你可以输入 `^j`，或者，如果你的终端对那个有奇怪的反应，你也可以使用 `^x^w`，这被设计成看起来像 Emacs 写文件的方式。

如果你看一下 `zed`，你会看到它有一些花里胡哨的功能——例如，`zed -f` 允许你编辑一个函数——但是将文件读入一个参数，编辑该参数，并将参数写回文件的代码非常简单；所有困难的编辑代码都已经在 `vared` 内部处理了。的确，`zed` 本质上是一个完全通用的编辑器，尽管对于长文件，特别是大于单个屏幕的文件，它很快变得低效；正如你所期望的，zle 是为高效处理短文本块而编写的。

如果你能通过使用一个特殊的键映射来创建只在 vared 中应用的键绑定，那可能会很好。也许有一天会实现。

顺便说一句，请注意，你可以用 vared 编辑数组，它会明智地处理不同的元素。像往常一样，空白分隔元素；当它向你呈现一个元素内包含空白的数组时，vared 会在它前面加上一个反斜杠，以表明它不是一个分隔符。你可以自己用反斜杠插入带引号的空格。只有空白字符需要这种引用，而且只有反斜杠有效。

例如，

      array=('一个 词' '两个 或更多 词')
      vared array

呈现给你 `一个\ 词 两个\ 或\ 更多\ 词`。如果你添加 ` 和\ 一些\ 更多.`，按回车，然后输入 `print -l $array` 来每行显示一个元素，你会看到

      一个 词
      两个 或更多 词
      和 一些 更多.

一些旧版本的 shell 对元素内的空格不太小心。

[]{#l102}

### 4.6.3: 缓冲区堆栈

现在将解释 `push-line-or-edit` 的神秘其他用途。实际上，让我们坚持使用 `push-line`，因为我已经处理了 `-or-edit` 部分。

输入

      print 我刚才在目录

（没有换行符）。哦，天哪，你刚才在哪个目录？你不想打断文本流去查找。按 `\eq`；你一直在输入的行消失了——但别担心，它没有消失。现在输入

      dirs

两件事发生了：最后那一行当然被执行了，显示了目录栈上的目录列表（你对 `pushd` 和 `popd` 的使用），但你之前去掉的那一行也重新出现了，所以你可以继续编辑它。

你可能不会马上意识到这有多有用，但就在我写上一段的时候，我就用了好几次。例如，我正在 zle 源代码和我保存本指南的目录之间交替切换，我在意识到我在错误的目录之前就开始输入一个 `grep` 命令。我所需要做的就是输入 `\eq`，然后 `pushd`，把我带到我想要的地方，然后完成 `grep`。

“缓冲区堆栈”，这是这个机制的行话，可以随你喜欢多深。它是一个后进先出（LIFO）的堆栈，所以由最近输入的 `\eq` 推到它上面的行将首先重新出现，然后是按相反顺序的旧行。你甚至可以从一个函数中填充缓冲区堆栈——不一定是 zle 函数，尽管那也行——用 `print -z` *command-line*。

如果你想，你可以用 `\eg` 从堆栈中明确地拉出一个东西，但这与清除当前行并按回车有相同的效果。你当然可以多次推送同一行：如果你在执行它之前需要做一整套事情，每次行弹回来时就再按一次 `\eq`。

我撒了一点谎，为了避免混淆。`push-line-or-edit` 对多行缓冲区的聪明之处也延伸到了这种情况。如果你对一个多行缓冲区做一个普通的 `push-line`，只有当前的单行被推送；推送整个东西的命令，这可能是你想要的，是 `push-input`。但如果你绑定了 `push-line-or-edit`，你可以忘记这个区别，因为它会为你做。如果你一直注意听，你可以算出以下序列（假设 `\eq` 已被重新绑定到 `push-line-or-edit`）：

      % if [[ no = yes ]]; then
      then> print<ESC>q<ESC>q

第一个 `\eq` 将两行变成一个单一的缓冲区，然后第二个将整个东西推到缓冲区堆栈上。这省去了很多关于绑定的思考。因此，我建议 Emacs 模式的用户在他们的 `.zshrc` 中添加

      bindkey '\eq' push-line-or-edit

然后忘记这些区别。

[]{#l103}

## 4.7: 扩展 zle

我们现在来到 zle 最新、最灵活的部分，即使用 shell 函数创建新的、随你喜欢多复杂的编辑命令的能力。这最初是由 Andrew Main（“Zefram”）在 zsh 3.1 中引入的，因此在所有 zsh 4 版本中都是标准的，尽管工作仍在继续。

[]{#l104}

### 4.7.1: 小部件

如果你的母语不是英语，首先，恭喜你读到这里。其次，你可能认为“widget”只是一个技术词，应用于实现某些计算思想的对象，比如在窗口系统中实现文本编辑的东西。然而，对大多数英语使用者来说，“widget”是一个幽默的词，指一个物体，有点像“whatyoumacallit”或“thingummybob”，比如“那个能一次性解开箔纸并拔出软木塞的聪明小玩意在哪里”。Zsh 的用法在我看来更接近第二种，非技术的版本，但我可能因为 Zefram 引入的代表小部件的内部对象，用户永远看不到，被称为“thingy”而有偏见，我不会再提它了，因为你不需要知道。

无论如何，“小部件”本质上就是我到目前为止一直称之为编辑器命令的东西，你可以绑定到一个键序列。更精确的术语之所以有用，是因为一旦你有 shell 函数到处飞，单词“命令”就无可救药地不具体了，因为函数充满了可能是也可能不是小部件的命令。所以我毫不犹豫地使用这个词。

所以现在我们引入第二种类型的小部件：一种不是由内置到 shell 中的代码处理，而是由用户编写的函数处理。它们是完全等价的；`bindkey` 和公司不关心是哪一种。你创建小部件所需要做的就是

      zle -N widget-name function-name

然后 *widget-name* 可以在 `bindkey` 或 `execute-named-cmd` 中使用，函数 *function-name* 将被运行。如果 `widget-name` 和 `function-name` 相同，这通常是最简单的事情，你只需要其中一个。

你可以通过使用 `zle -l` 来列出现有的小部件，尽管通常 `zle -lL` 是一个更好的选择，因为那时的输出格式与你定义小部件时使用的形式相同。如果你这样做时看到很多 `zle -C` 小部件，暂时忽略它们；它们是补全小部件，处理方式有点不同，将在[第六章](zshguide06.html#comp)中描述。

现在你需要知道函数中应该放什么。

[]{#l105}

### 4.7.2: 执行其他小部件

在实现小部件的函数内部，你能做的最简单的事情就是调用一个现有的函数。所以，

      my-widget() {
        zle backward-word
      }
      zle -N my-widget

创建一个名为 `my-widget` 的小部件，它在各方面（除了速度）都像内建小部件 `backward-word` 一样。你甚至可以给它一个前缀参数，这个参数会被传递下去；`\e3` 然后无论你把小部件绑定到什么（或者 `\exmy-widget`）都会向后移动三个单词。

假设你想给 `backward-word` 传递你自己的前缀参数，而不是用户输入的那个？或者假设你想考虑前缀参数，但用它做一些不同的事情？两者都是可能的。

让我们来看第一个。你可以通过在小部件名称后放上 `-n` *argument* 来为这个命令单独提供一个前缀参数（注意这不是大多数选项去的地方）。

      my-widget() {
        zle backward-word -n 2
      }

这总是向后移动两个单词，覆盖用户给出的任何数字参数。（顺便说一句，你可以重新定义函数而不用告诉 zle；zle 只是在小部件运行时调用碰巧被定义的任何函数。）如果你在名称后只放 `-N`，它会取消用户给出的任何前缀，而不会引入新的。

前缀处理的另一部分——拦截用户指定的那个并可能修改它——引入了用户定义小部件最重要的部分之一。Zle 提供了各种参数，可以读取并经常写入以改变编辑器的行为甚至正在编辑的文本。在这种情况下，参数是 `$PREFIX`。例如，

      my-widget() {
        zle backward-word -n $(( ${NUMERIC:-1} * 2 ))
      }

这使用一个算术替换来为 `backward-word` 提供一个参数，该参数是用户给出的两倍。注意 `${NUMERIC:-1}` 这个表示法，它很重要：大多数时候，你根本不给命令一个数字参数，在这种情况下，zle 很自然地将 `$NUMERIC` 视为未设置。这会搞乱算术替换。

顺便说一句，如果你在 shell 函数中犯了错误，你不会看到它；你只会得到一个哔哔声，除非你用 `setopt nobeep` 关闭了它。来自这类函数的输出被丢弃了，因为它会弄乱显示。所以你应该在将函数变成小部件之前进行任何基本的调试，例如，在前面放一个 `print` 并直接运行它——你不能从编辑器外部执行小部件。

以下也有效：

      my-widget() {
        (( NUMERIC = ${NUMERIC:-1} * 2 ))
        zle backward-word
      }

因为你可以直接改变 `$NUMERIC`，并且除非被 `-n` 参数覆盖，否则它会被函数中调用的任何小部件使用。如果你在函数内部调用更多的小部件——你可以调用任意多个——同样的参数将适用于所有没有显式 `-n` 或 `-N` 的小部件。

一些小部件允许你指定非数字参数。目前这些主要是搜索函数，你可以给它们一个明确的搜索字符串。然而，通常你每次都想指定一个新的搜索字符串。我能看到的最有用的使用方式是为增量搜索命令提供一个初始参数。稍后，我将展示你如何以类似于 Emacs 模式的 `^r` 绑定 `history-incremental-search-backwards` 的方式读取字符。

[]{#l106}

### 4.7.3: 一些特殊的内建小部件及其用途

有些事情你可能想在 zle 函数中对编辑器做，但直接从 zle 执行是没用的。一个是像普通小部件那样产生一个错误。你可以用 `zle beep` 来做到这一点。然而，这不会自动在那个点停止你的函数；由你来从函数返回。

通过用 `zle -N` 声明并定义相应的函数，可以重新定义一个内建小部件。从现在开始，所有引用该小部件的现有绑定都会导致你的函数被运行，而不是内建的那个。这是因为 zle 实际上不关心一个小部件做什么，直到它被运行。你可以通过使用 `bindkey` 定义一个键序列来调用一个未定义的小部件，比如 `any-old-string`，来看到这一点。shell 不会抱怨，直到你实际按下该键序列。

然而，有时你想确保调用内建小部件，即使其行为已被重新定义。你可以通过在小部件名称前放一个 `.` 来做到这一点；`zle .up-line-or-history` 总是调用通常被称为 `up-line-or-history` 的内建小部件，即使后者已被重新定义。一个用途是重新绑定 `accept-line`，以便在 zle 即将把一行传递给 shell 时做一些事情，但无论如何都要接受该行：你编写自己的小部件 `accept-line`，确保它在完成前调用 `zle .accept-line`，然后使用 `zle -N accept-line`。这里有一个微不足道但并非完全愚蠢的例子：

      accept-line() {
        print -n "\e]2;Executing $BUFFER\a"
        zle .accept-line
      }
      zle -N accept-line

现在每次你按回车执行一个命令时，那个 `print` 命令都会先被执行。如所写，它将 `Executing` 然后是命令行的内容（见下文）放入你的 xterm 窗口的标题中，假设它理解通常的 xterm 转义序列。实际上，这个特定的例子通常是用特殊的 shell 函数（不是 zle 函数）`preexec` 来处理的，它被传递一个即将被执行的命令行作为参数，而不是在 `$BUFFER` 中。重新绑定 `accept-line` 似乎有一个副作用，即在某些情况下，回车键在 minibuffer 中停止工作。

请注意，要撤销回车执行你的新小部件的事实，你需要将 `accept-line` 别名回 `.accept-line`：

      zle -A .accept-line accept-line

如果你记不住顺序，就像 zsh 和 UNIX 中的大多数别名或重命名命令一样，包括 `ln` 和 `bindkey -A`，你想要保留其属性的现有命令排在第一位，而它的新名称排在第二位。此外，就像那些命令一样，如果行上的第二个名称当前意味着别的东西，那也没关系；那将被新的含义所取代。之后，你不需要担心你自己的 `accept-line` 小部件；zle 会处理移除不再被引用的小部件的细节。然而，函数仍然在那里，因为就 shell 的其余部分而言，它只是一个普通的 shell 函数，你需要用 `unfunction` 来移除它。

但是，请记住，不要用明显的命令删除一个重新定义了基本内部小部件的小部件

      # 不不不！
      zle -D accept-line

这会使回车键除了抱怨没有这样的小部件之外没有任何效果。如果你真的陷入困境，`\ex.accept-line` 应该可以工作，因为你可以像使用任何其他小部件一样使用 `.`-小部件，除非它们会重新定义或删除一个 `.` 小部件。使用上面带有扩展命令形式的 `.accept-line` 的 `zle -A` 命令返回正常。如果你试图重新定义或删除一个 `.` 小部件，zle 会告诉你它受保护。然而，你可以用这种方式移除任何其他小部件，即使它仍然绑定到一个键序列；如果你输入那个序列，你会看到一个错误。

关于 `accept-line` 的一点需要注意的是，该行不会立即传递给 zsh，只有当你的函数退出时才会。当你思考一下时，这很明显；zle 是从主 shell 调用的，如果你的 zle 小部件还没有执行完，主 shell 还没有拿回控制权。但它确实意味着，例如，如果你在调用 `accept-line` 或 `.accept-line` 之后修改命令行，那些更改会反映在传递给 shell 的行中：

      # 这个也别用！
      accept-line() {
        zle .accept-line
        BUFFER='哈哈！'
      }

这总是向主 shell 返回字符串 `哈哈！`。这并不是特别有用，除非你正在为巴黎艺术画廊的装置构建一个塞缪尔·贝克特 shell。

[]{#l107}

### 4.7.4: 特殊参数：普通文本

shell 提供了各种参数，以便于操作命令行。你已经见过 `$NUMERIC`。你可能想知道如果你有自己的名为 `$NUMERIC` 的参数会发生什么；毕竟，它是一个相当简单的用作名称的字符串。好消息是你不需要担心；当 shell 运行一个 zle 函数时，它只是隐藏任何现有的参数出现，并使其特殊参数可用。然后当它退出时，原始参数被重新启用。所以你所要担心的就是确保你在 zle 小部件内部不将这些特殊参数用于任何其他事情。

有四个特别常见的 zle 参数。

首先，有三种引用命令行上文本的方式：`$BUFFER` 是整行作为一个字符串，`$LBUFFER` 是光标位置左边的行，`$RBUFFER` 是它后面的行，包括光标下的字符，所以分割总是在下一个插入字符将要去的地方。这些中的任何一个或所有都可能为空，并且 `$BUFFER` 总是字符串 `$LBUFFER$RBUFFER`。

这些的必要对应物是 `$CURSOR`，它是光标位置，1 是第一个字符。如果你知道 shell 如何在参数替换中处理子字符串，你将能够看到 `$LBUFFER` 是 `$BUFFER[1,$CURSOR-1]`，而 `$RBUFFER` 是 `$BUFFER[$CURSOR,-1]`（除非你正在使用 `KSH_ARRAYS` 选项以与 ksh 的索引兼容——这不推荐用于实现 zle 或补全小部件，因为它会与 shell 提供的那些造成混淆）。

关于这些真正有用的是它们是可修改的。如果你修改 `$LBUFFER` 或 `$RBUFFER`，那么 `$BUFFER` 和 `$CURSOR` 将被适当地修改；加长或缩短 `$LBUFFER` 会增加或减少 `$CURSOR`。如果你修改 `$BUFFER`，你可能需要自己设置 `$CURSOR`，因为 shell 无法确定光标应该在哪里。如果你改变 `$CURSOR`，字符将在 `$LBUFFER` 和 `$RBUFFER` 之间移动，但 `$BUFFER` 将保持不变。

这使得像基本移动和删除命令这样的任务变得极其简单，通常只是一个模式匹配的问题。然而，了解 zsh 更复杂的模式匹配和参数替换特性绝对是有益的，下一章将描述。例如，如果你用

      emulate -L zsh
      setopt extendedglob
      LBUFFER=${LBUFFER%%[^[:blank:]]##}

来开始一个小部件函数，那么 `$LBUFFER` 包含光标左边的行，去掉了紧邻光标左边的所有非空白字符（通常是除了空格或制表符之外的任何东西）。

这个函数使用了参数替换特性 `$`*param*`%%`*pattern*`}`，它从 `$`*param* 的末尾移除 *pattern* 的最长匹配。`emulate -L zsh` 确保为函数适当地设置了 shell 选项，并使所有选项设置都是局部的，`setopt extendedglob` 打开了扩展模式匹配特性；正是这个使得模式中出现的序列 `##` 意味着“前一个模式元素重复一次或多次”。前一个模式元素是“除了空白字符之外的任何东西”。因此，所有非空白字符的出现都从 `$LBUFFER` 的末尾被移除了。

如果你想将光标移过那些字符，你可以稍微调整一下函数：

      emulate -L zsh
      setopt extendedglob
      chars=${(M)LBUFFER%%[^[:blank:]]##}
      (( CURSOR -= ${#chars} ))

字符串 `(M)` 出现在参数替换的开头。这是 zsh 独特的参数标志系统的一部分；这个意味着“插入替换的匹配部分”。换句话说，替换不是返回去掉了末尾非空白字符的 `$LBUFFER`，而是返回它本应去掉的那些字符。要跳过它们现在是一个简单的事情，只需将 `$CURSOR` 减去该字符串的长度。

如果你尝试这些例子，你会发现它们可能不完全是你想要的。特别是，它们不处理普通单词导向函数所做的在非空白字符旁边找到的任何空白字符。然而，你现在有足够的信息来自己添加对此的测试。

如果你变得更老练，你就可以添加对 `$NUMERIC` 的处理。记住，除非用户明确给出，否则这个不会被设置，所以在那种情况下，由你来将它视为 1。

[]{#l108}

### 4.7.5: 其他特殊参数

你可能想要做的大部分事情都可以用我们已经见过的参数来完成。这里有一些关于你可能想如何使用一些其他可用参数的提示。一如既往，要获得一个完整的列表，但提示较少，请参阅手册。

`$KEYS` 告诉你用于调用小部件的键；它是那些原始字符的字符串，没有转换成 `bindkey` 格式。换句话说，如果它是一个单键（可能包括一个控制键或一个 meta 键），`$KEYS` 将只包含一个单字符。所以你可以为不同的键改变小部件的行为。这里有一个非常（非常）简单的函数，像 `self-insert`：

      LBUFFER=$LBUFFER$KEYS

请注意，这对于 `\ex` 扩展命令处理效果不佳；你只会得到行尾的 `^m`。你需要确保任何使用 `$KEYS` 的小部件都被合理地绑定。这也没有处理用于重复字符的数字参数；添加这个是一个相当简单的练习（特别是考虑到 zsh 的“repeat”循环）。

`$WIDGET` 和 `$LASTWIDGET` 告诉你正在执行的当前小部件和前一个的名称。乍一听，这些听起来不那么有用。然而，你可以将 `$WIDGET` 与一个小部件不必与定义它的函数同名的事实结合起来使用。你可以定义

      zle -N this-widget function
      zle -N that-widget function

并在 `function` 内部测试 `$WIDGET`，看它是否包含 `this-widget` 或 `that-widget`。如果它们有很多共享代码，那是一个相当大的简化，而无需编写额外的函数。

`$LASTWIDGET` 倾向于用于一个稍微不同的目的：检查上一个要执行的命令是否与当前命令相同，或者可能只是与它友好。这里是 `up-line-or-beginning-search` 函数的编辑亮点，这是一个介于 `up-line-or-search` 和 `history-beginning-search-backward` 之间的混合体，已添加到 shell 的 `4.1` 发行版中。如果缓冲区中有前几行，它会在它们之间向上移动；否则，如果它是一系列调用此函数的第一个，它会记住光标位置并向后查找具有从开头到该点相同文本的行，并将光标放在行尾；否则，如果刚刚执行了相同的小部件，它会使用旧的光标位置在历史中更远的地方搜索另一个匹配项。

      if [[ $LBUFFER == *$ '\n'* ]]; then
        zle .up-line-or-history
        __searching=''
      else
        if [[ $LASTWIDGET = $__searching ]]; then
          CURSOR=$__savecursor
        else
          __savecursor=$CURSOR
        fi
        __searching=$WIDGET
        zle .history-beginning-search-backward
        zle .end-of-line
      fi

我们测试 `$__searching` 而不是直接测试 `$WIDGET`，以便能够区分我们是在移动行还是在搜索。`$__savecursor` 给出了向后搜索的位置，之后我们将光标放在行尾。以 `__` 开头的参数不是函数局部的，因为我们需要从前一次执行中测试它们，所以它们前面加了下划线，以试图将它们与周围可能存在的其他参数区分开来。

你会看到发行版中提供的实际函数比这个稍微复杂一些；一方面，它使用用户设置的样式来决定其行为。样式在[第六章](zshguide06.html#comp)中描述用于补全小部件，但你可以在 zle 函数中以完全相同的方式使用它们。

`up-line-or-beginning-search` 的完整版本使用了另一个参数，`$PREBUFFER`。它包含 `zle` 已经吸收的任何你无法再编辑的文本——换句话说，在 shell 用 `$PS2` 提示剩余部分之前读入的文本。因此，测试 `[[ -n $PREBUFFER ]]` 实际上是测试你是否在 `$PS2`。你可以用这个来实现 `push-line-or-edit` 风格的行为。

[]{#l109}

### 4.7.6: 读取按键和使用 minibuffer

时不时地，你希望编辑器在中间有用户输入的情况下执行一系列操作。这通常是通过两个命令的组合来完成的。

首先，你可能需要在 minibuffer 中提示用户，就像 `\ex` 做的那样。你可以用 `zle -R` 来做到这一点。它的基本功能是重新显示命令行，刷新你在函数中到目前为止所做的所有更改，但你可以给它一个字符串参数，它会出现在 minibuffer 中，就在命令行下方。你可以在那之后给它一个其他字符串的列表，它们会以类似于可能的补全列表的方式出现，但在这种情况下对 zle 没有特殊意义。

要从用户那里获取输入，你可以使用 `read -k`，它读取单个键（不是序列；不进行查找）。这个命令在 shell 中总是可用的，但在这种情况下，它是由 zle 自己处理的。键以原始字节的形式返回。算术求值的两个功能对于处理这个键很有用：`#key` 返回 `$key` 的第一个字符的 ASCII 码，而 `##`*key* 返回 *key* 的 ASCII 码，其形式是 `bindkey` 会理解的。例如，

      read -k key
      if (( #key == ##\C-g )); then
         ...

使用算术求值。左边的形式将 `$key` 中的第一个字符转换为一个数字，第二个将字面上的 bindkey 风格的字符串 `\C-g` 转换为一个数字（ASCII 7，因为 1 到 26 就是 `\C-a` 到 `\C-z`）。不要将这两种形式与 `$#key` 混淆，后者是参数中字符串的长度，在这种情况下对于单个字节几乎肯定是 1；这种形式在算术替换内外都有效，其他形式只在内部有效。只要可能，推荐使用 `(( ... ))` 形式进行算术替换；你可以用基本的 `[[ ... ]]` 形式来做，因为 `-eq` 和类似的测试将两边都视为算术，尽管你可能需要额外的引用；然而，我知道这样做的唯一好理由是避免在同一个复杂测试中使用两种条件语法。

这些技巧只对相当复杂的函数真正有用。举个例子，看看 zsh 源代码发行版中提供的 `incremental-complete-word` 函数。这个函数通过使用 `#\C-g` 的形式而不是 `##\C-g` 来增加清晰度；它做同样的事情，但双反斜杠非常令人困惑，这就是为什么引入了另一种形式。

[]{#l110}

### 4.7.7: 示例

**transpose-words-about-point**\

这个函数是 `transpose-words` 的一个变体。它有各种曲折。首先，所讨论的单词总是以空格分隔的，既不是 shell 单词，也不是 `$WORDCHARS` 意义上的单词。这使得它相当可预测。

其次，即使光标下的字符不是空白字符，它也会围绕当前点（因此得名）转置单词。我发现这很有用，因为我永远在输入像 `function_name` 这样的复合词，结果发现我应该输入的是 `name_function`。现在我只需将光标定位在下划线上并执行这个小部件。

      emulate -L zsh
      setopt extendedglob

      local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

      pat1=${LBUFFER%%(#b)([^[:blank:]]##)([[:blank:]]#)}
      word1=$match[1]
      ws1=$match[2]

      match=()
      pat2=${RBUFFER##(#b)(?[[:blank:]]#)([^[:blank:]]##)}
      ws2=$match[1]
      word2=$match[2]

      if [[ -n $word1 && -n $word2 ]]; then
        LBUFFER="$pat1$word2$ws1"
        RBUFFER="$ws2$word1$pat2"
      else
        zle beep
      fi

这里唯一聪明的东西是模式匹配。它大量使用了“反向引用”，这是一个扩展的 globbing 特性，用于所有形式的模式匹配，包括，如本例中，参数替换。下一章将完整描述它。要寻找的关键东西是 `(#b)`，它在 `EXTENDED_GLOB` 选项打开时激活反向引用，后面的括号标记出你想要引用的部分，以及对数组 `$match` 的元素的引用，它存储了那些部分。shell 还设置了 `$mbegin` 和 `$mend` 来给出那些匹配的开始和结束位置，这就是为什么那些参数被设为局部的；我们希望保护它们不被函数外部看到，即使我们实际上没有使用它们。

你可能还需要知道关于 `#` 字符：一个在模式后面意味着“零次或多次重复”，两个意味着“一次或多次重复”。最后，字符类中的 `[:blank:]` 指的是任何空白字符；当被否定时，如字符类 `[^[:blank:]]`，它意味着任何非空白字符。有了 `#`，我们匹配一系列空白或非空白字符。鉴于此，你可以算出其余的发生了什么。

这里有一个更复杂的版本。如果你觉得前一个很难，你可能不想仔细看这个。

      emulate -L zsh
      setopt extendedglob

      local wordstyle blankpat wordpat1 wordpat2
      local match mbegin mend pat1 pat2 word1 word2 ws1 ws2

      zstyle -s ':zle:transpose-words-about-point' word-style wordstyle

      case $wordstyle in
        (shell) local bufwords
                # 这会将行分割成 shell 理解的单词。
                bufwords=(${(z)LBUFFER})
                wordpat1="${"(q)bufwords[-1]}""
                # 取 RBUFFER 的子串以跳过第一个字符，
                # 即光标下的那个。
                bufwords=(${(z)RBUFFER[2,-1]})
                wordpat2="${"(q)bufwords[1]}""
                blankpat='[[:blank:]]#'
                ;;
        (space) blankpat='[[:blank:]]#'
                wordpat1='[^[:blank:]]##'
                wordpat2=$wordpat1
                ;;
        (*) local wc=$WORDCHARS
            if [[ $wc = (#b)(?*)-(*) ]]; then
              # 我们需要将任何 `-' 带到前面以避免混淆
              # 字符类... 我们用 `]' 侥幸过关，因为在 zsh 中
              # 如果它被引用，这不是一个模式字符。
              wc=-$match[1]$match[2]
            fi
            # 空白是任何不在由
            # 字母数字和 $wc 中的字符组成的字符类中的东西。
            # 在必要时引用 $wc，因为我们不希望那些
            # 字符稍后被认为是模式字符。
            blankpat="[^${"(q)wc}a-zA-Z0-9]#"
            # 并且一个单词字符是任何其他东西。
            wordpat1="[${"(q)wc}a-zA-Z0-9]##"
            wordpat2=$wordpat1
            ;;
      esac

      # eval 使参数中的任何特殊字符都处于活动状态。
      # 特别是，我们需要周围的 `[' 是 `真实的'。
      # 这就是为什么我们在 `shell' 选项中引用了 wordpats，其中
      # 它们此时必须被视为文字字符串。
      eval pat1='${LBUFFER%%(#b)('${wordpat1}')('${blankpat}')}'
      word1=$match[1]
      ws1=$match[2]

      match=()
      eval pat2='${RBUFFER##(#b)(?'${blankpat}')('${wordpat2}')}'
      ws2=$match[1]
      word2=$match[2]

      if [[ -n $word1 && -n $word2 ]]; then
        LBUFFER="$pat1$word2$ws1"
        RBUFFER="$ws2$word1$pat2"
      else
        zle beep
      fi

增加的是使用样式来定义 shell 如何找到“单词”的能力。默认情况下，单词与 shell 通常认为的单词相同；这是由 case 语句的分支处理的，该分支使用 `$WORDCHARS` 和一点额外的技巧来获得一个匹配被认为是单词一部分的字符集的模式。我们使用 `eval` 是因为它允许我们让 `$wordpat1` 和朋友们的一些部分作为模式字符活动，而其他部分被引用。

这引入了两种类型的参数扩展标志：`${(q)`*param*`}` 添加反斜杠以引用 `$`*param* 中的特殊字符，因此当参数出现在 `eval` 之后时，结果只是原始字符串。`${(z)`*param*`}` 像 shell 命令行被分割成命令和单词一样分割参数，所以结果是一个数组；`z` 代表 zsh-splitting 或你喜欢的 zplitting。

如果你设置

      zstyle ':zle:*' word-style space

你会回到原始函数的行为。

最后，如果你在那个 `zstyle` 命令中用 `shell` 替换 `space`，你会得到在 shell 内部正常使用时被分割的单词；例如，试试

      echo execute the widget 'between these' 'two quoted expressions'

整个带引号的表达式将被转置。你可能会发现，如果你在带引号的表达式中间这样做，你得不到一个合理的结果；那是因为 `(z)`-splitting 不知道如何处理其左右两边未正确完成的引号。一些版本的 shell 有一个 bug（在 4.0.5 中修复），即无法正确分割的表达式，因为引号未完成，末尾会有一个额外的空格字符。

**insert-numeric**\

这里有一个小部件，允许你插入一个 ASCII 字符